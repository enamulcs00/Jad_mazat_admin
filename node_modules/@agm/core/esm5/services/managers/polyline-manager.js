import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { createMVCEventObservable } from '../../utils/mvcarray-utils';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
var PolylineManager = /** @class */ (function () {
    function PolylineManager(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polylines = new Map();
    }
    PolylineManager_1 = PolylineManager;
    PolylineManager._convertPoints = function (line) {
        var path = line._getPoints().map(function (point) {
            return { lat: point.latitude, lng: point.longitude };
        });
        return path;
    };
    PolylineManager._convertPath = function (path) {
        var symbolPath = google.maps.SymbolPath[path];
        if (typeof symbolPath === 'number') {
            return symbolPath;
        }
        else {
            return path;
        }
    };
    PolylineManager._convertIcons = function (line) {
        var icons = line._getIcons().map(function (agmIcon) { return ({
            fixedRotation: agmIcon.fixedRotation,
            offset: agmIcon.offset,
            repeat: agmIcon.repeat,
            icon: {
                anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),
                fillColor: agmIcon.fillColor,
                fillOpacity: agmIcon.fillOpacity,
                path: PolylineManager_1._convertPath(agmIcon.path),
                rotation: agmIcon.rotation,
                scale: agmIcon.scale,
                strokeColor: agmIcon.strokeColor,
                strokeOpacity: agmIcon.strokeOpacity,
                strokeWeight: agmIcon.strokeWeight,
            },
        }); });
        // prune undefineds;
        icons.forEach(function (icon) {
            Object.entries(icon).forEach(function (_a) {
                var _b = tslib_1.__read(_a, 2), key = _b[0], val = _b[1];
                if (typeof val === 'undefined') {
                    delete icon[key];
                }
            });
            if (typeof icon.icon.anchor.x === 'undefined' ||
                typeof icon.icon.anchor.y === 'undefined') {
                delete icon.icon.anchor;
            }
        });
        return icons;
    };
    PolylineManager.prototype.addPolyline = function (line) {
        var _this = this;
        var polylinePromise = this._mapsWrapper.getNativeMap()
            .then(function () { return [PolylineManager_1._convertPoints(line),
            PolylineManager_1._convertIcons(line)]; })
            .then(function (_a) {
            var _b = tslib_1.__read(_a, 2), path = _b[0], icons = _b[1];
            return _this._mapsWrapper.createPolyline({
                clickable: line.clickable,
                draggable: line.draggable,
                editable: line.editable,
                geodesic: line.geodesic,
                strokeColor: line.strokeColor,
                strokeOpacity: line.strokeOpacity,
                strokeWeight: line.strokeWeight,
                visible: line.visible,
                zIndex: line.zIndex,
                path: path,
                icons: icons,
            });
        });
        this._polylines.set(line, polylinePromise);
    };
    PolylineManager.prototype.updatePolylinePoints = function (line) {
        var _this = this;
        var path = PolylineManager_1._convertPoints(line);
        var m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) { return _this._zone.run(function () { l.setPath(path); }); });
    };
    PolylineManager.prototype.updateIconSequences = function (line) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var icons, m;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._mapsWrapper.getNativeMap()];
                    case 1:
                        _a.sent();
                        icons = PolylineManager_1._convertIcons(line);
                        m = this._polylines.get(line);
                        if (m == null) {
                            return [2 /*return*/];
                        }
                        return [2 /*return*/, m.then(function (l) { return _this._zone.run(function () { return l.setOptions({ icons: icons }); }); })];
                }
            });
        });
    };
    PolylineManager.prototype.setPolylineOptions = function (line, options) {
        return this._polylines.get(line).then(function (l) { l.setOptions(options); });
    };
    PolylineManager.prototype.deletePolyline = function (line) {
        var _this = this;
        var m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) {
            return _this._zone.run(function () {
                l.setMap(null);
                _this._polylines.delete(line);
            });
        });
    };
    PolylineManager.prototype.getMVCPath = function (agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var polyline;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._polylines.get(agmPolyline)];
                    case 1:
                        polyline = _a.sent();
                        return [2 /*return*/, polyline.getPath()];
                }
            });
        });
    };
    PolylineManager.prototype.getPath = function (agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getMVCPath(agmPolyline)];
                    case 1: return [2 /*return*/, (_a.sent()).getArray()];
                }
            });
        });
    };
    PolylineManager.prototype.createEventObservable = function (eventName, line) {
        var _this = this;
        return new Observable(function (observer) {
            _this._polylines.get(line).then(function (l) {
                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
            });
        });
    };
    PolylineManager.prototype.createPathEventObservable = function (line) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mvcPath;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getMVCPath(line)];
                    case 1:
                        mvcPath = _a.sent();
                        return [2 /*return*/, createMVCEventObservable(mvcPath)];
                }
            });
        });
    };
    var PolylineManager_1;
    PolylineManager.ctorParameters = function () { return [
        { type: GoogleMapsAPIWrapper },
        { type: NgZone }
    ]; };
    PolylineManager = PolylineManager_1 = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
    ], PolylineManager);
PolylineManager.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: PolylineManager, factory: function PolylineManager_Factory(t) { return new (t || PolylineManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(NgZone)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(PolylineManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: NgZone }]; }, { _mapsWrapper: [], _zone: [], _polylines: [], addPolyline: [], updatePolylinePoints: [], updateIconSequences: [], setPolylineOptions: [], deletePolyline: [], getMVCPath: [], getPath: [], createEventObservable: [], createPathEventObservable: [] });
    return PolylineManager;
}());
export { PolylineManager };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTUvc2VydmljZXMvbWFuYWdlcnMvcG9seWxpbmUtbWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhEQTBLOEQsQUFDekM7Ozs7Ozs0VUFFRyIsImZpbGUiOiJwb2x5bGluZS1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgY3JlYXRlTVZDRXZlbnRPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbXZjYXJyYXktdXRpbHMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBzQVBJV3JhcHBlciB9IGZyb20gJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJztcclxudmFyIFBvbHlsaW5lTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvbHlsaW5lTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XHJcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIFBvbHlsaW5lTWFuYWdlcl8xID0gUG9seWxpbmVNYW5hZ2VyO1xyXG4gICAgUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IGxpbmUuX2dldFBvaW50cygpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGF0OiBwb2ludC5sYXRpdHVkZSwgbG5nOiBwb2ludC5sb25naXR1ZGUgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICBQb2x5bGluZU1hbmFnZXIuX2NvbnZlcnRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGhbcGF0aF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzeW1ib2xQYXRoID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQb2x5bGluZU1hbmFnZXIuX2NvbnZlcnRJY29ucyA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgdmFyIGljb25zID0gbGluZS5fZ2V0SWNvbnMoKS5tYXAoZnVuY3Rpb24gKGFnbUljb24pIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIGZpeGVkUm90YXRpb246IGFnbUljb24uZml4ZWRSb3RhdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0OiBhZ21JY29uLm9mZnNldCxcclxuICAgICAgICAgICAgcmVwZWF0OiBhZ21JY29uLnJlcGVhdCxcclxuICAgICAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yOiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoYWdtSWNvbi5hbmNob3JYLCBhZ21JY29uLmFuY2hvclkpLFxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBhZ21JY29uLmZpbGxDb2xvcixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBhZ21JY29uLmZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgcGF0aDogUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRQYXRoKGFnbUljb24ucGF0aCksXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogYWdtSWNvbi5yb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBhZ21JY29uLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGFnbUljb24uc3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBhZ21JY29uLnN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IGFnbUljb24uc3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pOyB9KTtcclxuICAgICAgICAvLyBwcnVuZSB1bmRlZmluZWRzO1xyXG4gICAgICAgIGljb25zLmZvckVhY2goZnVuY3Rpb24gKGljb24pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaWNvbikuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGljb25ba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvbi5pY29uLmFuY2hvci54ID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGljb24uaWNvbi5hbmNob3IueSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpY29uLmljb24uYW5jaG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGljb25zO1xyXG4gICAgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuYWRkUG9seWxpbmUgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBvbHlsaW5lUHJvbWlzZSA9IHRoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydFBvaW50cyhsaW5lKSxcclxuICAgICAgICAgICAgUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRJY29ucyhsaW5lKV07IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIHBhdGggPSBfYlswXSwgaWNvbnMgPSBfYlsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5bGluZSh7XHJcbiAgICAgICAgICAgICAgICBjbGlja2FibGU6IGxpbmUuY2xpY2thYmxlLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBsaW5lLmRyYWdnYWJsZSxcclxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBsaW5lLmVkaXRhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2VvZGVzaWM6IGxpbmUuZ2VvZGVzaWMsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogbGluZS5zdHJva2VDb2xvcixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGxpbmUuc3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogbGluZS5zdHJva2VXZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBsaW5lLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGxpbmUuekluZGV4LFxyXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgICAgIGljb25zOiBpY29ucyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChsaW5lLCBwb2x5bGluZVByb21pc2UpO1xyXG4gICAgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUG9seWxpbmVQb2ludHMgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhdGggPSBQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydFBvaW50cyhsaW5lKTtcclxuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IGwuc2V0UGF0aChwYXRoKTsgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUudXBkYXRlSWNvblNlcXVlbmNlcyA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpY29ucywgbTtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9tYXBzV3JhcHBlci5nZXROYXRpdmVNYXAoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25zID0gUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRJY29ucyhsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gbC5zZXRPcHRpb25zKHsgaWNvbnM6IGljb25zIH0pOyB9KTsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLnNldFBvbHlsaW5lT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xyXG4gICAgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlUG9seWxpbmUgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbC5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcG9seWxpbmVzLmRlbGV0ZShsaW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5nZXRNVkNQYXRoID0gZnVuY3Rpb24gKGFnbVBvbHlsaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2x5bGluZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9wb2x5bGluZXMuZ2V0KGFnbVBvbHlsaW5lKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvbHlsaW5lLmdldFBhdGgoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uIChhZ21Qb2x5bGluZSkge1xyXG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TVZDUGF0aChhZ21Qb2x5bGluZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmdldEFycmF5KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkge1xyXG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVBhdGhFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbXZjUGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE1WQ1BhdGgobGluZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXZjUGF0aCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNyZWF0ZU1WQ0V2ZW50T2JzZXJ2YWJsZShtdmNQYXRoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBQb2x5bGluZU1hbmFnZXJfMTtcclxuICAgIFBvbHlsaW5lTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0sXHJcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxyXG4gICAgXTsgfTtcclxuICAgIFBvbHlsaW5lTWFuYWdlciA9IFBvbHlsaW5lTWFuYWdlcl8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0dvb2dsZU1hcHNBUElXcmFwcGVyLCBOZ1pvbmVdKVxyXG4gICAgXSwgUG9seWxpbmVNYW5hZ2VyKTtcclxuICAgIHJldHVybiBQb2x5bGluZU1hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFBvbHlsaW5lTWFuYWdlciB9O1xyIl19