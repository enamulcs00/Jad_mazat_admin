import * as tslib_1 from "tslib";
import { Directive, Input } from '@angular/core';
/**
 * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,
 * or custom icons either along the entire line, or in a specific part of it.
 * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize
 *
 * ### Example
 * ```html
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-icon-sequence [fixedRotation]="true" [path]="'FORWARD_OPEN_ARROW'">
 *          </agm-icon-sequence>
 *      </agm-polyline>
 *    </agm-map>
 * ```
 *
 * @export
 * @class AgmPolylineIcon
 */
import * as ɵngcc0 from '@angular/core';
var AgmPolylineIcon = /** @class */ (function () {
    function AgmPolylineIcon() {
    }
    AgmPolylineIcon.prototype.ngOnInit = function () {
        if (this.path == null) {
            throw new Error('Icon Sequence path is required');
        }
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], AgmPolylineIcon.prototype, "fixedRotation", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AgmPolylineIcon.prototype, "offset", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AgmPolylineIcon.prototype, "repeat", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "anchorX", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "anchorY", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AgmPolylineIcon.prototype, "fillColor", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "fillOpacity", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AgmPolylineIcon.prototype, "path", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "rotation", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "scale", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AgmPolylineIcon.prototype, "strokeColor", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "strokeOpacity", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], AgmPolylineIcon.prototype, "strokeWeight", void 0);
AgmPolylineIcon.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: AgmPolylineIcon, selectors: [["agm-icon-sequence"]], factory: function AgmPolylineIcon_Factory(t) { return new (t || AgmPolylineIcon)(); }, inputs: { fixedRotation: "fixedRotation", offset: "offset", repeat: "repeat", anchorX: "anchorX", anchorY: "anchorY", fillColor: "fillColor", fillOpacity: "fillOpacity", path: "path", rotation: "rotation", scale: "scale", strokeColor: "strokeColor", strokeOpacity: "strokeOpacity", strokeWeight: "strokeWeight" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AgmPolylineIcon, [{
        type: Directive,
        args: [{ selector: 'agm-polyline agm-icon-sequence' }]
    }], function () { return []; }, { ngOnInit: [], fixedRotation: [{
            type: Input
        }], offset: [{
            type: Input
        }], repeat: [{
            type: Input
        }], anchorX: [{
            type: Input
        }], anchorY: [{
            type: Input
        }], fillColor: [{
            type: Input
        }], fillOpacity: [{
            type: Input
        }], path: [{
            type: Input
        }], rotation: [{
            type: Input
        }], scale: [{
            type: Input
        }], strokeColor: [{
            type: Input
        }], strokeOpacity: [{
            type: Input
        }], strokeWeight: [{
            type: Input
        }] });
    return AgmPolylineIcon;
}());
export { AgmPolylineIcon };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTUvZGlyZWN0aXZlcy9wb2x5bGluZS1pY29uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQTJEMEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0FHbEMiLCJmaWxlIjoicG9seWxpbmUtaWNvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuLyoqXHJcbiAqIEFnbVBvbHlsaW5lSWNvbiBlbmFibGVzIHRvIGFkZCBwb2x5bGluZSBzZXF1ZW5jZXMgdG8gYWRkIGFycm93cywgY2lyY2xlLFxyXG4gKiBvciBjdXN0b20gaWNvbnMgZWl0aGVyIGFsb25nIHRoZSBlbnRpcmUgbGluZSwgb3IgaW4gYSBzcGVjaWZpYyBwYXJ0IG9mIGl0LlxyXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvc2hhcGVzI3BvbHlsaW5lX2N1c3RvbWl6ZVxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGBodG1sXHJcbiAqICAgIDxhZ20tbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cclxuICogICAgICA8YWdtLXBvbHlsaW5lPlxyXG4gKiAgICAgICAgICA8YWdtLWljb24tc2VxdWVuY2UgW2ZpeGVkUm90YXRpb25dPVwidHJ1ZVwiIFtwYXRoXT1cIidGT1JXQVJEX09QRU5fQVJST1cnXCI+XHJcbiAqICAgICAgICAgIDwvYWdtLWljb24tc2VxdWVuY2U+XHJcbiAqICAgICAgPC9hZ20tcG9seWxpbmU+XHJcbiAqICAgIDwvYWdtLW1hcD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIEFnbVBvbHlsaW5lSWNvblxyXG4gKi9cclxudmFyIEFnbVBvbHlsaW5lSWNvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFnbVBvbHlsaW5lSWNvbigpIHtcclxuICAgIH1cclxuICAgIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGF0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWNvbiBTZXF1ZW5jZSBwYXRoIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQWdtUG9seWxpbmVJY29uLnByb3RvdHlwZSwgXCJmaXhlZFJvdGF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQWdtUG9seWxpbmVJY29uLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBZ21Qb2x5bGluZUljb24ucHJvdG90eXBlLCBcInJlcGVhdFwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwiYW5jaG9yWFwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwiYW5jaG9yWVwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwiZmlsbENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQWdtUG9seWxpbmVJY29uLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwicGF0aFwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBZ21Qb2x5bGluZUljb24ucHJvdG90eXBlLCBcInNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQWdtUG9seWxpbmVJY29uLnByb3RvdHlwZSwgXCJzdHJva2VDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFnbVBvbHlsaW5lSWNvbi5wcm90b3R5cGUsIFwic3Ryb2tlV2VpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBBZ21Qb2x5bGluZUljb24gPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnYWdtLXBvbHlsaW5lIGFnbS1pY29uLXNlcXVlbmNlJyB9KVxyXG4gICAgXSwgQWdtUG9seWxpbmVJY29uKTtcclxuICAgIHJldHVybiBBZ21Qb2x5bGluZUljb247XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEFnbVBvbHlsaW5lSWNvbiB9O1xyIl19