import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';
var AgmPolyline_1;
import { ContentChildren, Directive, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { PolylineManager } from '../services/managers/polyline-manager';
import { AgmPolylineIcon } from './polyline-icon';
import { AgmPolylinePoint } from './polyline-point';
let polylineId = 0;
/**
 * AgmPolyline renders a polyline on a {@link AgmMap}
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    .agm-map-container {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-polyline-point [latitude]="latA" [longitude]="lngA">
 *          </agm-polyline-point>
 *          <agm-polyline-point [latitude]="latB" [longitude]="lngB">
 *          </agm-polyline-point>
 *      </agm-polyline>
 *    </agm-map>
 *  `
 * })
 * ```
 */
let AgmPolyline = AgmPolyline_1 = class AgmPolyline {
    constructor(_polylineManager) {
        this._polylineManager = _polylineManager;
        /**
         * Indicates whether this Polyline handles mouse events. Defaults to true.
         */
        this.clickable = true;
        /**
         * If set to true, the user can drag this shape over the map. The geodesic property defines the
         * mode of dragging. Defaults to false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If set to true, the user can edit this shape by dragging the control points shown at the
         * vertices and on each segment. Defaults to false.
         */
        this.editable = false;
        /**
         * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of
         * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.
         * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions
         * are maintained relative to the surface of the earth. Defaults to false.
         */
        this.geodesic = false;
        /**
         * Whether this polyline is visible on the map. Defaults to true.
         */
        this.visible = true;
        /**
         * This event is fired when the DOM click event is fired on the Polyline.
         */
        this.lineClick = new EventEmitter();
        /**
         * This event is fired when the DOM dblclick event is fired on the Polyline.
         */
        this.lineDblClick = new EventEmitter();
        /**
         * This event is repeatedly fired while the user drags the polyline.
         */
        this.lineDrag = new EventEmitter();
        /**
         * This event is fired when the user stops dragging the polyline.
         */
        this.lineDragEnd = new EventEmitter();
        /**
         * This event is fired when the user starts dragging the polyline.
         */
        this.lineDragStart = new EventEmitter();
        /**
         * This event is fired when the DOM mousedown event is fired on the Polyline.
         */
        this.lineMouseDown = new EventEmitter();
        /**
         * This event is fired when the DOM mousemove event is fired on the Polyline.
         */
        this.lineMouseMove = new EventEmitter();
        /**
         * This event is fired on Polyline mouseout.
         */
        this.lineMouseOut = new EventEmitter();
        /**
         * This event is fired on Polyline mouseover.
         */
        this.lineMouseOver = new EventEmitter();
        /**
         * This event is fired whe the DOM mouseup event is fired on the Polyline
         */
        this.lineMouseUp = new EventEmitter();
        /**
         * This event is fired when the Polyline is right-clicked on.
         */
        this.lineRightClick = new EventEmitter();
        /**
         * This event is fired after Polyline's path changes.
         */
        this.polyPathChange = new EventEmitter();
        this._polylineAddedToManager = false;
        this._subscriptions = [];
        this._id = (polylineId++).toString();
    }
    /** @internal */
    ngAfterContentInit() {
        if (this.points.length) {
            this.points.forEach((point) => {
                const s = point.positionChanged.subscribe(() => { this._polylineManager.updatePolylinePoints(this); });
                this._subscriptions.push(s);
            });
        }
        if (!this._polylineAddedToManager) {
            this._init();
        }
        const pointSub = this.points.changes.subscribe(() => this._polylineManager.updatePolylinePoints(this));
        this._subscriptions.push(pointSub);
        this._polylineManager.updatePolylinePoints(this);
        const iconSub = this.iconSequences.changes.subscribe(() => this._polylineManager.updateIconSequences(this));
        this._subscriptions.push(iconSub);
    }
    ngOnChanges(changes) {
        if (!this._polylineAddedToManager) {
            this._init();
            return;
        }
        let options = {};
        const optionKeys = Object.keys(changes).filter(k => AgmPolyline_1._polylineOptionsAttributes.indexOf(k) !== -1);
        optionKeys.forEach(k => options[k] = changes[k].currentValue);
        this._polylineManager.setPolylineOptions(this, options);
    }
    getPath() {
        return this._polylineManager.getPath(this);
    }
    _init() {
        this._polylineManager.addPolyline(this);
        this._polylineAddedToManager = true;
        this._addEventListeners();
    }
    _addEventListeners() {
        const handlers = [
            { name: 'click', handler: (ev) => this.lineClick.emit(ev) },
            { name: 'dblclick', handler: (ev) => this.lineDblClick.emit(ev) },
            { name: 'drag', handler: (ev) => this.lineDrag.emit(ev) },
            { name: 'dragend', handler: (ev) => this.lineDragEnd.emit(ev) },
            { name: 'dragstart', handler: (ev) => this.lineDragStart.emit(ev) },
            { name: 'mousedown', handler: (ev) => this.lineMouseDown.emit(ev) },
            { name: 'mousemove', handler: (ev) => this.lineMouseMove.emit(ev) },
            { name: 'mouseout', handler: (ev) => this.lineMouseOut.emit(ev) },
            { name: 'mouseover', handler: (ev) => this.lineMouseOver.emit(ev) },
            { name: 'mouseup', handler: (ev) => this.lineMouseUp.emit(ev) },
            { name: 'rightclick', handler: (ev) => this.lineRightClick.emit(ev) },
        ];
        handlers.forEach((obj) => {
            const os = this._polylineManager.createEventObservable(obj.name, this).subscribe(obj.handler);
            this._subscriptions.push(os);
        });
        this._polylineManager.createPathEventObservable(this).then((ob$) => {
            const os = ob$.subscribe(pathEvent => this.polyPathChange.emit(pathEvent));
            this._subscriptions.push(os);
        });
    }
    /** @internal */
    _getPoints() {
        if (this.points) {
            return this.points.toArray();
        }
        return [];
    }
    _getIcons() {
        if (this.iconSequences) {
            return this.iconSequences.toArray();
        }
        return [];
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    ngOnDestroy() {
        this._polylineManager.deletePolyline(this);
        // unsubscribe all registered observable subscriptions
        this._subscriptions.forEach((s) => s.unsubscribe());
    }
}
AgmPolyline.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: AgmPolyline, selectors: [["agm-polyline"]], factory: function AgmPolyline_Factory(t) { return new (t || AgmPolyline)(ɵngcc0.ɵɵdirectiveInject(PolylineManager)); }, contentQueries: function AgmPolyline_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmPolylinePoint, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmPolylineIcon, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.points = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.iconSequences = _t);
    } }, inputs: { clickable: "clickable", draggable: ["polylineDraggable", "draggable"], editable: "editable", geodesic: "geodesic", visible: "visible", strokeColor: "strokeColor", strokeOpacity: "strokeOpacity", strokeWeight: "strokeWeight", zIndex: "zIndex" }, outputs: { lineClick: "lineClick", lineDblClick: "lineDblClick", lineDrag: "lineDrag", lineDragEnd: "lineDragEnd", lineDragStart: "lineDragStart", lineMouseDown: "lineMouseDown", lineMouseMove: "lineMouseMove", lineMouseOut: "lineMouseOut", lineMouseOver: "lineMouseOver", lineMouseUp: "lineMouseUp", lineRightClick: "lineRightClick", polyPathChange: "polyPathChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AgmPolyline, [{
        type: Directive,
        args: [{
                selector: 'agm-polyline'
            }]
    }], function () { return [{ type: PolylineManager }]; }, { constructor: [], _polylineManager: [], clickable: [{
            type: Input
        }], draggable: [{
            type: Input,
            args: ['polylineDraggable']
        }], editable: [{
            type: Input
        }], geodesic: [{
            type: Input
        }], visible: [{
            type: Input
        }], lineClick: [{
            type: Output
        }], lineDblClick: [{
            type: Output
        }], lineDrag: [{
            type: Output
        }], lineDragEnd: [{
            type: Output
        }], lineDragStart: [{
            type: Output
        }], lineMouseDown: [{
            type: Output
        }], lineMouseMove: [{
            type: Output
        }], lineMouseOut: [{
            type: Output
        }], lineMouseOver: [{
            type: Output
        }], lineMouseUp: [{
            type: Output
        }], lineRightClick: [{
            type: Output
        }], polyPathChange: [{
            type: Output
        }], _polylineAddedToManager: [], _subscriptions: [], _id: [], ngAfterContentInit: [], ngOnChanges: [], getPath: [], _init: [], _addEventListeners: [], _getPoints: [], _getIcons: [], id: [], ngOnDestroy: [], strokeColor: [{
            type: Input
        }], strokeOpacity: [{
            type: Input
        }], strokeWeight: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], points: [{
            type: ContentChildren,
            args: [AgmPolylinePoint]
        }], iconSequences: [{
            type: ContentChildren,
            args: [AgmPolylineIcon]
        }] });;
AgmPolyline._polylineOptionsAttributes = [
    'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',
    'zIndex',
];
AgmPolyline.ctorParameters = () => [
    { type: PolylineManager }
];
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "clickable", void 0);
tslib_1.__decorate([
    Input('polylineDraggable'),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "draggable", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "editable", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "geodesic", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], AgmPolyline.prototype, "strokeColor", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], AgmPolyline.prototype, "strokeOpacity", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], AgmPolyline.prototype, "strokeWeight", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "visible", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], AgmPolyline.prototype, "zIndex", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineDblClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineDrag", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineDragEnd", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineDragStart", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineMouseDown", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineMouseMove", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineMouseOut", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineMouseOver", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineMouseUp", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], AgmPolyline.prototype, "lineRightClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", Object)
], AgmPolyline.prototype, "polyPathChange", void 0);
tslib_1.__decorate([
    ContentChildren(AgmPolylinePoint),
    tslib_1.__metadata("design:type", QueryList)
], AgmPolyline.prototype, "points", void 0);
tslib_1.__decorate([
    ContentChildren(AgmPolylineIcon),
    tslib_1.__metadata("design:type", QueryList)
], AgmPolyline.prototype, "iconSequences", void 0);
AgmPolyline = AgmPolyline_1 = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [PolylineManager])
], AgmPolyline);
export { AgmPolyline };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvZGlyZWN0aXZlcy9wb2x5bGluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQWlNQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREFvR2lELEFBRzNDIiwiZmlsZSI6InBvbHlsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxudmFyIEFnbVBvbHlsaW5lXzE7XHJcbmltcG9ydCB7IENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQb2x5bGluZU1hbmFnZXIgfSBmcm9tICcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJztcclxuaW1wb3J0IHsgQWdtUG9seWxpbmVJY29uIH0gZnJvbSAnLi9wb2x5bGluZS1pY29uJztcclxuaW1wb3J0IHsgQWdtUG9seWxpbmVQb2ludCB9IGZyb20gJy4vcG9seWxpbmUtcG9pbnQnO1xyXG5sZXQgcG9seWxpbmVJZCA9IDA7XHJcbi8qKlxyXG4gKiBBZ21Qb2x5bGluZSByZW5kZXJzIGEgcG9seWxpbmUgb24gYSB7QGxpbmsgQWdtTWFwfVxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgIC5hZ20tbWFwLWNvbnRhaW5lciB7XHJcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcclxuICogICAgfVxyXG4gKiBgXSxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDxhZ20tbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cclxuICogICAgICA8YWdtLXBvbHlsaW5lPlxyXG4gKiAgICAgICAgICA8YWdtLXBvbHlsaW5lLXBvaW50IFtsYXRpdHVkZV09XCJsYXRBXCIgW2xvbmdpdHVkZV09XCJsbmdBXCI+XHJcbiAqICAgICAgICAgIDwvYWdtLXBvbHlsaW5lLXBvaW50PlxyXG4gKiAgICAgICAgICA8YWdtLXBvbHlsaW5lLXBvaW50IFtsYXRpdHVkZV09XCJsYXRCXCIgW2xvbmdpdHVkZV09XCJsbmdCXCI+XHJcbiAqICAgICAgICAgIDwvYWdtLXBvbHlsaW5lLXBvaW50PlxyXG4gKiAgICAgIDwvYWdtLXBvbHlsaW5lPlxyXG4gKiAgICA8L2FnbS1tYXA+XHJcbiAqICBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxubGV0IEFnbVBvbHlsaW5lID0gQWdtUG9seWxpbmVfMSA9IGNsYXNzIEFnbVBvbHlsaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKF9wb2x5bGluZU1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIgPSBfcG9seWxpbmVNYW5hZ2VyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgUG9seWxpbmUgaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZHJhZyB0aGlzIHNoYXBlIG92ZXIgdGhlIG1hcC4gVGhlIGdlb2Rlc2ljIHByb3BlcnR5IGRlZmluZXMgdGhlXHJcbiAgICAgICAgICogbW9kZSBvZiBkcmFnZ2luZy4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxyXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0IHRoZVxyXG4gICAgICAgICAqIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRydWUsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZSBpbnRlcnByZXRlZCBhcyBnZW9kZXNpYyBhbmQgd2lsbCBmb2xsb3cgdGhlIGN1cnZhdHVyZSBvZlxyXG4gICAgICAgICAqIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIHJlbmRlcmVkIGFzIHN0cmFpZ2h0IGxpbmVzIGluIHNjcmVlbiBzcGFjZS5cclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGEgZ2VvZGVzaWMgcG9seWdvbiBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXHJcbiAgICAgICAgICogYXJlIG1haW50YWluZWQgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVhcnRoLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdlb2Rlc2ljID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGlzIHBvbHlsaW5lIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5bGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW5lRGJsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5bGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVEcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW5lRHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVEcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5bGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVNb3VzZURvd24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5bGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVNb3VzZU1vdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVNb3VzZU91dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlsaW5lIG1vdXNlb3Zlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVNb3VzZU92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGUgdGhlIERPTSBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5bGluZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGluZU1vdXNlVXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBQb2x5bGluZSBpcyByaWdodC1jbGlja2VkIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGluZVJpZ2h0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciBQb2x5bGluZSdzIHBhdGggY2hhbmdlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvbHlQYXRoQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5faWQgPSAocG9seWxpbmVJZCsrKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBwb2ludC5wb3NpdGlvbkNoYW5nZWQuc3Vic2NyaWJlKCgpID0+IHsgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKHRoaXMpOyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBvaW50U3ViID0gdGhpcy5wb2ludHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gocG9pbnRTdWIpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci51cGRhdGVQb2x5bGluZVBvaW50cyh0aGlzKTtcclxuICAgICAgICBjb25zdCBpY29uU3ViID0gdGhpcy5pY29uU2VxdWVuY2VzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3BvbHlsaW5lTWFuYWdlci51cGRhdGVJY29uU2VxdWVuY2VzKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goaWNvblN1Yik7XHJcbiAgICB9XHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoayA9PiBBZ21Qb2x5bGluZV8xLl9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKTtcclxuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goayA9PiBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5zZXRQb2x5bGluZU9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZU1hbmFnZXIuZ2V0UGF0aCh0aGlzKTtcclxuICAgIH1cclxuICAgIF9pbml0KCkge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5hZGRQb2x5bGluZSh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgfVxyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IChldikgPT4gdGhpcy5saW5lQ2xpY2suZW1pdChldikgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXYpID0+IHRoaXMubGluZURibENsaWNrLmVtaXQoZXYpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiAoZXYpID0+IHRoaXMubGluZURyYWcuZW1pdChldikgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZ2VuZCcsIGhhbmRsZXI6IChldikgPT4gdGhpcy5saW5lRHJhZ0VuZC5lbWl0KGV2KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXYpID0+IHRoaXMubGluZURyYWdTdGFydC5lbWl0KGV2KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiAoZXYpID0+IHRoaXMubGluZU1vdXNlRG93bi5lbWl0KGV2KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW1vdmUnLCBoYW5kbGVyOiAoZXYpID0+IHRoaXMubGluZU1vdXNlTW92ZS5lbWl0KGV2KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldikgPT4gdGhpcy5saW5lTW91c2VPdXQuZW1pdChldikgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2KSA9PiB0aGlzLmxpbmVNb3VzZU92ZXIuZW1pdChldikgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2V1cCcsIGhhbmRsZXI6IChldikgPT4gdGhpcy5saW5lTW91c2VVcC5lbWl0KGV2KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2KSA9PiB0aGlzLmxpbmVSaWdodENsaWNrLmVtaXQoZXYpIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3MgPSB0aGlzLl9wb2x5bGluZU1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCB0aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gob3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5jcmVhdGVQYXRoRXZlbnRPYnNlcnZhYmxlKHRoaXMpLnRoZW4oKG9iJCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcyA9IG9iJC5zdWJzY3JpYmUocGF0aEV2ZW50ID0+IHRoaXMucG9seVBhdGhDaGFuZ2UuZW1pdChwYXRoRXZlbnQpKTtcclxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRQb2ludHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50cy50b0FycmF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIF9nZXRJY29ucygpIHtcclxuICAgICAgICBpZiAodGhpcy5pY29uU2VxdWVuY2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmljb25TZXF1ZW5jZXMudG9BcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBpZCgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuZGVsZXRlUG9seWxpbmUodGhpcyk7XHJcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgfVxyXG59O1xyXG5BZ21Qb2x5bGluZS5fcG9seWxpbmVPcHRpb25zQXR0cmlidXRlcyA9IFtcclxuICAgICdkcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAndmlzaWJsZScsICdnZW9kZXNpYycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsXHJcbiAgICAnekluZGV4JyxcclxuXTtcclxuQWdtUG9seWxpbmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IFBvbHlsaW5lTWFuYWdlciB9XHJcbl07XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwiY2xpY2thYmxlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgncG9seWxpbmVEcmFnZ2FibGUnKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcImRyYWdnYWJsZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5wdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcImVkaXRhYmxlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwiZ2VvZGVzaWNcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJzdHJva2VDb2xvclwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5wdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXZWlnaHRcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwiekluZGV4XCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcImxpbmVDbGlja1wiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJsaW5lRGJsQ2xpY2tcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZURyYWdcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZURyYWdFbmRcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZURyYWdTdGFydFwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJsaW5lTW91c2VEb3duXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcImxpbmVNb3VzZU1vdmVcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZU1vdXNlT3V0XCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcImxpbmVNb3VzZU92ZXJcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZU1vdXNlVXBcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwibGluZVJpZ2h0Q2xpY2tcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBZ21Qb2x5bGluZS5wcm90b3R5cGUsIFwicG9seVBhdGhDaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIENvbnRlbnRDaGlsZHJlbihBZ21Qb2x5bGluZVBvaW50KSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcclxuXSwgQWdtUG9seWxpbmUucHJvdG90eXBlLCBcInBvaW50c1wiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgQ29udGVudENoaWxkcmVuKEFnbVBvbHlsaW5lSWNvbiksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXHJcbl0sIEFnbVBvbHlsaW5lLnByb3RvdHlwZSwgXCJpY29uU2VxdWVuY2VzXCIsIHZvaWQgMCk7XHJcbkFnbVBvbHlsaW5lID0gQWdtUG9seWxpbmVfMSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgIHNlbGVjdG9yOiAnYWdtLXBvbHlsaW5lJyxcclxuICAgIH0pLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvbHlsaW5lTWFuYWdlcl0pXHJcbl0sIEFnbVBvbHlsaW5lKTtcclxuZXhwb3J0IHsgQWdtUG9seWxpbmUgfTtcciJdfQ==