import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { bindCallback, Observable, of, ReplaySubject, throwError } from 'rxjs';
import { map, multicast, switchMap } from 'rxjs/operators';
import { GeocoderStatus } from './google-maps-types';
import { MapsAPILoader } from './maps-api-loader/maps-api-loader';
import * as i0 from "@angular/core";
import * as i1 from "./maps-api-loader/maps-api-loader";
import * as ɵngcc0 from '@angular/core';
let AgmGeocoder = class AgmGeocoder {
    constructor(loader) {
        const connectableGeocoder$ = new Observable(subscriber => {
            loader.load().then(() => subscriber.next());
        })
            .pipe(map(() => this._createGeocoder()), multicast(new ReplaySubject(1)));
        connectableGeocoder$.connect(); // ignore the subscription
        // since we will remain subscribed till application exits
        this.geocoder$ = connectableGeocoder$;
    }
    geocode(request) {
        return this.geocoder$.pipe(switchMap((geocoder) => this._getGoogleResults(geocoder, request)));
    }
    _getGoogleResults(geocoder, request) {
        const geocodeObservable = bindCallback(geocoder.geocode);
        return geocodeObservable(request).pipe(switchMap(([results, status]) => {
            if (status === GeocoderStatus.OK) {
                return of(results);
            }
            return throwError(status);
        }));
    }
    _createGeocoder() {
        return new google.maps.Geocoder();
    }
}
AgmGeocoder.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: AgmGeocoder, factory: function AgmGeocoder_Factory(t) { return new (t || AgmGeocoder)(ɵngcc0.ɵɵinject(MapsAPILoader)); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AgmGeocoder, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: MapsAPILoader }]; }, { constructor: [], geocoder$: [], geocode: [], _getGoogleResults: [], _createGeocoder: [] });;
AgmGeocoder.ctorParameters = () => [
    { type: MapsAPILoader }
];
AgmGeocoder.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function AgmGeocoder_Factory() { return new AgmGeocoder(i0.ɵɵinject(i1.MapsAPILoader)); }, token: AgmGeocoder, providedIn: "root" });
AgmGeocoder = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [MapsAPILoader])
], AgmGeocoder);
export { AgmGeocoder };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvZ2VvY29kZXItc2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3SkF5QkM7Ozs7O2tDQUtpQyxBQUNLIiwiZmlsZSI6Imdlb2NvZGVyLXNlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGJpbmRDYWxsYmFjaywgT2JzZXJ2YWJsZSwgb2YsIFJlcGxheVN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCBtdWx0aWNhc3QsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgR2VvY29kZXJTdGF0dXMgfSBmcm9tICcuL2dvb2dsZS1tYXBzLXR5cGVzJztcclxuaW1wb3J0IHsgTWFwc0FQSUxvYWRlciB9IGZyb20gJy4vbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlcic7XHJcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCAqIGFzIGkxIGZyb20gXCIuL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXJcIjtcclxubGV0IEFnbUdlb2NvZGVyID0gY2xhc3MgQWdtR2VvY29kZXIge1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyKSB7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGVHZW9jb2RlciQgPSBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVyID0+IHtcclxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKS50aGVuKCgpID0+IHN1YnNjcmliZXIubmV4dCgpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAucGlwZShtYXAoKCkgPT4gdGhpcy5fY3JlYXRlR2VvY29kZXIoKSksIG11bHRpY2FzdChuZXcgUmVwbGF5U3ViamVjdCgxKSkpO1xyXG4gICAgICAgIGNvbm5lY3RhYmxlR2VvY29kZXIkLmNvbm5lY3QoKTsgLy8gaWdub3JlIHRoZSBzdWJzY3JpcHRpb25cclxuICAgICAgICAvLyBzaW5jZSB3ZSB3aWxsIHJlbWFpbiBzdWJzY3JpYmVkIHRpbGwgYXBwbGljYXRpb24gZXhpdHNcclxuICAgICAgICB0aGlzLmdlb2NvZGVyJCA9IGNvbm5lY3RhYmxlR2VvY29kZXIkO1xyXG4gICAgfVxyXG4gICAgZ2VvY29kZShyZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvY29kZXIkLnBpcGUoc3dpdGNoTWFwKChnZW9jb2RlcikgPT4gdGhpcy5fZ2V0R29vZ2xlUmVzdWx0cyhnZW9jb2RlciwgcmVxdWVzdCkpKTtcclxuICAgIH1cclxuICAgIF9nZXRHb29nbGVSZXN1bHRzKGdlb2NvZGVyLCByZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgZ2VvY29kZU9ic2VydmFibGUgPSBiaW5kQ2FsbGJhY2soZ2VvY29kZXIuZ2VvY29kZSk7XHJcbiAgICAgICAgcmV0dXJuIGdlb2NvZGVPYnNlcnZhYmxlKHJlcXVlc3QpLnBpcGUoc3dpdGNoTWFwKChbcmVzdWx0cywgc3RhdHVzXSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBHZW9jb2RlclN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHN0YXR1cyk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZUdlb2NvZGVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcclxuICAgIH1cclxufTtcclxuQWdtR2VvY29kZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IE1hcHNBUElMb2FkZXIgfVxyXG5dO1xyXG5BZ21HZW9jb2Rlci5uZ0luamVjdGFibGVEZWYgPSBpMC7Jtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIEFnbUdlb2NvZGVyX0ZhY3RvcnkoKSB7IHJldHVybiBuZXcgQWdtR2VvY29kZXIoaTAuybXJtWluamVjdChpMS5NYXBzQVBJTG9hZGVyKSk7IH0sIHRva2VuOiBBZ21HZW9jb2RlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XHJcbkFnbUdlb2NvZGVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWFwc0FQSUxvYWRlcl0pXHJcbl0sIEFnbUdlb2NvZGVyKTtcclxuZXhwb3J0IHsgQWdtR2VvY29kZXIgfTtcciJdfQ==