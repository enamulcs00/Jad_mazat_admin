import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
let CircleManager = class CircleManager {
    constructor(_apiWrapper, _zone) {
        this._apiWrapper = _apiWrapper;
        this._zone = _zone;
        this._circles = new Map();
    }
    addCircle(circle) {
        this._circles.set(circle, this._apiWrapper.createCircle({
            center: { lat: circle.latitude, lng: circle.longitude },
            clickable: circle.clickable,
            draggable: circle.draggable,
            editable: circle.editable,
            fillColor: circle.fillColor,
            fillOpacity: circle.fillOpacity,
            radius: circle.radius,
            strokeColor: circle.strokeColor,
            strokeOpacity: circle.strokeOpacity,
            strokePosition: circle.strokePosition,
            strokeWeight: circle.strokeWeight,
            visible: circle.visible,
            zIndex: circle.zIndex,
        }));
    }
    /**
     * Removes the given circle from the map.
     */
    removeCircle(circle) {
        return this._circles.get(circle).then((c) => {
            c.setMap(null);
            this._circles.delete(circle);
        });
    }
    setOptions(circle, options) {
        return this._circles.get(circle).then((c) => {
            if (typeof options.strokePosition === 'string') {
                options.strokePosition = google.maps.StrokePosition[options.strokePosition];
            }
            c.setOptions(options);
        });
    }
    getBounds(circle) {
        return this._circles.get(circle).then((c) => c.getBounds());
    }
    getCenter(circle) {
        return this._circles.get(circle).then((c) => c.getCenter());
    }
    getRadius(circle) {
        return this._circles.get(circle).then((c) => c.getRadius());
    }
    setCenter(circle) {
        return this._circles.get(circle).then((c) => { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });
    }
    setEditable(circle) {
        return this._circles.get(circle).then((c) => { return c.setEditable(circle.editable); });
    }
    setDraggable(circle) {
        return this._circles.get(circle).then((c) => { return c.setDraggable(circle.draggable); });
    }
    setVisible(circle) {
        return this._circles.get(circle).then((c) => { return c.setVisible(circle.visible); });
    }
    setRadius(circle) {
        return this._circles.get(circle).then((c) => { return c.setRadius(circle.radius); });
    }
    getNativeCircle(circle) {
        return this._circles.get(circle);
    }
    createEventObservable(eventName, circle) {
        return new Observable((observer) => {
            let listener = null;
            this._circles.get(circle).then((c) => {
                listener = c.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
            return () => {
                if (listener !== null) {
                    listener.remove();
                }
            };
        });
    }
}
CircleManager.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: CircleManager, factory: function CircleManager_Factory(t) { return new (t || CircleManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(NgZone)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CircleManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: NgZone }]; }, { constructor: [], _apiWrapper: [], _zone: [], _circles: [], addCircle: [], removeCircle: [], setOptions: [], getBounds: [], getCenter: [], getRadius: [], setCenter: [], setEditable: [], setDraggable: [], setVisible: [], setRadius: [], getNativeCircle: [], createEventObservable: [] });;
CircleManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: NgZone }
];
CircleManager = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
], CircleManager);
export { CircleManager };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFuYWdlcnMvY2lyY2xlLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrWEFnRkM7Ozs7O29DQUttQyxBQUNuQiIsImZpbGUiOiJjaXJjbGUtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0gZnJvbSAnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInO1xyXG5sZXQgQ2lyY2xlTWFuYWdlciA9IGNsYXNzIENpcmNsZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX2FwaVdyYXBwZXIsIF96b25lKSB7XHJcbiAgICAgICAgdGhpcy5fYXBpV3JhcHBlciA9IF9hcGlXcmFwcGVyO1xyXG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcclxuICAgICAgICB0aGlzLl9jaXJjbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgYWRkQ2lyY2xlKGNpcmNsZSkge1xyXG4gICAgICAgIHRoaXMuX2NpcmNsZXMuc2V0KGNpcmNsZSwgdGhpcy5fYXBpV3JhcHBlci5jcmVhdGVDaXJjbGUoe1xyXG4gICAgICAgICAgICBjZW50ZXI6IHsgbGF0OiBjaXJjbGUubGF0aXR1ZGUsIGxuZzogY2lyY2xlLmxvbmdpdHVkZSB9LFxyXG4gICAgICAgICAgICBjbGlja2FibGU6IGNpcmNsZS5jbGlja2FibGUsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2lyY2xlLmRyYWdnYWJsZSxcclxuICAgICAgICAgICAgZWRpdGFibGU6IGNpcmNsZS5lZGl0YWJsZSxcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBjaXJjbGUuZmlsbENvbG9yLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogY2lyY2xlLmZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICByYWRpdXM6IGNpcmNsZS5yYWRpdXMsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBjaXJjbGUuc3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGNpcmNsZS5zdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICBzdHJva2VQb3NpdGlvbjogY2lyY2xlLnN0cm9rZVBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IGNpcmNsZS5zdHJva2VXZWlnaHQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGNpcmNsZS52aXNpYmxlLFxyXG4gICAgICAgICAgICB6SW5kZXg6IGNpcmNsZS56SW5kZXgsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaXJjbGUgZnJvbSB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVDaXJjbGUoY2lyY2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbigoYykgPT4ge1xyXG4gICAgICAgICAgICBjLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlcy5kZWxldGUoY2lyY2xlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldE9wdGlvbnMoY2lyY2xlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbigoYykgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3Ryb2tlUG9zaXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cm9rZVBvc2l0aW9uID0gZ29vZ2xlLm1hcHMuU3Ryb2tlUG9zaXRpb25bb3B0aW9ucy5zdHJva2VQb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYy5zZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0Qm91bmRzKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IGMuZ2V0Qm91bmRzKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2VudGVyKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IGMuZ2V0Q2VudGVyKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmFkaXVzKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IGMuZ2V0UmFkaXVzKCkpO1xyXG4gICAgfVxyXG4gICAgc2V0Q2VudGVyKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IHsgcmV0dXJuIGMuc2V0Q2VudGVyKHsgbGF0OiBjaXJjbGUubGF0aXR1ZGUsIGxuZzogY2lyY2xlLmxvbmdpdHVkZSB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICBzZXRFZGl0YWJsZShjaXJjbGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKChjKSA9PiB7IHJldHVybiBjLnNldEVkaXRhYmxlKGNpcmNsZS5lZGl0YWJsZSk7IH0pO1xyXG4gICAgfVxyXG4gICAgc2V0RHJhZ2dhYmxlKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IHsgcmV0dXJuIGMuc2V0RHJhZ2dhYmxlKGNpcmNsZS5kcmFnZ2FibGUpOyB9KTtcclxuICAgIH1cclxuICAgIHNldFZpc2libGUoY2lyY2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbigoYykgPT4geyByZXR1cm4gYy5zZXRWaXNpYmxlKGNpcmNsZS52aXNpYmxlKTsgfSk7XHJcbiAgICB9XHJcbiAgICBzZXRSYWRpdXMoY2lyY2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbigoYykgPT4geyByZXR1cm4gYy5zZXRSYWRpdXMoY2lyY2xlLnJhZGl1cyk7IH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TmF0aXZlQ2lyY2xlKGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnRPYnNlcnZhYmxlKGV2ZW50TmFtZSwgY2lyY2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oKGMpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gYy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIChlKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbkNpcmNsZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0sXHJcbiAgICB7IHR5cGU6IE5nWm9uZSB9XHJcbl07XHJcbkNpcmNsZU1hbmFnZXIgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0dvb2dsZU1hcHNBUElXcmFwcGVyLCBOZ1pvbmVdKVxyXG5dLCBDaXJjbGVNYW5hZ2VyKTtcclxuZXhwb3J0IHsgQ2lyY2xlTWFuYWdlciB9O1xyIl19