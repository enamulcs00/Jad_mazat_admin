import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';
var PolylineManager_1;
import { Injectable, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { createMVCEventObservable } from '../../utils/mvcarray-utils';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
let PolylineManager = PolylineManager_1 = class PolylineManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polylines = new Map();
    }
    static _convertPoints(line) {
        const path = line._getPoints().map((point) => {
            return { lat: point.latitude, lng: point.longitude };
        });
        return path;
    }
    static _convertPath(path) {
        const symbolPath = google.maps.SymbolPath[path];
        if (typeof symbolPath === 'number') {
            return symbolPath;
        }
        else {
            return path;
        }
    }
    static _convertIcons(line) {
        const icons = line._getIcons().map(agmIcon => ({
            fixedRotation: agmIcon.fixedRotation,
            offset: agmIcon.offset,
            repeat: agmIcon.repeat,
            icon: {
                anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),
                fillColor: agmIcon.fillColor,
                fillOpacity: agmIcon.fillOpacity,
                path: PolylineManager_1._convertPath(agmIcon.path),
                rotation: agmIcon.rotation,
                scale: agmIcon.scale,
                strokeColor: agmIcon.strokeColor,
                strokeOpacity: agmIcon.strokeOpacity,
                strokeWeight: agmIcon.strokeWeight,
            },
        }));
        // prune undefineds;
        icons.forEach(icon => {
            Object.entries(icon).forEach(([key, val]) => {
                if (typeof val === 'undefined') {
                    delete icon[key];
                }
            });
            if (typeof icon.icon.anchor.x === 'undefined' ||
                typeof icon.icon.anchor.y === 'undefined') {
                delete icon.icon.anchor;
            }
        });
        return icons;
    }
    addPolyline(line) {
        const polylinePromise = this._mapsWrapper.getNativeMap()
            .then(() => [PolylineManager_1._convertPoints(line),
            PolylineManager_1._convertIcons(line)])
            .then(([path, icons]) => this._mapsWrapper.createPolyline({
            clickable: line.clickable,
            draggable: line.draggable,
            editable: line.editable,
            geodesic: line.geodesic,
            strokeColor: line.strokeColor,
            strokeOpacity: line.strokeOpacity,
            strokeWeight: line.strokeWeight,
            visible: line.visible,
            zIndex: line.zIndex,
            path: path,
            icons: icons,
        }));
        this._polylines.set(line, polylinePromise);
    }
    updatePolylinePoints(line) {
        const path = PolylineManager_1._convertPoints(line);
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => { return this._zone.run(() => { l.setPath(path); }); });
    }
    updateIconSequences(line) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this._mapsWrapper.getNativeMap();
            const icons = PolylineManager_1._convertIcons(line);
            const m = this._polylines.get(line);
            if (m == null) {
                return;
            }
            return m.then(l => this._zone.run(() => l.setOptions({ icons: icons })));
        });
    }
    setPolylineOptions(line, options) {
        return this._polylines.get(line).then((l) => { l.setOptions(options); });
    }
    deletePolyline(line) {
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => {
            return this._zone.run(() => {
                l.setMap(null);
                this._polylines.delete(line);
            });
        });
    }
    getMVCPath(agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const polyline = yield this._polylines.get(agmPolyline);
            return polyline.getPath();
        });
    }
    getPath(agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.getMVCPath(agmPolyline)).getArray();
        });
    }
    createEventObservable(eventName, line) {
        return new Observable((observer) => {
            this._polylines.get(line).then((l) => {
                l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    createPathEventObservable(line) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mvcPath = yield this.getMVCPath(line);
            return createMVCEventObservable(mvcPath);
        });
    }
}
PolylineManager.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: PolylineManager, factory: function PolylineManager_Factory(t) { return new (t || PolylineManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(NgZone)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(PolylineManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: NgZone }]; }, { constructor: [], _mapsWrapper: [], _zone: [], _polylines: [], addPolyline: [], updatePolylinePoints: [], updateIconSequences: [], setPolylineOptions: [], deletePolyline: [], getMVCPath: [], getPath: [], createEventObservable: [], createPathEventObservable: [] });;
PolylineManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: NgZone }
];
PolylineManager = PolylineManager_1 = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
], PolylineManager);
export { PolylineManager };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFuYWdlcnMvcG9seWxpbmUtbWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZWQXNJQzs7Ozs7MERBS3lELEFBQ3pDIiwiZmlsZSI6InBvbHlsaW5lLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG52YXIgUG9seWxpbmVNYW5hZ2VyXzE7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNyZWF0ZU1WQ0V2ZW50T2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL212Y2FycmF5LXV0aWxzJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwc0FQSVdyYXBwZXIgfSBmcm9tICcuLi9nb29nbGUtbWFwcy1hcGktd3JhcHBlcic7XHJcbmxldCBQb2x5bGluZU1hbmFnZXIgPSBQb2x5bGluZU1hbmFnZXJfMSA9IGNsYXNzIFBvbHlsaW5lTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XHJcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY29udmVydFBvaW50cyhsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGxpbmUuX2dldFBvaW50cygpLm1hcCgocG9pbnQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGF0OiBwb2ludC5sYXRpdHVkZSwgbG5nOiBwb2ludC5sb25naXR1ZGUgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY29udmVydFBhdGgocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IHN5bWJvbFBhdGggPSBnb29nbGUubWFwcy5TeW1ib2xQYXRoW3BhdGhdO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sUGF0aCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NvbnZlcnRJY29ucyhsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgaWNvbnMgPSBsaW5lLl9nZXRJY29ucygpLm1hcChhZ21JY29uID0+ICh7XHJcbiAgICAgICAgICAgIGZpeGVkUm90YXRpb246IGFnbUljb24uZml4ZWRSb3RhdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0OiBhZ21JY29uLm9mZnNldCxcclxuICAgICAgICAgICAgcmVwZWF0OiBhZ21JY29uLnJlcGVhdCxcclxuICAgICAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yOiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoYWdtSWNvbi5hbmNob3JYLCBhZ21JY29uLmFuY2hvclkpLFxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBhZ21JY29uLmZpbGxDb2xvcixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBhZ21JY29uLmZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgcGF0aDogUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRQYXRoKGFnbUljb24ucGF0aCksXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogYWdtSWNvbi5yb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBhZ21JY29uLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGFnbUljb24uc3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBhZ21JY29uLnN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IGFnbUljb24uc3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBwcnVuZSB1bmRlZmluZWRzO1xyXG4gICAgICAgIGljb25zLmZvckVhY2goaWNvbiA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGljb24pLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpY29uW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGljb24uaWNvbi5hbmNob3IueCA9PT0gJ3VuZGVmaW5lZCcgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBpY29uLmljb24uYW5jaG9yLnkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaWNvbi5pY29uLmFuY2hvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpY29ucztcclxuICAgIH1cclxuICAgIGFkZFBvbHlsaW5lKGxpbmUpIHtcclxuICAgICAgICBjb25zdCBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5nZXROYXRpdmVNYXAoKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiBbUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRQb2ludHMobGluZSksXHJcbiAgICAgICAgICAgIFBvbHlsaW5lTWFuYWdlcl8xLl9jb252ZXJ0SWNvbnMobGluZSldKVxyXG4gICAgICAgICAgICAudGhlbigoW3BhdGgsIGljb25zXSkgPT4gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlUG9seWxpbmUoe1xyXG4gICAgICAgICAgICBjbGlja2FibGU6IGxpbmUuY2xpY2thYmxlLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGxpbmUuZHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICBlZGl0YWJsZTogbGluZS5lZGl0YWJsZSxcclxuICAgICAgICAgICAgZ2VvZGVzaWM6IGxpbmUuZ2VvZGVzaWMsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBsaW5lLnN0cm9rZUNvbG9yLFxyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBsaW5lLnN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogbGluZS5zdHJva2VXZWlnaHQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGxpbmUudmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBsaW5lLnpJbmRleCxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgaWNvbnM6IGljb25zLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZXMuc2V0KGxpbmUsIHBvbHlsaW5lUHJvbWlzZSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQb2x5bGluZVBvaW50cyhsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IFBvbHlsaW5lTWFuYWdlcl8xLl9jb252ZXJ0UG9pbnRzKGxpbmUpO1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsKSA9PiB7IHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7IGwuc2V0UGF0aChwYXRoKTsgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSWNvblNlcXVlbmNlcyhsaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9tYXBzV3JhcHBlci5nZXROYXRpdmVNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgaWNvbnMgPSBQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydEljb25zKGxpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKTtcclxuICAgICAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtLnRoZW4obCA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBsLnNldE9wdGlvbnMoeyBpY29uczogaWNvbnMgfSkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldFBvbHlsaW5lT3B0aW9ucyhsaW5lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbigobCkgPT4geyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlUG9seWxpbmUobGluZSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5kZWxldGUobGluZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TVZDUGF0aChhZ21Qb2x5bGluZSkge1xyXG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWxpbmUgPSB5aWVsZCB0aGlzLl9wb2x5bGluZXMuZ2V0KGFnbVBvbHlsaW5lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lLmdldFBhdGgoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFBhdGgoYWdtUG9seWxpbmUpIHtcclxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgdGhpcy5nZXRNVkNQYXRoKGFnbVBvbHlsaW5lKSkuZ2V0QXJyYXkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShldmVudE5hbWUsIGxpbmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbigobCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIChlKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUGF0aEV2ZW50T2JzZXJ2YWJsZShsaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBtdmNQYXRoID0geWllbGQgdGhpcy5nZXRNVkNQYXRoKGxpbmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTVZDRXZlbnRPYnNlcnZhYmxlKG12Y1BhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5Qb2x5bGluZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0sXHJcbiAgICB7IHR5cGU6IE5nWm9uZSB9XHJcbl07XHJcblBvbHlsaW5lTWFuYWdlciA9IFBvbHlsaW5lTWFuYWdlcl8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIEluamVjdGFibGUoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHb29nbGVNYXBzQVBJV3JhcHBlciwgTmdab25lXSlcclxuXSwgUG9seWxpbmVNYW5hZ2VyKTtcclxuZXhwb3J0IHsgUG9seWxpbmVNYW5hZ2VyIH07XHIiXX0=