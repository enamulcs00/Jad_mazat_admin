import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
import { MarkerManager } from './marker-manager';
import * as ɵngcc0 from '@angular/core';
let InfoWindowManager = class InfoWindowManager {
    constructor(_mapsWrapper, _zone, _markerManager) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._markerManager = _markerManager;
        this._infoWindows = new Map();
    }
    deleteInfoWindow(infoWindow) {
        const iWindow = this._infoWindows.get(infoWindow);
        if (iWindow == null) {
            // info window already deleted
            return Promise.resolve();
        }
        return iWindow.then((i) => {
            return this._zone.run(() => {
                i.close();
                this._infoWindows.delete(infoWindow);
            });
        });
    }
    setPosition(infoWindow) {
        return this._infoWindows.get(infoWindow).then((i) => i.setPosition({
            lat: infoWindow.latitude,
            lng: infoWindow.longitude,
        }));
    }
    setZIndex(infoWindow) {
        return this._infoWindows.get(infoWindow)
            .then((i) => i.setZIndex(infoWindow.zIndex));
    }
    open(infoWindow) {
        return this._infoWindows.get(infoWindow).then((w) => {
            if (infoWindow.hostMarker != null) {
                return this._markerManager.getNativeMarker(infoWindow.hostMarker).then((marker) => {
                    return this._mapsWrapper.getNativeMap().then((map) => w.open(map, marker));
                });
            }
            return this._mapsWrapper.getNativeMap().then((map) => w.open(map));
        });
    }
    close(infoWindow) {
        return this._infoWindows.get(infoWindow).then((w) => w.close());
    }
    setOptions(infoWindow, options) {
        return this._infoWindows.get(infoWindow).then((i) => i.setOptions(options));
    }
    addInfoWindow(infoWindow) {
        const options = {
            content: infoWindow.content,
            maxWidth: infoWindow.maxWidth,
            zIndex: infoWindow.zIndex,
            disableAutoPan: infoWindow.disableAutoPan,
        };
        if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {
            options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };
        }
        const infoWindowPromise = this._mapsWrapper.createInfoWindow(options);
        this._infoWindows.set(infoWindow, infoWindowPromise);
    }
    /**
     * Creates a Google Maps event listener for the given InfoWindow as an Observable
     */
    createEventObservable(eventName, infoWindow) {
        return new Observable((observer) => {
            this._infoWindows.get(infoWindow).then((i) => {
                i.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
}
InfoWindowManager.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: InfoWindowManager, factory: function InfoWindowManager_Factory(t) { return new (t || InfoWindowManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(NgZone), ɵngcc0.ɵɵinject(MarkerManager)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(InfoWindowManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: NgZone }, { type: MarkerManager }]; }, { constructor: [], _mapsWrapper: [], _zone: [], _markerManager: [], _infoWindows: [], deleteInfoWindow: [], setPosition: [], setZIndex: [], open: [], close: [], setOptions: [], addInfoWindow: [], createEventObservable: [] });;
InfoWindowManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: NgZone },
    { type: MarkerManager }
];
InfoWindowManager = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone,
        MarkerManager])
], InfoWindowManager);
export { InfoWindowManager };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFuYWdlcnMvaW5mby13aW5kb3ctbWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OFVBcUVDOzs7Ozs7d0NBTXVDLEFBQ3ZCIiwiZmlsZSI6ImluZm8td2luZG93LW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBzQVBJV3JhcHBlciB9IGZyb20gJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJztcclxuaW1wb3J0IHsgTWFya2VyTWFuYWdlciB9IGZyb20gJy4vbWFya2VyLW1hbmFnZXInO1xyXG5sZXQgSW5mb1dpbmRvd01hbmFnZXIgPSBjbGFzcyBJbmZvV2luZG93TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbWFwc1dyYXBwZXIsIF96b25lLCBfbWFya2VyTWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xyXG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyID0gX21hcmtlck1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvd3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVJbmZvV2luZG93KGluZm9XaW5kb3cpIHtcclxuICAgICAgICBjb25zdCBpV2luZG93ID0gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpO1xyXG4gICAgICAgIGlmIChpV2luZG93ID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW5mbyB3aW5kb3cgYWxyZWFkeSBkZWxldGVkXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlXaW5kb3cudGhlbigoaSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaS5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd3MuZGVsZXRlKGluZm9XaW5kb3cpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldFBvc2l0aW9uKGluZm9XaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oKGkpID0+IGkuc2V0UG9zaXRpb24oe1xyXG4gICAgICAgICAgICBsYXQ6IGluZm9XaW5kb3cubGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIGxuZzogaW5mb1dpbmRvdy5sb25naXR1ZGUsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgc2V0WkluZGV4KGluZm9XaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpXHJcbiAgICAgICAgICAgIC50aGVuKChpKSA9PiBpLnNldFpJbmRleChpbmZvV2luZG93LnpJbmRleCkpO1xyXG4gICAgfVxyXG4gICAgb3BlbihpbmZvV2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKCh3KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmZvV2luZG93Lmhvc3RNYXJrZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlck1hbmFnZXIuZ2V0TmF0aXZlTWFya2VyKGluZm9XaW5kb3cuaG9zdE1hcmtlcikudGhlbigobWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oKG1hcCkgPT4gdy5vcGVuKG1hcCwgbWFya2VyKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwc1dyYXBwZXIuZ2V0TmF0aXZlTWFwKCkudGhlbigobWFwKSA9PiB3Lm9wZW4obWFwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZShpbmZvV2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKCh3KSA9PiB3LmNsb3NlKCkpO1xyXG4gICAgfVxyXG4gICAgc2V0T3B0aW9ucyhpbmZvV2luZG93LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKChpKSA9PiBpLnNldE9wdGlvbnMob3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgYWRkSW5mb1dpbmRvdyhpbmZvV2luZG93KSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29udGVudDogaW5mb1dpbmRvdy5jb250ZW50LFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogaW5mb1dpbmRvdy5tYXhXaWR0aCxcclxuICAgICAgICAgICAgekluZGV4OiBpbmZvV2luZG93LnpJbmRleCxcclxuICAgICAgICAgICAgZGlzYWJsZUF1dG9QYW46IGluZm9XaW5kb3cuZGlzYWJsZUF1dG9QYW4sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGluZm9XaW5kb3cubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmZvV2luZG93LmxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHsgbGF0OiBpbmZvV2luZG93LmxhdGl0dWRlLCBsbmc6IGluZm9XaW5kb3cubG9uZ2l0dWRlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZm9XaW5kb3dQcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9pbmZvV2luZG93cy5zZXQoaW5mb1dpbmRvdywgaW5mb1dpbmRvd1Byb21pc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIE1hcHMgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBJbmZvV2luZG93IGFzIGFuIE9ic2VydmFibGVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlRXZlbnRPYnNlcnZhYmxlKGV2ZW50TmFtZSwgaW5mb1dpbmRvdykge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oKGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGkuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuSW5mb1dpbmRvd01hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0sXHJcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxyXG4gICAgeyB0eXBlOiBNYXJrZXJNYW5hZ2VyIH1cclxuXTtcclxuSW5mb1dpbmRvd01hbmFnZXIgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0dvb2dsZU1hcHNBUElXcmFwcGVyLCBOZ1pvbmUsXHJcbiAgICAgICAgTWFya2VyTWFuYWdlcl0pXHJcbl0sIEluZm9XaW5kb3dNYW5hZ2VyKTtcclxuZXhwb3J0IHsgSW5mb1dpbmRvd01hbmFnZXIgfTtcciJdfQ==