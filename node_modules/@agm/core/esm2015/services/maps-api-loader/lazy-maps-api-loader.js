import * as tslib_1 from "tslib";
import { Inject, Injectable, InjectionToken, LOCALE_ID, Optional } from '@angular/core';
import { DocumentRef, WindowRef } from '../../utils/browser-globals';
import { MapsAPILoader } from './maps-api-loader';
import * as ɵngcc0 from '@angular/core';
export var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
/**
 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
 * LazyMapsAPILoaderConfig}.
 */
export const LAZY_MAPS_API_CONFIG = new InjectionToken('angular-google-maps LAZY_MAPS_API_CONFIG');
let LazyMapsAPILoader = class LazyMapsAPILoader extends MapsAPILoader {
    constructor(config = null, w, d, localeId) {
        super();
        this.localeId = localeId;
        this._SCRIPT_ID = 'agmGoogleMapsApiScript';
        this.callbackName = `agmLazyMapsAPILoader`;
        this._config = config || {};
        this._windowRef = w;
        this._documentRef = d;
    }
    load() {
        const window = this._windowRef.getNativeWindow();
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this._scriptLoadingPromise) {
            return this._scriptLoadingPromise;
        }
        // this can happen in HMR situations or Stackblitz.io editors.
        const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);
        if (scriptOnPage) {
            this._assignScriptLoadingPromise(scriptOnPage);
            return this._scriptLoadingPromise;
        }
        const script = this._documentRef.getNativeDocument().createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this._SCRIPT_ID;
        script.src = this._getScriptSrc(this.callbackName);
        this._assignScriptLoadingPromise(script);
        this._documentRef.getNativeDocument().body.appendChild(script);
        return this._scriptLoadingPromise;
    }
    _assignScriptLoadingPromise(scriptElem) {
        this._scriptLoadingPromise = new Promise((resolve, reject) => {
            this._windowRef.getNativeWindow()[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    _getScriptSrc(callbackName) {
        let protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol;
        switch (protocolType) {
            case GoogleMapsScriptProtocol.AUTO:
                protocol = '';
                break;
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
        const queryParams = {
            v: this._config.apiVersion || 'quarterly',
            callback: callbackName,
            key: this._config.apiKey,
            client: this._config.clientId,
            channel: this._config.channel,
            libraries: this._config.libraries,
            region: this._config.region,
            language: this._config.language || this.localeId !== 'en-US' ? this.localeId : null,
        };
        const params = Object.keys(queryParams)
            .filter((k) => queryParams[k] != null)
            .filter((k) => {
            // remove empty arrays
            return !Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
        })
            .map((k) => {
            // join arrays as comma seperated strings
            let i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        })
            .map((entry) => {
            return `${entry.key}=${entry.value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
}
LazyMapsAPILoader.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: LazyMapsAPILoader, factory: function LazyMapsAPILoader_Factory(t) { return new (t || LazyMapsAPILoader)(ɵngcc0.ɵɵinject(LAZY_MAPS_API_CONFIG, 8), ɵngcc0.ɵɵinject(WindowRef), ɵngcc0.ɵɵinject(DocumentRef), ɵngcc0.ɵɵinject(LOCALE_ID)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LazyMapsAPILoader, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LAZY_MAPS_API_CONFIG]
            }] }, { type: WindowRef }, { type: DocumentRef }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { constructor: [], localeId: [], _SCRIPT_ID: [], callbackName: [], _config: [], _windowRef: [], _documentRef: [], load: [], _assignScriptLoadingPromise: [], _scriptLoadingPromise: [], _getScriptSrc: [] });;
LazyMapsAPILoader.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_MAPS_API_CONFIG,] }] },
    { type: WindowRef },
    { type: DocumentRef },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
LazyMapsAPILoader = tslib_1.__decorate([
    tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(LAZY_MAPS_API_CONFIG)),
    tslib_1.__param(3, Inject(LOCALE_ID)),
    tslib_1.__metadata("design:paramtypes", [Object, WindowRef, DocumentRef, String])
], LazyMapsAPILoader);
export { LazyMapsAPILoader };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bU9Bc0dDOzs7Ozs7O3dDQU91QyxBQUN2QiIsImZpbGUiOiJsYXp5LW1hcHMtYXBpLWxvYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIExPQ0FMRV9JRCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRG9jdW1lbnRSZWYsIFdpbmRvd1JlZiB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXItZ2xvYmFscyc7XHJcbmltcG9ydCB7IE1hcHNBUElMb2FkZXIgfSBmcm9tICcuL21hcHMtYXBpLWxvYWRlcic7XHJcbmV4cG9ydCB2YXIgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sO1xyXG4oZnVuY3Rpb24gKEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCkge1xyXG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBcIl0gPSAxXSA9IFwiSFRUUFwiO1xyXG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBTXCJdID0gMl0gPSBcIkhUVFBTXCI7XHJcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiQVVUT1wiXSA9IDNdID0gXCJBVVRPXCI7XHJcbn0pKEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCB8fCAoR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcclxuLyoqXHJcbiAqIFRva2VuIGZvciB0aGUgY29uZmlnIG9mIHRoZSBMYXp5TWFwc0FQSUxvYWRlci4gUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IG9mIHR5cGUge0BsaW5rXHJcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBMQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignYW5ndWxhci1nb29nbGUtbWFwcyBMQVpZX01BUFNfQVBJX0NPTkZJRycpO1xyXG5sZXQgTGF6eU1hcHNBUElMb2FkZXIgPSBjbGFzcyBMYXp5TWFwc0FQSUxvYWRlciBleHRlbmRzIE1hcHNBUElMb2FkZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0gbnVsbCwgdywgZCwgbG9jYWxlSWQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubG9jYWxlSWQgPSBsb2NhbGVJZDtcclxuICAgICAgICB0aGlzLl9TQ1JJUFRfSUQgPSAnYWdtR29vZ2xlTWFwc0FwaVNjcmlwdCc7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja05hbWUgPSBgYWdtTGF6eU1hcHNBUElMb2FkZXJgO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICB0aGlzLl93aW5kb3dSZWYgPSB3O1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmID0gZDtcclxuICAgIH1cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpO1xyXG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcykge1xyXG4gICAgICAgICAgICAvLyBHb29nbGUgbWFwcyBhbHJlYWR5IGxvYWRlZCBvbiB0aGUgcGFnZS5cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaW4gSE1SIHNpdHVhdGlvbnMgb3IgU3RhY2tibGl0ei5pbyBlZGl0b3JzLlxyXG4gICAgICAgIGNvbnN0IHNjcmlwdE9uUGFnZSA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuZ2V0RWxlbWVudEJ5SWQodGhpcy5fU0NSSVBUX0lEKTtcclxuICAgICAgICBpZiAoc2NyaXB0T25QYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2lnblNjcmlwdExvYWRpbmdQcm9taXNlKHNjcmlwdE9uUGFnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gdGhpcy5fZG9jdW1lbnRSZWYuZ2V0TmF0aXZlRG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XHJcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcclxuICAgICAgICBzY3JpcHQuaWQgPSB0aGlzLl9TQ1JJUFRfSUQ7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuX2dldFNjcmlwdFNyYyh0aGlzLmNhbGxiYWNrTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fYXNzaWduU2NyaXB0TG9hZGluZ1Byb21pc2Uoc2NyaXB0KTtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XHJcbiAgICB9XHJcbiAgICBfYXNzaWduU2NyaXB0TG9hZGluZ1Byb21pc2Uoc2NyaXB0RWxlbSkge1xyXG4gICAgICAgIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl93aW5kb3dSZWYuZ2V0TmF0aXZlV2luZG93KClbdGhpcy5jYWxsYmFja05hbWVdID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzY3JpcHRFbGVtLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0U2NyaXB0U3JjKGNhbGxiYWNrTmFtZSkge1xyXG4gICAgICAgIGxldCBwcm90b2NvbFR5cGUgPSAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTO1xyXG4gICAgICAgIGxldCBwcm90b2NvbDtcclxuICAgICAgICBzd2l0Y2ggKHByb3RvY29sVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5BVVRPOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cHM6JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aCA9IHRoaXMuX2NvbmZpZy5ob3N0QW5kUGF0aCB8fCAnbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHY6IHRoaXMuX2NvbmZpZy5hcGlWZXJzaW9uIHx8ICdxdWFydGVybHknLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tOYW1lLFxyXG4gICAgICAgICAgICBrZXk6IHRoaXMuX2NvbmZpZy5hcGlLZXksXHJcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5fY29uZmlnLmNsaWVudElkLFxyXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLl9jb25maWcuY2hhbm5lbCxcclxuICAgICAgICAgICAgbGlicmFyaWVzOiB0aGlzLl9jb25maWcubGlicmFyaWVzLFxyXG4gICAgICAgICAgICByZWdpb246IHRoaXMuX2NvbmZpZy5yZWdpb24sXHJcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLl9jb25maWcubGFuZ3VhZ2UgfHwgdGhpcy5sb2NhbGVJZCAhPT0gJ2VuLVVTJyA/IHRoaXMubG9jYWxlSWQgOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IHF1ZXJ5UGFyYW1zW2tdICE9IG51bGwpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IGFycmF5c1xyXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XHJcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgJiYgcXVlcnlQYXJhbXNba10ubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcCgoaykgPT4ge1xyXG4gICAgICAgICAgICAvLyBqb2luIGFycmF5cyBhcyBjb21tYSBzZXBlcmF0ZWQgc3RyaW5nc1xyXG4gICAgICAgICAgICBsZXQgaSA9IHF1ZXJ5UGFyYW1zW2tdO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogaS5qb2luKCcsJykgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtlbnRyeS5rZXl9PSR7ZW50cnkudmFsdWV9YDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbignJicpO1xyXG4gICAgICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdEFuZFBhdGh9PyR7cGFyYW1zfWA7XHJcbiAgICB9XHJcbn07XHJcbkxhenlNYXBzQVBJTG9hZGVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xyXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTEFaWV9NQVBTX0FQSV9DT05GSUcsXSB9XSB9LFxyXG4gICAgeyB0eXBlOiBXaW5kb3dSZWYgfSxcclxuICAgIHsgdHlwZTogRG9jdW1lbnRSZWYgfSxcclxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtMT0NBTEVfSUQsXSB9XSB9XHJcbl07XHJcbkxhenlNYXBzQVBJTG9hZGVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIEluamVjdGFibGUoKSxcclxuICAgIHRzbGliXzEuX19wYXJhbSgwLCBPcHRpb25hbCgpKSwgdHNsaWJfMS5fX3BhcmFtKDAsIEluamVjdChMQVpZX01BUFNfQVBJX0NPTkZJRykpLFxyXG4gICAgdHNsaWJfMS5fX3BhcmFtKDMsIEluamVjdChMT0NBTEVfSUQpKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYsIFN0cmluZ10pXHJcbl0sIExhenlNYXBzQVBJTG9hZGVyKTtcclxuZXhwb3J0IHsgTGF6eU1hcHNBUElMb2FkZXIgfTtcciJdfQ==