{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@ckeditor/ckeditor5-angular/fesm2015/ckeditor-ckeditor5-angular.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgeC,aAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyBD,uLAOC","file":"ckeditor-ckeditor5-angular.js","sourcesContent":["import { __awaiter } from 'tslib';\r\nimport EditorWatchdog from '@ckeditor/ckeditor5-watchdog/src/editorwatchdog';\r\nimport { Component, Input, Output, NgZone, EventEmitter, forwardRef, ElementRef, NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\r\n * For licensing, see LICENSE.md.\r\n */\r\n/**\r\n * Basic typings for the CKEditor5 elements.\r\n */\r\nvar CKEditor5;\r\n(function (CKEditor5) {\r\n    /**\r\n     * The CKEditor5 editor constructor.\r\n     * @record\r\n     */\r\n    function EditorConstructor() { }\r\n    CKEditor5.EditorConstructor = EditorConstructor;\r\n    /**\r\n     * The CKEditor5 editor config.\r\n     * @record\r\n     */\r\n    function Config() { }\r\n    CKEditor5.Config = Config;\r\n    /**\r\n     * The event object passed to CKEditor5 event callbacks.\r\n     *\r\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_utils_eventinfo-EventInfo.html\r\n     * @record\r\n     * @template EventName\r\n     */\r\n    function EventInfo() { }\r\n    CKEditor5.EventInfo = EventInfo;\r\n    /**\r\n     * The base Editor class.\r\n     *\r\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\r\n     * @record\r\n     */\r\n    function BaseEditor() { }\r\n    CKEditor5.BaseEditor = BaseEditor;\r\n    /**\r\n     * The CKEditor5 DataApi interface.\r\n     *\r\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_utils_dataapimixin-DataApi.html.\r\n     * @record\r\n     */\r\n    function DataApi() { }\r\n    CKEditor5.DataApi = DataApi;\r\n    /**\r\n     * A CKEditor5 editor that implements the\r\n     * [DataApi interface](https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_utils_dataapimixin-DataApi.html).\r\n     * E.g. the `ClassicEditor`, `InlineEditor`, etc.\r\n     * @record\r\n     */\r\n    function Editor() { }\r\n    CKEditor5.Editor = Editor;\r\n    /**\r\n     * @record\r\n     */\r\n    function ContextWatchdog() { }\r\n    CKEditor5.ContextWatchdog = ContextWatchdog;\r\n    /**\r\n     * @record\r\n     */\r\n    function EditorWatchdog$$1() { }\r\n    CKEditor5.EditorWatchdog = EditorWatchdog$$1;\r\n    /**\r\n     * @record\r\n     * @template T\r\n     */\r\n    function Watchdog() { }\r\n    CKEditor5.Watchdog = Watchdog;\r\n})(CKEditor5 || (CKEditor5 = {}));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\r\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\r\n */\r\n// A copy of @ckeditor/ckeditor5-utils/src/uid.js\r\n// A hash table of hex numbers to avoid using toString() in uid() which is costly.\r\n// [ '00', '01', '02', ..., 'fe', 'ff' ]\r\nconst ɵ0 = /**\r\n * @param {?} val\r\n * @param {?} index\r\n * @return {?}\r\n */\r\n(val, index) => ('0' + (index).toString(16)).slice(-2);\r\n/** @type {?} */\r\nconst HEX_NUMBERS = new Array(256).fill(0)\r\n    .map((ɵ0));\r\n/**\r\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\r\n * 32 alphanumeric characters.\r\n *\r\n * **Note**: The characters the unique id is built from correspond to the hex number notation\r\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\r\n * by 16 8-bit numbers next to each other.\r\n *\r\n * @return {?} An unique id string.\r\n */\r\nfunction uid() {\r\n    // Let's create some positive random 32bit integers first.\r\n    //\r\n    // 1. Math.random() is a float between 0 and 1.\r\n    // 2. 0x100000000 is 2^32 = 4294967296.\r\n    // 3. >>> 0 enforces integer (in JS all numbers are floating point).\r\n    //\r\n    // For instance:\r\n    //\t\tMath.random() * 0x100000000 = 3366450031.853859\r\n    // but\r\n    //\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\r\n    /** @type {?} */\r\n    const r1 = Math.random() * 0x100000000 >>> 0;\r\n    /** @type {?} */\r\n    const r2 = Math.random() * 0x100000000 >>> 0;\r\n    /** @type {?} */\r\n    const r3 = Math.random() * 0x100000000 >>> 0;\r\n    /** @type {?} */\r\n    const r4 = Math.random() * 0x100000000 >>> 0;\r\n    // Make sure that id does not start with number.\r\n    return 'e' +\r\n        HEX_NUMBERS[r1 >> 0 & 0xFF] +\r\n        HEX_NUMBERS[r1 >> 8 & 0xFF] +\r\n        HEX_NUMBERS[r1 >> 16 & 0xFF] +\r\n        HEX_NUMBERS[r1 >> 24 & 0xFF] +\r\n        HEX_NUMBERS[r2 >> 0 & 0xFF] +\r\n        HEX_NUMBERS[r2 >> 8 & 0xFF] +\r\n        HEX_NUMBERS[r2 >> 16 & 0xFF] +\r\n        HEX_NUMBERS[r2 >> 24 & 0xFF] +\r\n        HEX_NUMBERS[r3 >> 0 & 0xFF] +\r\n        HEX_NUMBERS[r3 >> 8 & 0xFF] +\r\n        HEX_NUMBERS[r3 >> 16 & 0xFF] +\r\n        HEX_NUMBERS[r3 >> 24 & 0xFF] +\r\n        HEX_NUMBERS[r4 >> 0 & 0xFF] +\r\n        HEX_NUMBERS[r4 >> 8 & 0xFF] +\r\n        HEX_NUMBERS[r4 >> 16 & 0xFF] +\r\n        HEX_NUMBERS[r4 >> 24 & 0xFF];\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CKEditorComponent {\r\n    /**\r\n     * @param {?} elementRef\r\n     * @param {?} ngZone\r\n     */\r\n    constructor(elementRef, ngZone) {\r\n        /**\r\n         * The configuration of the editor.\r\n         * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html\r\n         * to learn more.\r\n         */\r\n        this.config = {};\r\n        /**\r\n         * The initial data of the editor. Useful when not using the ngModel.\r\n         * See https://angular.io/api/forms/NgModel to learn more.\r\n         */\r\n        this.data = '';\r\n        /**\r\n         * Tag name of the editor component.\r\n         *\r\n         * The default tag is 'div'.\r\n         */\r\n        this.tagName = 'div';\r\n        /**\r\n         * Fires when the editor is ready. It corresponds with the `editor#ready`\r\n         * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready\r\n         * event.\r\n         */\r\n        this.ready = new EventEmitter();\r\n        /**\r\n         * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`\r\n         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change\r\n         * event.\r\n         */\r\n        this.change = new EventEmitter();\r\n        /**\r\n         * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`\r\n         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur\r\n         * event.\r\n         */\r\n        this.blur = new EventEmitter();\r\n        /**\r\n         * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`\r\n         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus\r\n         * event.\r\n         */\r\n        this.focus = new EventEmitter();\r\n        /**\r\n         * Fires when the editor component crashes.\r\n         */\r\n        this.error = new EventEmitter();\r\n        /**\r\n         * If the component is read–only before the editor instance is created, it remembers that state,\r\n         * so the editor can become read–only once it is ready.\r\n         */\r\n        this.initiallyDisabled = false;\r\n        /**\r\n         * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.\r\n         */\r\n        this.isEditorSettingData = false;\r\n        this.id = uid();\r\n        this.ngZone = ngZone;\r\n        this.elementRef = elementRef;\r\n    }\r\n    /**\r\n     * When set `true`, the editor becomes read-only.\r\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#member-isReadOnly\r\n     * to learn more.\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    set disabled(isDisabled) {\r\n        this.setDisabledState(isDisabled);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get disabled() {\r\n        if (this.editorInstance) {\r\n            return this.editorInstance.isReadOnly;\r\n        }\r\n        return this.initiallyDisabled;\r\n    }\r\n    /**\r\n     * The instance of the editor created by this component.\r\n     * @return {?}\r\n     */\r\n    get editorInstance() {\r\n        /** @type {?} */\r\n        let editorWatchdog = this.editorWatchdog;\r\n        if (this.watchdog) {\r\n            // Temporarily use the `_watchdogs` internal map as the `getItem()` method throws\r\n            // an error when the item is not registered yet.\r\n            // See https://github.com/ckeditor/ckeditor5-angular/issues/177.\r\n            editorWatchdog = this.watchdog._watchdogs.get(this.id);\r\n        }\r\n        if (editorWatchdog) {\r\n            return editorWatchdog.editor;\r\n        }\r\n        return null;\r\n    }\r\n    // Implementing the AfterViewInit interface.\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterViewInit() {\r\n        this.attachToWatchdog();\r\n    }\r\n    // Implementing the OnDestroy interface.\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        return __awaiter(this, void 0, void 0, /** @this {!CKEditorComponent} */ function* () {\r\n            if (this.watchdog) {\r\n                yield this.watchdog.remove(this.id);\r\n            }\r\n            else if (this.editorWatchdog && this.editorWatchdog.editor) {\r\n                yield this.editorWatchdog.destroy();\r\n                this.editorWatchdog = undefined;\r\n            }\r\n        });\r\n    }\r\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    writeValue(value) {\r\n        // This method is called with the `null` value when the form resets.\r\n        // A component's responsibility is to restore to the initial state.\r\n        if (value === null) {\r\n            value = '';\r\n        }\r\n        // If already initialized.\r\n        if (this.editorInstance) {\r\n            // The lock mechanism prevents from calling `cvaOnChange()` during changing\r\n            // the editor state. See #139\r\n            this.isEditorSettingData = true;\r\n            this.editorInstance.setData(value);\r\n            this.isEditorSettingData = false;\r\n        }\r\n        // If not, wait for it to be ready; store the data.\r\n        else {\r\n            this.data = value;\r\n            // If the editor element is already available, then update its content.\r\n            // If the ngModel is used then the editor element should be updated directly here.\r\n            if (this.editorElement) {\r\n                this.editorElement.innerHTML = this.data;\r\n            }\r\n        }\r\n    }\r\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\r\n    /**\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    registerOnChange(callback) {\r\n        this.cvaOnChange = callback;\r\n    }\r\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\r\n    /**\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    registerOnTouched(callback) {\r\n        this.cvaOnTouched = callback;\r\n    }\r\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    setDisabledState(isDisabled) {\r\n        // If already initialized.\r\n        if (this.editorInstance) {\r\n            this.editorInstance.isReadOnly = isDisabled;\r\n        }\r\n        // Store the state anyway to use it once the editor is created.\r\n        this.initiallyDisabled = isDisabled;\r\n    }\r\n    /**\r\n     * Creates the editor instance, sets initial editor data, then integrates\r\n     * the editor with the Angular component. This method does not use the `editor.setData()`\r\n     * because of the issue in the collaboration mode (#6).\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    attachToWatchdog() {\r\n        /** @type {?} */\r\n        const creator = (/**\r\n         * @param {?} element\r\n         * @param {?} config\r\n         * @return {?}\r\n         */\r\n        (element, config) => __awaiter(this, void 0, void 0, function* () {\r\n            return this.ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => __awaiter(this, void 0, void 0, function* () {\r\n                this.elementRef.nativeElement.appendChild(element);\r\n                /** @type {?} */\r\n                const editor = yield (/** @type {?} */ (this.editor)).create(element, config);\r\n                if (this.initiallyDisabled) {\r\n                    editor.isReadOnly = this.initiallyDisabled;\r\n                }\r\n                this.ngZone.run((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    this.ready.emit(editor);\r\n                }));\r\n                this.setUpEditorEvents(editor);\r\n                return editor;\r\n            })));\r\n        }));\r\n        /** @type {?} */\r\n        const destructor = (/**\r\n         * @param {?} editor\r\n         * @return {?}\r\n         */\r\n        (editor) => __awaiter(this, void 0, void 0, function* () {\r\n            yield editor.destroy();\r\n            this.elementRef.nativeElement.removeChild((/** @type {?} */ (this.editorElement)));\r\n        }));\r\n        /** @type {?} */\r\n        const emitError = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this.ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this.error.emit();\r\n            }));\r\n        });\r\n        /** @type {?} */\r\n        const element = document.createElement(this.tagName);\r\n        /** @type {?} */\r\n        const config = this.getConfig();\r\n        this.editorElement = element;\r\n        // Based on the presence of the watchdog decide how to initialize the editor.\r\n        if (this.watchdog) {\r\n            // When the context watchdog is passed add the new item to it based on the passed configuration.\r\n            this.watchdog.add({\r\n                id: this.id,\r\n                type: 'editor',\r\n                creator,\r\n                destructor,\r\n                sourceElementOrData: element,\r\n                config\r\n            });\r\n            this.watchdog.on('itemError', (/**\r\n             * @param {?} _\r\n             * @param {?} __1\r\n             * @return {?}\r\n             */\r\n            (_, { itemId }) => {\r\n                if (itemId === this.id) {\r\n                    emitError();\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // In the other case create the watchdog by hand to keep the editor running.\r\n            /** @type {?} */\r\n            const editorWatchdog = new EditorWatchdog(this.editor);\r\n            editorWatchdog.setCreator(creator);\r\n            editorWatchdog.setDestructor(destructor);\r\n            editorWatchdog.on('error', emitError);\r\n            this.editorWatchdog = editorWatchdog;\r\n            this.editorWatchdog.create(element, config);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    getConfig() {\r\n        if (this.data && this.config.initialData) {\r\n            throw new Error('Editor data should be provided either using `config.initialData` or `data` properties.');\r\n        }\r\n        // Merge two possible ways of providing data into the `config.initialData` field.\r\n        return Object.assign({}, this.config, { initialData: this.config.initialData || this.data || '' });\r\n    }\r\n    /**\r\n     * Integrates the editor with the component by attaching related event listeners.\r\n     * @private\r\n     * @param {?} editor\r\n     * @return {?}\r\n     */\r\n    setUpEditorEvents(editor) {\r\n        /** @type {?} */\r\n        const modelDocument = editor.model.document;\r\n        /** @type {?} */\r\n        const viewDocument = editor.editing.view.document;\r\n        modelDocument.on('change:data', (/**\r\n         * @param {?} evt\r\n         * @return {?}\r\n         */\r\n        (evt) => {\r\n            this.ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                if (this.cvaOnChange && !this.isEditorSettingData) {\r\n                    /** @type {?} */\r\n                    const data = editor.getData();\r\n                    this.cvaOnChange(data);\r\n                }\r\n                this.change.emit({ event: evt, editor });\r\n            }));\r\n        }));\r\n        viewDocument.on('focus', (/**\r\n         * @param {?} evt\r\n         * @return {?}\r\n         */\r\n        (evt) => {\r\n            this.ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this.focus.emit({ event: evt, editor });\r\n            }));\r\n        }));\r\n        viewDocument.on('blur', (/**\r\n         * @param {?} evt\r\n         * @return {?}\r\n         */\r\n        (evt) => {\r\n            this.ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                if (this.cvaOnTouched) {\r\n                    this.cvaOnTouched();\r\n                }\r\n                this.blur.emit({ event: evt, editor });\r\n            }));\r\n        }));\r\n    }\r\n}\r\nCKEditorComponent.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'ckeditor',\r\n                template: '<ng-template></ng-template>',\r\n                // Integration with @angular/forms.\r\n                providers: [\r\n                    {\r\n                        provide: NG_VALUE_ACCESSOR,\r\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n                        useExisting: forwardRef((/**\r\n                         * @return {?}\r\n                         */\r\n                        () => CKEditorComponent)),\r\n                        multi: true,\r\n                    }\r\n                ]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nCKEditorComponent.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone }\r\n];\r\nCKEditorComponent.propDecorators = {\r\n    editor: [{ type: Input }],\r\n    config: [{ type: Input }],\r\n    data: [{ type: Input }],\r\n    tagName: [{ type: Input }],\r\n    watchdog: [{ type: Input }],\r\n    disabled: [{ type: Input }],\r\n    ready: [{ type: Output }],\r\n    change: [{ type: Output }],\r\n    blur: [{ type: Output }],\r\n    focus: [{ type: Output }],\r\n    error: [{ type: Output }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CKEditorModule {\r\n}\r\nCKEditorModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [FormsModule, CommonModule],\r\n                declarations: [CKEditorComponent],\r\n                exports: [CKEditorComponent]\r\n            },] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { CKEditorComponent, CKEditorModule };\r\n\r\n"]}