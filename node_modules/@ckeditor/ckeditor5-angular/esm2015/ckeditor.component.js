/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
import { Component, Input, Output, NgZone, EventEmitter, forwardRef, ElementRef } from '@angular/core';
import EditorWatchdog from '@ckeditor/ckeditor5-watchdog/src/editorwatchdog';
import uid from './uid';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import * as ɵngcc0 from '@angular/core';

function CKEditorComponent_ng_template_0_Template(rf, ctx) { }
export class CKEditorComponent {
    /**
     * @param {?} elementRef
     * @param {?} ngZone
     */
    constructor(elementRef, ngZone) {
        /**
         * The configuration of the editor.
         * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html
         * to learn more.
         */
        this.config = {};
        /**
         * The initial data of the editor. Useful when not using the ngModel.
         * See https://angular.io/api/forms/NgModel to learn more.
         */
        this.data = '';
        /**
         * Tag name of the editor component.
         *
         * The default tag is 'div'.
         */
        this.tagName = 'div';
        /**
         * Fires when the editor is ready. It corresponds with the `editor#ready`
         * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready
         * event.
         */
        this.ready = new EventEmitter();
        /**
         * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`
         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change
         * event.
         */
        this.change = new EventEmitter();
        /**
         * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`
         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur
         * event.
         */
        this.blur = new EventEmitter();
        /**
         * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`
         * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus
         * event.
         */
        this.focus = new EventEmitter();
        /**
         * Fires when the editor component crashes.
         */
        this.error = new EventEmitter();
        /**
         * If the component is read–only before the editor instance is created, it remembers that state,
         * so the editor can become read–only once it is ready.
         */
        this.initiallyDisabled = false;
        /**
         * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.
         */
        this.isEditorSettingData = false;
        this.id = uid();
        this.ngZone = ngZone;
        this.elementRef = elementRef;
    }
    /**
     * When set `true`, the editor becomes read-only.
     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#member-isReadOnly
     * to learn more.
     * @param {?} isDisabled
     * @return {?}
     */
    set disabled(isDisabled) {
        this.setDisabledState(isDisabled);
    }
    /**
     * @return {?}
     */
    get disabled() {
        if (this.editorInstance) {
            return this.editorInstance.isReadOnly;
        }
        return this.initiallyDisabled;
    }
    /**
     * The instance of the editor created by this component.
     * @return {?}
     */
    get editorInstance() {
        /** @type {?} */
        let editorWatchdog = this.editorWatchdog;
        if (this.watchdog) {
            // Temporarily use the `_watchdogs` internal map as the `getItem()` method throws
            // an error when the item is not registered yet.
            // See https://github.com/ckeditor/ckeditor5-angular/issues/177.
            editorWatchdog = this.watchdog._watchdogs.get(this.id);
        }
        if (editorWatchdog) {
            return editorWatchdog.editor;
        }
        return null;
    }
    // Implementing the AfterViewInit interface.
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.attachToWatchdog();
    }
    // Implementing the OnDestroy interface.
    /**
     * @return {?}
     */
    ngOnDestroy() {
        return tslib_1.__awaiter(this, void 0, void 0, /** @this {!CKEditorComponent} */ function* () {
            if (this.watchdog) {
                yield this.watchdog.remove(this.id);
            }
            else if (this.editorWatchdog && this.editorWatchdog.editor) {
                yield this.editorWatchdog.destroy();
                this.editorWatchdog = undefined;
            }
        });
    }
    // Implementing the ControlValueAccessor interface (only when binding to ngModel).
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        // This method is called with the `null` value when the form resets.
        // A component's responsibility is to restore to the initial state.
        if (value === null) {
            value = '';
        }
        // If already initialized.
        if (this.editorInstance) {
            // The lock mechanism prevents from calling `cvaOnChange()` during changing
            // the editor state. See #139
            this.isEditorSettingData = true;
            this.editorInstance.setData(value);
            this.isEditorSettingData = false;
        }
        // If not, wait for it to be ready; store the data.
        else {
            this.data = value;
            // If the editor element is already available, then update its content.
            // If the ngModel is used then the editor element should be updated directly here.
            if (this.editorElement) {
                this.editorElement.innerHTML = this.data;
            }
        }
    }
    // Implementing the ControlValueAccessor interface (only when binding to ngModel).
    /**
     * @param {?} callback
     * @return {?}
     */
    registerOnChange(callback) {
        this.cvaOnChange = callback;
    }
    // Implementing the ControlValueAccessor interface (only when binding to ngModel).
    /**
     * @param {?} callback
     * @return {?}
     */
    registerOnTouched(callback) {
        this.cvaOnTouched = callback;
    }
    // Implementing the ControlValueAccessor interface (only when binding to ngModel).
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        // If already initialized.
        if (this.editorInstance) {
            this.editorInstance.isReadOnly = isDisabled;
        }
        // Store the state anyway to use it once the editor is created.
        this.initiallyDisabled = isDisabled;
    }
    /**
     * Creates the editor instance, sets initial editor data, then integrates
     * the editor with the Angular component. This method does not use the `editor.setData()`
     * because of the issue in the collaboration mode (#6).
     * @private
     * @return {?}
     */
    attachToWatchdog() {
        /** @type {?} */
        const creator = (/**
         * @param {?} element
         * @param {?} config
         * @return {?}
         */
        (element, config) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.elementRef.nativeElement.appendChild(element);
                /** @type {?} */
                const editor = yield (/** @type {?} */ (this.editor)).create(element, config);
                if (this.initiallyDisabled) {
                    editor.isReadOnly = this.initiallyDisabled;
                }
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    this.ready.emit(editor);
                }));
                this.setUpEditorEvents(editor);
                return editor;
            })));
        }));
        /** @type {?} */
        const destructor = (/**
         * @param {?} editor
         * @return {?}
         */
        (editor) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield editor.destroy();
            this.elementRef.nativeElement.removeChild((/** @type {?} */ (this.editorElement)));
        }));
        /** @type {?} */
        const emitError = (/**
         * @return {?}
         */
        () => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                this.error.emit();
            }));
        });
        /** @type {?} */
        const element = document.createElement(this.tagName);
        /** @type {?} */
        const config = this.getConfig();
        this.editorElement = element;
        // Based on the presence of the watchdog decide how to initialize the editor.
        if (this.watchdog) {
            // When the context watchdog is passed add the new item to it based on the passed configuration.
            this.watchdog.add({
                id: this.id,
                type: 'editor',
                creator,
                destructor,
                sourceElementOrData: element,
                config
            });
            this.watchdog.on('itemError', (/**
             * @param {?} _
             * @param {?} __1
             * @return {?}
             */
            (_, { itemId }) => {
                if (itemId === this.id) {
                    emitError();
                }
            }));
        }
        else {
            // In the other case create the watchdog by hand to keep the editor running.
            /** @type {?} */
            const editorWatchdog = new EditorWatchdog(this.editor);
            editorWatchdog.setCreator(creator);
            editorWatchdog.setDestructor(destructor);
            editorWatchdog.on('error', emitError);
            this.editorWatchdog = editorWatchdog;
            this.editorWatchdog.create(element, config);
        }
    }
    /**
     * @private
     * @return {?}
     */
    getConfig() {
        if (this.data && this.config.initialData) {
            throw new Error('Editor data should be provided either using `config.initialData` or `data` properties.');
        }
        // Merge two possible ways of providing data into the `config.initialData` field.
        return Object.assign({}, this.config, { initialData: this.config.initialData || this.data || '' });
    }
    /**
     * Integrates the editor with the component by attaching related event listeners.
     * @private
     * @param {?} editor
     * @return {?}
     */
    setUpEditorEvents(editor) {
        /** @type {?} */
        const modelDocument = editor.model.document;
        /** @type {?} */
        const viewDocument = editor.editing.view.document;
        modelDocument.on('change:data', (/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                if (this.cvaOnChange && !this.isEditorSettingData) {
                    /** @type {?} */
                    const data = editor.getData();
                    this.cvaOnChange(data);
                }
                this.change.emit({ event: evt, editor });
            }));
        }));
        viewDocument.on('focus', (/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                this.focus.emit({ event: evt, editor });
            }));
        }));
        viewDocument.on('blur', (/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                if (this.cvaOnTouched) {
                    this.cvaOnTouched();
                }
                this.blur.emit({ event: evt, editor });
            }));
        }));
    }
}
CKEditorComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: CKEditorComponent, selectors: [["ckeditor"]], factory: function CKEditorComponent_Factory(t) { return new (t || CKEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, inputs: { config: "config", data: "data", tagName: "tagName", disabled: "disabled", editor: "editor", watchdog: "watchdog" }, outputs: { ready: "ready", change: "change", blur: "blur", focus: "focus", error: "error" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                useExisting: forwardRef(( /**
                 * @return {?}
                 */() => CKEditorComponent)),
                multi: true
            }
        ])], consts: 1, vars: 0, template: function CKEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, "ng-template");
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CKEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ckeditor',
                template: '<ng-template></ng-template>',
                // Integration with @angular/forms.
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        // eslint-disable-next-line @typescript-eslint/no-use-before-define
                        useExisting: forwardRef(( /**
                         * @return {?}
                         */() => CKEditorComponent)),
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ElementRef }, { type: NgZone }]; }, { constructor: [], config: [{
            type: Input
        }], data: [{
            type: Input
        }], tagName: [{
            type: Input
        }], ready: [{
            type: Output
        }], change: [{
            type: Output
        }], blur: [{
            type: Output
        }], focus: [{
            type: Output
        }], error: [{
            type: Output
        }], initiallyDisabled: [], isEditorSettingData: [], id: [], ngZone: [], elementRef: [], disabled: [{
            type: Input
        }], disabled: [], editorInstance: [], ngAfterViewInit: [], ngOnDestroy: [], writeValue: [], registerOnChange: [], cvaOnChange: [], registerOnTouched: [], cvaOnTouched: [], setDisabledState: [], attachToWatchdog: [], editorElement: [], editorWatchdog: [], getConfig: [], setUpEditorEvents: [], editor: [{
            type: Input
        }], watchdog: [{
            type: Input
        }] });
/** @nocollapse */
CKEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
CKEditorComponent.propDecorators = {
    editor: [{ type: Input }],
    config: [{ type: Input }],
    data: [{ type: Input }],
    tagName: [{ type: Input }],
    watchdog: [{ type: Input }],
    disabled: [{ type: Input }],
    ready: [{ type: Output }],
    change: [{ type: Output }],
    blur: [{ type: Output }],
    focus: [{ type: Output }],
    error: [{ type: Output }]
};
if (false) {
    /**
     * The reference to the DOM element created by the component.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.elementRef;
    /**
     * The constructor of the editor to be used for the instance of the component.
     * It can be e.g. the `ClassicEditorBuild`, `InlineEditorBuild` or some custom editor.
     * @type {?}
     */
    CKEditorComponent.prototype.editor;
    /**
     * The configuration of the editor.
     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html
     * to learn more.
     * @type {?}
     */
    CKEditorComponent.prototype.config;
    /**
     * The initial data of the editor. Useful when not using the ngModel.
     * See https://angular.io/api/forms/NgModel to learn more.
     * @type {?}
     */
    CKEditorComponent.prototype.data;
    /**
     * Tag name of the editor component.
     *
     * The default tag is 'div'.
     * @type {?}
     */
    CKEditorComponent.prototype.tagName;
    /**
     * The context watchdog.
     * @type {?}
     */
    CKEditorComponent.prototype.watchdog;
    /**
     * Fires when the editor is ready. It corresponds with the `editor#ready`
     * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready
     * event.
     * @type {?}
     */
    CKEditorComponent.prototype.ready;
    /**
     * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`
     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change
     * event.
     * @type {?}
     */
    CKEditorComponent.prototype.change;
    /**
     * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`
     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur
     * event.
     * @type {?}
     */
    CKEditorComponent.prototype.blur;
    /**
     * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`
     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus
     * event.
     * @type {?}
     */
    CKEditorComponent.prototype.focus;
    /**
     * Fires when the editor component crashes.
     * @type {?}
     */
    CKEditorComponent.prototype.error;
    /**
     * The editor watchdog. It is created when the context watchdog is not passed to the component.
     * It keeps the editor running.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.editorWatchdog;
    /**
     * If the component is read–only before the editor instance is created, it remembers that state,
     * so the editor can become read–only once it is ready.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.initiallyDisabled;
    /**
     * An instance of https://angular.io/api/core/NgZone to allow the interaction with the editor
     * withing the Angular event loop.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.ngZone;
    /**
     * A callback executed when the content of the editor changes. Part of the
     * `ControlValueAccessor` (https://angular.io/api/forms/ControlValueAccessor) interface.
     *
     * Note: Unset unless the component uses the `ngModel`.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.cvaOnChange;
    /**
     * A callback executed when the editor has been blurred. Part of the
     * `ControlValueAccessor` (https://angular.io/api/forms/ControlValueAccessor) interface.
     *
     * Note: Unset unless the component uses the `ngModel`.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.cvaOnTouched;
    /**
     * Reference to the source element used by the editor.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.editorElement;
    /**
     * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.isEditorSettingData;
    /**
     * @type {?}
     * @private
     */
    CKEditorComponent.prototype.id;
}
/**
 * @record
 */
export function BlurEvent() { }
if (false) {
    /** @type {?} */
    BlurEvent.prototype.event;
    /** @type {?} */
    BlurEvent.prototype.editor;
}
/**
 * @record
 */
export function FocusEvent() { }
if (false) {
    /** @type {?} */
    FocusEvent.prototype.event;
    /** @type {?} */
    FocusEvent.prototype.editor;
}
/**
 * @record
 */
export function ChangeEvent() { }
if (false) {
    /** @type {?} */
    ChangeEvent.prototype.event;
    /** @type {?} */
    ChangeEvent.prototype.editor;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInY6L2phZC1hZG1pbi1nby9tYXphdF9hZG1pbl9wYW5lbC9ub2RlX21vZHVsZXMvQGNrZWRpdG9yL2NrZWRpdG9yNS1hbmd1bGFyL2VzbTIwMTUvY2tlZGl0b3IuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzVkMsYUFrQkMiLCJmaWxlIjoiY2tlZGl0b3IuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG4vKipcclxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kLlxyXG4gKi9cclxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBOZ1pvbmUsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgRWRpdG9yV2F0Y2hkb2cgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS13YXRjaGRvZy9zcmMvZWRpdG9yd2F0Y2hkb2cnO1xyXG5pbXBvcnQgdWlkIGZyb20gJy4vdWlkJztcclxuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmV4cG9ydCBjbGFzcyBDS0VkaXRvckNvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxyXG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgbmdab25lKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGVkaXRvci5cclxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjUvbGF0ZXN0L2FwaS9tb2R1bGVfY29yZV9lZGl0b3JfZWRpdG9yY29uZmlnLUVkaXRvckNvbmZpZy5odG1sXHJcbiAgICAgICAgICogdG8gbGVhcm4gbW9yZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGRhdGEgb2YgdGhlIGVkaXRvci4gVXNlZnVsIHdoZW4gbm90IHVzaW5nIHRoZSBuZ01vZGVsLlxyXG4gICAgICAgICAqIFNlZSBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2Zvcm1zL05nTW9kZWwgdG8gbGVhcm4gbW9yZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRhdGEgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWcgbmFtZSBvZiB0aGUgZWRpdG9yIGNvbXBvbmVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHRhZyBpcyAnZGl2Jy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRhZ05hbWUgPSAnZGl2JztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZHkuIEl0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGBlZGl0b3IjcmVhZHlgXHJcbiAgICAgICAgICogaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjUvbGF0ZXN0L2FwaS9tb2R1bGVfY29yZV9lZGl0b3JfZWRpdG9yLUVkaXRvci5odG1sI2V2ZW50LXJlYWR5XHJcbiAgICAgICAgICogZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBlZGl0b3IgaGFzIGNoYW5nZWQuIEl0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGBlZGl0b3IubW9kZWwuZG9jdW1lbnQjY2hhbmdlYFxyXG4gICAgICAgICAqIGh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I1L2xhdGVzdC9hcGkvbW9kdWxlX2VuZ2luZV9tb2RlbF9kb2N1bWVudC1Eb2N1bWVudC5odG1sI2V2ZW50LWNoYW5nZVxyXG4gICAgICAgICAqIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVkaXRpbmcgdmlldyBvZiB0aGUgZWRpdG9yIGlzIGJsdXJyZWQuIEl0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGBlZGl0b3IuZWRpdGluZy52aWV3LmRvY3VtZW50I2JsdXJgXHJcbiAgICAgICAgICogaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjUvbGF0ZXN0L2FwaS9tb2R1bGVfZW5naW5lX3ZpZXdfZG9jdW1lbnQtRG9jdW1lbnQuaHRtbCNldmVudC1ldmVudDpibHVyXHJcbiAgICAgICAgICogZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ibHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVkaXRpbmcgdmlldyBvZiB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuIEl0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGBlZGl0b3IuZWRpdGluZy52aWV3LmRvY3VtZW50I2ZvY3VzYFxyXG4gICAgICAgICAqIGh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I1L2xhdGVzdC9hcGkvbW9kdWxlX2VuZ2luZV92aWV3X2RvY3VtZW50LURvY3VtZW50Lmh0bWwjZXZlbnQtZXZlbnQ6Zm9jdXNcclxuICAgICAgICAgKiBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVkaXRvciBjb21wb25lbnQgY3Jhc2hlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBjb21wb25lbnQgaXMgcmVhZOKAk29ubHkgYmVmb3JlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaXMgY3JlYXRlZCwgaXQgcmVtZW1iZXJzIHRoYXQgc3RhdGUsXHJcbiAgICAgICAgICogc28gdGhlIGVkaXRvciBjYW4gYmVjb21lIHJlYWTigJNvbmx5IG9uY2UgaXQgaXMgcmVhZHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbml0aWFsbHlEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbG9jayBmbGFnIHByZXZlbnRpbmcgZnJvbSBjYWxsaW5nIHRoZSBgY3ZhT25DaGFuZ2UoKWAgZHVyaW5nIHNldHRpbmcgZWRpdG9yIGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc0VkaXRvclNldHRpbmdEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pZCA9IHVpZCgpO1xyXG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gc2V0IGB0cnVlYCwgdGhlIGVkaXRvciBiZWNvbWVzIHJlYWQtb25seS5cclxuICAgICAqIFNlZSBodHRwczovL2NrZWRpdG9yLmNvbS9kb2NzL2NrZWRpdG9yNS9sYXRlc3QvYXBpL21vZHVsZV9jb3JlX2VkaXRvcl9lZGl0b3ItRWRpdG9yLmh0bWwjbWVtYmVyLWlzUmVhZE9ubHlcclxuICAgICAqIHRvIGxlYXJuIG1vcmUuXHJcbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHNldCBkaXNhYmxlZChpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5zZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnZXQgZGlzYWJsZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9ySW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9ySW5zdGFuY2UuaXNSZWFkT25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGx5RGlzYWJsZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgZWRpdG9yIGNyZWF0ZWQgYnkgdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnZXQgZWRpdG9ySW5zdGFuY2UoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGxldCBlZGl0b3JXYXRjaGRvZyA9IHRoaXMuZWRpdG9yV2F0Y2hkb2c7XHJcbiAgICAgICAgaWYgKHRoaXMud2F0Y2hkb2cpIHtcclxuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgdXNlIHRoZSBgX3dhdGNoZG9nc2AgaW50ZXJuYWwgbWFwIGFzIHRoZSBgZ2V0SXRlbSgpYCBtZXRob2QgdGhyb3dzXHJcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIHdoZW4gdGhlIGl0ZW0gaXMgbm90IHJlZ2lzdGVyZWQgeWV0LlxyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1hbmd1bGFyL2lzc3Vlcy8xNzcuXHJcbiAgICAgICAgICAgIGVkaXRvcldhdGNoZG9nID0gdGhpcy53YXRjaGRvZy5fd2F0Y2hkb2dzLmdldCh0aGlzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVkaXRvcldhdGNoZG9nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlZGl0b3JXYXRjaGRvZy5lZGl0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gSW1wbGVtZW50aW5nIHRoZSBBZnRlclZpZXdJbml0IGludGVyZmFjZS5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoVG9XYXRjaGRvZygpO1xyXG4gICAgfVxyXG4gICAgLy8gSW1wbGVtZW50aW5nIHRoZSBPbkRlc3Ryb3kgaW50ZXJmYWNlLlxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qKiBAdGhpcyB7IUNLRWRpdG9yQ29tcG9uZW50fSAqLyBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaGRvZykge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy53YXRjaGRvZy5yZW1vdmUodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lZGl0b3JXYXRjaGRvZyAmJiB0aGlzLmVkaXRvcldhdGNoZG9nLmVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5lZGl0b3JXYXRjaGRvZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvcldhdGNoZG9nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBJbXBsZW1lbnRpbmcgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSAob25seSB3aGVuIGJpbmRpbmcgdG8gbmdNb2RlbCkuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcclxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCB0aGUgYG51bGxgIHZhbHVlIHdoZW4gdGhlIGZvcm0gcmVzZXRzLlxyXG4gICAgICAgIC8vIEEgY29tcG9uZW50J3MgcmVzcG9uc2liaWxpdHkgaXMgdG8gcmVzdG9yZSB0byB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICAgICAgICBpZiAodGhpcy5lZGl0b3JJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgbG9jayBtZWNoYW5pc20gcHJldmVudHMgZnJvbSBjYWxsaW5nIGBjdmFPbkNoYW5nZSgpYCBkdXJpbmcgY2hhbmdpbmdcclxuICAgICAgICAgICAgLy8gdGhlIGVkaXRvciBzdGF0ZS4gU2VlICMxMzlcclxuICAgICAgICAgICAgdGhpcy5pc0VkaXRvclNldHRpbmdEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5zZXREYXRhKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5pc0VkaXRvclNldHRpbmdEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vdCwgd2FpdCBmb3IgaXQgdG8gYmUgcmVhZHk7IHN0b3JlIHRoZSBkYXRhLlxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGVkaXRvciBlbGVtZW50IGlzIGFscmVhZHkgYXZhaWxhYmxlLCB0aGVuIHVwZGF0ZSBpdHMgY29udGVudC5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIG5nTW9kZWwgaXMgdXNlZCB0aGVuIHRoZSBlZGl0b3IgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZCBkaXJlY3RseSBoZXJlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3JFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvckVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSW1wbGVtZW50aW5nIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgKG9ubHkgd2hlbiBiaW5kaW5nIHRvIG5nTW9kZWwpLlxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5jdmFPbkNoYW5nZSA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgLy8gSW1wbGVtZW50aW5nIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgKG9ubHkgd2hlbiBiaW5kaW5nIHRvIG5nTW9kZWwpLlxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY3ZhT25Ub3VjaGVkID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICAvLyBJbXBsZW1lbnRpbmcgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSAob25seSB3aGVuIGJpbmRpbmcgdG8gbmdNb2RlbCkuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgLy8gSWYgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICAgICAgICBpZiAodGhpcy5lZGl0b3JJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvckluc3RhbmNlLmlzUmVhZE9ubHkgPSBpc0Rpc2FibGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdG9yZSB0aGUgc3RhdGUgYW55d2F5IHRvIHVzZSBpdCBvbmNlIHRoZSBlZGl0b3IgaXMgY3JlYXRlZC5cclxuICAgICAgICB0aGlzLmluaXRpYWxseURpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZWRpdG9yIGluc3RhbmNlLCBzZXRzIGluaXRpYWwgZWRpdG9yIGRhdGEsIHRoZW4gaW50ZWdyYXRlc1xyXG4gICAgICogdGhlIGVkaXRvciB3aXRoIHRoZSBBbmd1bGFyIGNvbXBvbmVudC4gVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIHRoZSBgZWRpdG9yLnNldERhdGEoKWBcclxuICAgICAqIGJlY2F1c2Ugb2YgdGhlIGlzc3VlIGluIHRoZSBjb2xsYWJvcmF0aW9uIG1vZGUgKCM2KS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBhdHRhY2hUb1dhdGNoZG9nKCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBjcmVhdG9yID0gKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29uZmlnXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZWxlbWVudCwgY29uZmlnKSA9PiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgvKipcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICgpID0+IHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSB5aWVsZCAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5lZGl0b3IpKS5jcmVhdGUoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxseURpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzUmVhZE9ubHkgPSB0aGlzLmluaXRpYWxseURpc2FibGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgvKipcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5LmVtaXQoZWRpdG9yKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXBFZGl0b3JFdmVudHMoZWRpdG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3I7XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWRpdG9yXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZWRpdG9yKSA9PiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgZWRpdG9yLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlQ2hpbGQoKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuZWRpdG9yRWxlbWVudCkpKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGVtaXRFcnJvciA9ICgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgvKipcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdCgpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSk7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIHdhdGNoZG9nIGRlY2lkZSBob3cgdG8gaW5pdGlhbGl6ZSB0aGUgZWRpdG9yLlxyXG4gICAgICAgIGlmICh0aGlzLndhdGNoZG9nKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRleHQgd2F0Y2hkb2cgaXMgcGFzc2VkIGFkZCB0aGUgbmV3IGl0ZW0gdG8gaXQgYmFzZWQgb24gdGhlIHBhc3NlZCBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLndhdGNoZG9nLmFkZCh7XHJcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdlZGl0b3InLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRvcixcclxuICAgICAgICAgICAgICAgIGRlc3RydWN0b3IsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50T3JEYXRhOiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgY29uZmlnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLndhdGNoZG9nLm9uKCdpdGVtRXJyb3InLCAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gX1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgKF8sIHsgaXRlbUlkIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtSWQgPT09IHRoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSW4gdGhlIG90aGVyIGNhc2UgY3JlYXRlIHRoZSB3YXRjaGRvZyBieSBoYW5kIHRvIGtlZXAgdGhlIGVkaXRvciBydW5uaW5nLlxyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvcldhdGNoZG9nID0gbmV3IEVkaXRvcldhdGNoZG9nKHRoaXMuZWRpdG9yKTtcclxuICAgICAgICAgICAgZWRpdG9yV2F0Y2hkb2cuc2V0Q3JlYXRvcihjcmVhdG9yKTtcclxuICAgICAgICAgICAgZWRpdG9yV2F0Y2hkb2cuc2V0RGVzdHJ1Y3RvcihkZXN0cnVjdG9yKTtcclxuICAgICAgICAgICAgZWRpdG9yV2F0Y2hkb2cub24oJ2Vycm9yJywgZW1pdEVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JXYXRjaGRvZyA9IGVkaXRvcldhdGNoZG9nO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvcldhdGNoZG9nLmNyZWF0ZShlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldENvbmZpZygpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuY29uZmlnLmluaXRpYWxEYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWRpdG9yIGRhdGEgc2hvdWxkIGJlIHByb3ZpZGVkIGVpdGhlciB1c2luZyBgY29uZmlnLmluaXRpYWxEYXRhYCBvciBgZGF0YWAgcHJvcGVydGllcy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgdHdvIHBvc3NpYmxlIHdheXMgb2YgcHJvdmlkaW5nIGRhdGEgaW50byB0aGUgYGNvbmZpZy5pbml0aWFsRGF0YWAgZmllbGQuXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLCB7IGluaXRpYWxEYXRhOiB0aGlzLmNvbmZpZy5pbml0aWFsRGF0YSB8fCB0aGlzLmRhdGEgfHwgJycgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludGVncmF0ZXMgdGhlIGVkaXRvciB3aXRoIHRoZSBjb21wb25lbnQgYnkgYXR0YWNoaW5nIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gZWRpdG9yXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBzZXRVcEVkaXRvckV2ZW50cyhlZGl0b3IpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgbW9kZWxEb2N1bWVudCA9IGVkaXRvci5tb2RlbC5kb2N1bWVudDtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3Qgdmlld0RvY3VtZW50ID0gZWRpdG9yLmVkaXRpbmcudmlldy5kb2N1bWVudDtcclxuICAgICAgICBtb2RlbERvY3VtZW50Lm9uKCdjaGFuZ2U6ZGF0YScsICgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IGV2dFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3ZhT25DaGFuZ2UgJiYgIXRoaXMuaXNFZGl0b3JTZXR0aW5nRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZWRpdG9yLmdldERhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN2YU9uQ2hhbmdlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdCh7IGV2ZW50OiBldnQsIGVkaXRvciB9KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB2aWV3RG9jdW1lbnQub24oJ2ZvY3VzJywgKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXZ0XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLmVtaXQoeyBldmVudDogZXZ0LCBlZGl0b3IgfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdmlld0RvY3VtZW50Lm9uKCdibHVyJywgKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXZ0XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdmFPblRvdWNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN2YU9uVG91Y2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ibHVyLmVtaXQoeyBldmVudDogZXZ0LCBlZGl0b3IgfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cclxuQ0tFZGl0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdja2VkaXRvcicsXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZT48L25nLXRlbXBsYXRlPicsXHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGlvbiB3aXRoIEBhbmd1bGFyL2Zvcm1zLlxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiBDS0VkaXRvckNvbXBvbmVudCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1dIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbkNLRWRpdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xyXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXHJcbiAgICB7IHR5cGU6IE5nWm9uZSB9XHJcbl07XHJcbkNLRWRpdG9yQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgZWRpdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgIGNvbmZpZzogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgIHRhZ05hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgd2F0Y2hkb2c6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgcmVhZHk6IFt7IHR5cGU6IE91dHB1dCB9XSxcclxuICAgIGNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxyXG4gICAgYmx1cjogW3sgdHlwZTogT3V0cHV0IH1dLFxyXG4gICAgZm9jdXM6IFt7IHR5cGU6IE91dHB1dCB9XSxcclxuICAgIGVycm9yOiBbeyB0eXBlOiBPdXRwdXQgfV1cclxufTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWZlcmVuY2UgdG8gdGhlIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQ0tFZGl0b3JDb21wb25lbnQucHJvdG90eXBlLmVsZW1lbnRSZWY7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZWRpdG9yIHRvIGJlIHVzZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogSXQgY2FuIGJlIGUuZy4gdGhlIGBDbGFzc2ljRWRpdG9yQnVpbGRgLCBgSW5saW5lRWRpdG9yQnVpbGRgIG9yIHNvbWUgY3VzdG9tIGVkaXRvci5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuZWRpdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxyXG4gICAgICogU2VlIGh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I1L2xhdGVzdC9hcGkvbW9kdWxlX2NvcmVfZWRpdG9yX2VkaXRvcmNvbmZpZy1FZGl0b3JDb25maWcuaHRtbFxyXG4gICAgICogdG8gbGVhcm4gbW9yZS5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuY29uZmlnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5pdGlhbCBkYXRhIG9mIHRoZSBlZGl0b3IuIFVzZWZ1bCB3aGVuIG5vdCB1c2luZyB0aGUgbmdNb2RlbC5cclxuICAgICAqIFNlZSBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2Zvcm1zL05nTW9kZWwgdG8gbGVhcm4gbW9yZS5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuZGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogVGFnIG5hbWUgb2YgdGhlIGVkaXRvciBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgdGFnIGlzICdkaXYnLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIENLRWRpdG9yQ29tcG9uZW50LnByb3RvdHlwZS50YWdOYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29udGV4dCB3YXRjaGRvZy5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUud2F0Y2hkb2c7XHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGVkaXRvciBpcyByZWFkeS4gSXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgYGVkaXRvciNyZWFkeWBcclxuICAgICAqIGh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I1L2xhdGVzdC9hcGkvbW9kdWxlX2NvcmVfZWRpdG9yX2VkaXRvci1FZGl0b3IuaHRtbCNldmVudC1yZWFkeVxyXG4gICAgICogZXZlbnQuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgQ0tFZGl0b3JDb21wb25lbnQucHJvdG90eXBlLnJlYWR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBlZGl0b3IgaGFzIGNoYW5nZWQuIEl0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGBlZGl0b3IubW9kZWwuZG9jdW1lbnQjY2hhbmdlYFxyXG4gICAgICogaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjUvbGF0ZXN0L2FwaS9tb2R1bGVfZW5naW5lX21vZGVsX2RvY3VtZW50LURvY3VtZW50Lmh0bWwjZXZlbnQtY2hhbmdlXHJcbiAgICAgKiBldmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuY2hhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBlZGl0aW5nIHZpZXcgb2YgdGhlIGVkaXRvciBpcyBibHVycmVkLiBJdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBgZWRpdG9yLmVkaXRpbmcudmlldy5kb2N1bWVudCNibHVyYFxyXG4gICAgICogaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjUvbGF0ZXN0L2FwaS9tb2R1bGVfZW5naW5lX3ZpZXdfZG9jdW1lbnQtRG9jdW1lbnQuaHRtbCNldmVudC1ldmVudDpibHVyXHJcbiAgICAgKiBldmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuYmx1cjtcclxuICAgIC8qKlxyXG4gICAgICogRmlyZXMgd2hlbiB0aGUgZWRpdGluZyB2aWV3IG9mIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC4gSXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgYGVkaXRvci5lZGl0aW5nLnZpZXcuZG9jdW1lbnQjZm9jdXNgXHJcbiAgICAgKiBodHRwczovL2NrZWRpdG9yLmNvbS9kb2NzL2NrZWRpdG9yNS9sYXRlc3QvYXBpL21vZHVsZV9lbmdpbmVfdmlld19kb2N1bWVudC1Eb2N1bWVudC5odG1sI2V2ZW50LWV2ZW50OmZvY3VzXHJcbiAgICAgKiBldmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuZm9jdXM7XHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGVkaXRvciBjb21wb25lbnQgY3Jhc2hlcy5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuZXJyb3I7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlZGl0b3Igd2F0Y2hkb2cuIEl0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgY29udGV4dCB3YXRjaGRvZyBpcyBub3QgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBJdCBrZWVwcyB0aGUgZWRpdG9yIHJ1bm5pbmcuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIENLRWRpdG9yQ29tcG9uZW50LnByb3RvdHlwZS5lZGl0b3JXYXRjaGRvZztcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGNvbXBvbmVudCBpcyByZWFk4oCTb25seSBiZWZvcmUgdGhlIGVkaXRvciBpbnN0YW5jZSBpcyBjcmVhdGVkLCBpdCByZW1lbWJlcnMgdGhhdCBzdGF0ZSxcclxuICAgICAqIHNvIHRoZSBlZGl0b3IgY2FuIGJlY29tZSByZWFk4oCTb25seSBvbmNlIGl0IGlzIHJlYWR5LlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuaW5pdGlhbGx5RGlzYWJsZWQ7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGluc3RhbmNlIG9mIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29yZS9OZ1pvbmUgdG8gYWxsb3cgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIGVkaXRvclxyXG4gICAgICogd2l0aGluZyB0aGUgQW5ndWxhciBldmVudCBsb29wLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUubmdab25lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIGVkaXRvciBjaGFuZ2VzLiBQYXJ0IG9mIHRoZVxyXG4gICAgICogYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCAoaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9mb3Jtcy9Db250cm9sVmFsdWVBY2Nlc3NvcikgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IFVuc2V0IHVubGVzcyB0aGUgY29tcG9uZW50IHVzZXMgdGhlIGBuZ01vZGVsYC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQ0tFZGl0b3JDb21wb25lbnQucHJvdG90eXBlLmN2YU9uQ2hhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gdGhlIGVkaXRvciBoYXMgYmVlbiBibHVycmVkLiBQYXJ0IG9mIHRoZVxyXG4gICAgICogYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCAoaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9mb3Jtcy9Db250cm9sVmFsdWVBY2Nlc3NvcikgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IFVuc2V0IHVubGVzcyB0aGUgY29tcG9uZW50IHVzZXMgdGhlIGBuZ01vZGVsYC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQ0tFZGl0b3JDb21wb25lbnQucHJvdG90eXBlLmN2YU9uVG91Y2hlZDtcclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgZWxlbWVudCB1c2VkIGJ5IHRoZSBlZGl0b3IuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIENLRWRpdG9yQ29tcG9uZW50LnByb3RvdHlwZS5lZGl0b3JFbGVtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxvY2sgZmxhZyBwcmV2ZW50aW5nIGZyb20gY2FsbGluZyB0aGUgYGN2YU9uQ2hhbmdlKClgIGR1cmluZyBzZXR0aW5nIGVkaXRvciBkYXRhLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuaXNFZGl0b3JTZXR0aW5nRGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDS0VkaXRvckNvbXBvbmVudC5wcm90b3R5cGUuaWQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyRXZlbnQoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCbHVyRXZlbnQucHJvdG90eXBlLmV2ZW50O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgQmx1ckV2ZW50LnByb3RvdHlwZS5lZGl0b3I7XHJcbn1cclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBGb2N1c0V2ZW50KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgRm9jdXNFdmVudC5wcm90b3R5cGUuZXZlbnQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBGb2N1c0V2ZW50LnByb3RvdHlwZS5lZGl0b3I7XHJcbn1cclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBDaGFuZ2VFdmVudCgpIHsgfVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIENoYW5nZUV2ZW50LnByb3RvdHlwZS5ldmVudDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIENoYW5nZUV2ZW50LnByb3RvdHlwZS5lZGl0b3I7XHJcbn1cciJdfQ==