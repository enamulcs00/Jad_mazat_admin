{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm2015/stepper.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;CAcC,wGAQC;;;;;;;;;;;;;;;;;;;;;;;;CAiBD,2FAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmKD,aAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2XD,aAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8CD,aAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,aAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAeD,4LAqBC","file":"stepper.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directive, ElementRef, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, EventEmitter, forwardRef, Inject, InjectionToken, Input, Optional, Output, ViewChild, ViewEncapsulation, HostListener, NgModule } from '@angular/core';\r\nimport { FocusKeyManager } from '@angular/cdk/a11y';\r\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { END, ENTER, hasModifierKey, HOME, SPACE } from '@angular/cdk/keycodes';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { of, Subject } from 'rxjs';\r\nimport { startWith, takeUntil } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CdkStepHeader {\r\n    /**\r\n     * @param {?} _elementRef\r\n     */\r\n    constructor(_elementRef) {\r\n        this._elementRef = _elementRef;\r\n    }\r\n    /**\r\n     * Focuses the step header.\r\n     * @return {?}\r\n     */\r\n    focus() {\r\n        this._elementRef.nativeElement.focus();\r\n    }\r\n}\r\nCdkStepHeader.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkStepHeader]',\r\n                host: {\r\n                    'role': 'tab',\r\n                },\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStepHeader.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CdkStepLabel {\r\n    /**\r\n     * @param {?} template\r\n     */\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkStepLabel.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkStepLabel]',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStepLabel.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Used to generate unique ID for each stepper component.\r\n * @type {?}\r\n */\r\nlet nextId = 0;\r\n/**\r\n * Change event emitted on selection changes.\r\n */\r\nclass StepperSelectionEvent {\r\n}\r\n/**\r\n * Enum to represent the different states of the steps.\r\n * @type {?}\r\n */\r\nconst STEP_STATE = {\r\n    NUMBER: 'number',\r\n    EDIT: 'edit',\r\n    DONE: 'done',\r\n    ERROR: 'error'\r\n};\r\n/**\r\n * InjectionToken that can be used to specify the global stepper options.\r\n * @type {?}\r\n */\r\nconst STEPPER_GLOBAL_OPTIONS = new InjectionToken('STEPPER_GLOBAL_OPTIONS');\r\n/**\r\n * InjectionToken that can be used to specify the global stepper options.\r\n * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.\r\n * \\@breaking-change 8.0.0.\r\n * @type {?}\r\n */\r\nconst MAT_STEPPER_GLOBAL_OPTIONS = STEPPER_GLOBAL_OPTIONS;\r\nclass CdkStep {\r\n    /**\r\n     * \\@breaking-change 8.0.0 remove the `?` after `stepperOptions`\r\n     * @param {?} _stepper\r\n     * @param {?=} stepperOptions\r\n     */\r\n    constructor(_stepper, stepperOptions) {\r\n        this._stepper = _stepper;\r\n        /**\r\n         * Whether user has seen the expanded step content or not.\r\n         */\r\n        this.interacted = false;\r\n        this._editable = true;\r\n        this._optional = false;\r\n        this._completedOverride = null;\r\n        this._customError = null;\r\n        this._stepperOptions = stepperOptions ? stepperOptions : {};\r\n        this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;\r\n        this._showError = !!this._stepperOptions.showError;\r\n    }\r\n    /**\r\n     * Whether the user can return to this step once it has been marked as completed.\r\n     * @return {?}\r\n     */\r\n    get editable() {\r\n        return this._editable;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set editable(value) {\r\n        this._editable = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Whether the completion of step is optional.\r\n     * @return {?}\r\n     */\r\n    get optional() {\r\n        return this._optional;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set optional(value) {\r\n        this._optional = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Whether step is marked as completed.\r\n     * @return {?}\r\n     */\r\n    get completed() {\r\n        return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set completed(value) {\r\n        this._completedOverride = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getDefaultCompleted() {\r\n        return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;\r\n    }\r\n    /**\r\n     * Whether step has an error.\r\n     * @return {?}\r\n     */\r\n    get hasError() {\r\n        return this._customError == null ? this._getDefaultError() : this._customError;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set hasError(value) {\r\n        this._customError = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getDefaultError() {\r\n        return this.stepControl && this.stepControl.invalid && this.interacted;\r\n    }\r\n    /**\r\n     * Selects this step component.\r\n     * @return {?}\r\n     */\r\n    select() {\r\n        this._stepper.selected = this;\r\n    }\r\n    /**\r\n     * Resets the step to its initial state. Note that this includes resetting form data.\r\n     * @return {?}\r\n     */\r\n    reset() {\r\n        this.interacted = false;\r\n        if (this._completedOverride != null) {\r\n            this._completedOverride = false;\r\n        }\r\n        if (this._customError != null) {\r\n            this._customError = false;\r\n        }\r\n        if (this.stepControl) {\r\n            this.stepControl.reset();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnChanges() {\r\n        // Since basically all inputs of the MatStep get proxied through the view down to the\r\n        // underlying MatStepHeader, we have to make sure that change detection runs correctly.\r\n        this._stepper._stateChanged();\r\n    }\r\n}\r\nCdkStep.decorators = [\r\n    { type: Component, args: [{selector: 'cdk-step',\r\n                exportAs: 'cdkStep',\r\n                template: '<ng-template><ng-content></ng-content></ng-template>',\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStep.ctorParameters = () => [\r\n    { type: CdkStepper, decorators: [{ type: Inject, args: [forwardRef((/**\r\n                     * @return {?}\r\n                     */\r\n                    () => CdkStepper)),] }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [STEPPER_GLOBAL_OPTIONS,] }] }\r\n];\r\nCdkStep.propDecorators = {\r\n    stepLabel: [{ type: ContentChild, args: [CdkStepLabel, { static: false },] }],\r\n    content: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],\r\n    stepControl: [{ type: Input }],\r\n    label: [{ type: Input }],\r\n    errorMessage: [{ type: Input }],\r\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\r\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\r\n    state: [{ type: Input }],\r\n    editable: [{ type: Input }],\r\n    optional: [{ type: Input }],\r\n    completed: [{ type: Input }],\r\n    hasError: [{ type: Input }]\r\n};\r\nclass CdkStepper {\r\n    /**\r\n     * @param {?} _dir\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?=} _elementRef\r\n     * @param {?=} _document\r\n     */\r\n    constructor(_dir, _changeDetectorRef, _elementRef, _document) {\r\n        this._dir = _dir;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._elementRef = _elementRef;\r\n        /**\r\n         * Emits when the component is destroyed.\r\n         */\r\n        this._destroyed = new Subject();\r\n        this._linear = false;\r\n        this._selectedIndex = 0;\r\n        /**\r\n         * Event emitted when the selected step has changed.\r\n         */\r\n        this.selectionChange = new EventEmitter();\r\n        this._orientation = 'horizontal';\r\n        this._groupId = nextId++;\r\n        this._document = _document;\r\n    }\r\n    /**\r\n     * The list of step components that the stepper is holding.\r\n     * @return {?}\r\n     */\r\n    get steps() {\r\n        return this._steps;\r\n    }\r\n    /**\r\n     * Whether the validity of previous steps should be checked or not.\r\n     * @return {?}\r\n     */\r\n    get linear() {\r\n        return this._linear;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set linear(value) {\r\n        this._linear = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * The index of the selected step.\r\n     * @return {?}\r\n     */\r\n    get selectedIndex() {\r\n        return this._selectedIndex;\r\n    }\r\n    /**\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    set selectedIndex(index) {\r\n        /** @type {?} */\r\n        const newIndex = coerceNumberProperty(index);\r\n        if (this.steps) {\r\n            // Ensure that the index can't be out of bounds.\r\n            if (newIndex < 0 || newIndex > this.steps.length - 1) {\r\n                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');\r\n            }\r\n            if (this._selectedIndex != newIndex && !this._anyControlsInvalidOrPending(newIndex) &&\r\n                (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {\r\n                this._updateSelectedItemIndex(index);\r\n            }\r\n        }\r\n        else {\r\n            this._selectedIndex = newIndex;\r\n        }\r\n    }\r\n    /**\r\n     * The step that is selected.\r\n     * @return {?}\r\n     */\r\n    get selected() {\r\n        // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.\r\n        return this.steps ? this.steps.toArray()[this.selectedIndex] : (/** @type {?} */ (undefined));\r\n    }\r\n    /**\r\n     * @param {?} step\r\n     * @return {?}\r\n     */\r\n    set selected(step) {\r\n        this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterViewInit() {\r\n        // Note that while the step headers are content children by default, any components that\r\n        // extend this one might have them as view chidren. We initialize the keyboard handling in\r\n        // AfterViewInit so we're guaranteed for both view and content children to be defined.\r\n        this._keyManager = new FocusKeyManager(this._stepHeader)\r\n            .withWrap()\r\n            .withVerticalOrientation(this._orientation === 'vertical');\r\n        (this._dir ? ((/** @type {?} */ (this._dir.change))) : of())\r\n            .pipe(startWith(this._layoutDirection()), takeUntil(this._destroyed))\r\n            .subscribe((/**\r\n         * @param {?} direction\r\n         * @return {?}\r\n         */\r\n        direction => this._keyManager.withHorizontalOrientation(direction)));\r\n        this._keyManager.updateActiveItemIndex(this._selectedIndex);\r\n        this.steps.changes.pipe(takeUntil(this._destroyed)).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            if (!this.selected) {\r\n                this._selectedIndex = Math.max(this._selectedIndex - 1, 0);\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /**\r\n     * Selects and focuses the next step in list.\r\n     * @return {?}\r\n     */\r\n    next() {\r\n        this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);\r\n    }\r\n    /**\r\n     * Selects and focuses the previous step in list.\r\n     * @return {?}\r\n     */\r\n    previous() {\r\n        this.selectedIndex = Math.max(this._selectedIndex - 1, 0);\r\n    }\r\n    /**\r\n     * Resets the stepper to its initial state. Note that this includes clearing form data.\r\n     * @return {?}\r\n     */\r\n    reset() {\r\n        this._updateSelectedItemIndex(0);\r\n        this.steps.forEach((/**\r\n         * @param {?} step\r\n         * @return {?}\r\n         */\r\n        step => step.reset()));\r\n        this._stateChanged();\r\n    }\r\n    /**\r\n     * Returns a unique id for each step label element.\r\n     * @param {?} i\r\n     * @return {?}\r\n     */\r\n    _getStepLabelId(i) {\r\n        return `cdk-step-label-${this._groupId}-${i}`;\r\n    }\r\n    /**\r\n     * Returns unique id for each step content element.\r\n     * @param {?} i\r\n     * @return {?}\r\n     */\r\n    _getStepContentId(i) {\r\n        return `cdk-step-content-${this._groupId}-${i}`;\r\n    }\r\n    /**\r\n     * Marks the component to be change detected.\r\n     * @return {?}\r\n     */\r\n    _stateChanged() {\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /**\r\n     * Returns position state of the step with the given index.\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _getAnimationDirection(index) {\r\n        /** @type {?} */\r\n        const position = index - this._selectedIndex;\r\n        if (position < 0) {\r\n            return this._layoutDirection() === 'rtl' ? 'next' : 'previous';\r\n        }\r\n        else if (position > 0) {\r\n            return this._layoutDirection() === 'rtl' ? 'previous' : 'next';\r\n        }\r\n        return 'current';\r\n    }\r\n    /**\r\n     * Returns the type of icon to be displayed.\r\n     * @param {?} index\r\n     * @param {?=} state\r\n     * @return {?}\r\n     */\r\n    _getIndicatorType(index, state = STEP_STATE.NUMBER) {\r\n        /** @type {?} */\r\n        const step = this.steps.toArray()[index];\r\n        /** @type {?} */\r\n        const isCurrentStep = this._isCurrentStep(index);\r\n        return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) :\r\n            this._getGuidelineLogic(step, isCurrentStep, state);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} step\r\n     * @param {?} isCurrentStep\r\n     * @return {?}\r\n     */\r\n    _getDefaultIndicatorLogic(step, isCurrentStep) {\r\n        if (step._showError && step.hasError && !isCurrentStep) {\r\n            return STEP_STATE.ERROR;\r\n        }\r\n        else if (!step.completed || isCurrentStep) {\r\n            return STEP_STATE.NUMBER;\r\n        }\r\n        else {\r\n            return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} step\r\n     * @param {?} isCurrentStep\r\n     * @param {?=} state\r\n     * @return {?}\r\n     */\r\n    _getGuidelineLogic(step, isCurrentStep, state = STEP_STATE.NUMBER) {\r\n        if (step._showError && step.hasError && !isCurrentStep) {\r\n            return STEP_STATE.ERROR;\r\n        }\r\n        else if (step.completed && !isCurrentStep) {\r\n            return STEP_STATE.DONE;\r\n        }\r\n        else if (step.completed && isCurrentStep) {\r\n            return state;\r\n        }\r\n        else if (step.editable && isCurrentStep) {\r\n            return STEP_STATE.EDIT;\r\n        }\r\n        else {\r\n            return state;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _isCurrentStep(index) {\r\n        return this._selectedIndex === index;\r\n    }\r\n    /**\r\n     * Returns the index of the currently-focused step header.\r\n     * @return {?}\r\n     */\r\n    _getFocusIndex() {\r\n        return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} newIndex\r\n     * @return {?}\r\n     */\r\n    _updateSelectedItemIndex(newIndex) {\r\n        /** @type {?} */\r\n        const stepsArray = this.steps.toArray();\r\n        this.selectionChange.emit({\r\n            selectedIndex: newIndex,\r\n            previouslySelectedIndex: this._selectedIndex,\r\n            selectedStep: stepsArray[newIndex],\r\n            previouslySelectedStep: stepsArray[this._selectedIndex],\r\n        });\r\n        // If focus is inside the stepper, move it to the next header, otherwise it may become\r\n        // lost when the active step content is hidden. We can't be more granular with the check\r\n        // (e.g. checking whether focus is inside the active step), because we don't have a\r\n        // reference to the elements that are rendering out the content.\r\n        this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :\r\n            this._keyManager.updateActiveItemIndex(newIndex);\r\n        this._selectedIndex = newIndex;\r\n        this._stateChanged();\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onKeydown(event) {\r\n        /** @type {?} */\r\n        const hasModifier = hasModifierKey(event);\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        /** @type {?} */\r\n        const manager = this._keyManager;\r\n        if (manager.activeItemIndex != null && !hasModifier &&\r\n            (keyCode === SPACE || keyCode === ENTER)) {\r\n            this.selectedIndex = manager.activeItemIndex;\r\n            event.preventDefault();\r\n        }\r\n        else if (keyCode === HOME) {\r\n            manager.setFirstItemActive();\r\n            event.preventDefault();\r\n        }\r\n        else if (keyCode === END) {\r\n            manager.setLastItemActive();\r\n            event.preventDefault();\r\n        }\r\n        else {\r\n            manager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _anyControlsInvalidOrPending(index) {\r\n        /** @type {?} */\r\n        const steps = this.steps.toArray();\r\n        steps[this._selectedIndex].interacted = true;\r\n        if (this._linear && index >= 0) {\r\n            return steps.slice(0, index).some((/**\r\n             * @param {?} step\r\n             * @return {?}\r\n             */\r\n            step => {\r\n                /** @type {?} */\r\n                const control = step.stepControl;\r\n                /** @type {?} */\r\n                const isIncomplete = control ? (control.invalid || control.pending || !step.interacted) : !step.completed;\r\n                return isIncomplete && !step.optional && !step._completedOverride;\r\n            }));\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _layoutDirection() {\r\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\r\n    }\r\n    /**\r\n     * Checks whether the stepper contains the focused element.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _containsFocus() {\r\n        if (!this._document || !this._elementRef) {\r\n            return false;\r\n        }\r\n        /** @type {?} */\r\n        const stepperElement = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        const focusedElement = this._document.activeElement;\r\n        return stepperElement === focusedElement || stepperElement.contains(focusedElement);\r\n    }\r\n}\r\nCdkStepper.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkStepper]',\r\n                exportAs: 'cdkStepper',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStepper.ctorParameters = () => [\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: ChangeDetectorRef },\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\nCdkStepper.propDecorators = {\r\n    _steps: [{ type: ContentChildren, args: [CdkStep,] }],\r\n    _stepHeader: [{ type: ContentChildren, args: [CdkStepHeader,] }],\r\n    linear: [{ type: Input }],\r\n    selectedIndex: [{ type: Input }],\r\n    selected: [{ type: Input }],\r\n    selectionChange: [{ type: Output }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Button that moves to the next step in a stepper workflow.\r\n */\r\nclass CdkStepperNext {\r\n    /**\r\n     * @param {?} _stepper\r\n     */\r\n    constructor(_stepper) {\r\n        this._stepper = _stepper;\r\n        /**\r\n         * Type of the next button. Defaults to \"submit\" if not specified.\r\n         */\r\n        this.type = 'submit';\r\n    }\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @return {?}\r\n     */\r\n    _handleClick() {\r\n        this._stepper.next();\r\n    }\r\n}\r\nCdkStepperNext.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'button[cdkStepperNext]',\r\n                host: {\r\n                    '[type]': 'type',\r\n                }\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStepperNext.ctorParameters = () => [\r\n    { type: CdkStepper }\r\n];\r\nCdkStepperNext.propDecorators = {\r\n    type: [{ type: Input }],\r\n    _handleClick: [{ type: HostListener, args: ['click',] }]\r\n};\r\n/**\r\n * Button that moves to the previous step in a stepper workflow.\r\n */\r\nclass CdkStepperPrevious {\r\n    /**\r\n     * @param {?} _stepper\r\n     */\r\n    constructor(_stepper) {\r\n        this._stepper = _stepper;\r\n        /**\r\n         * Type of the previous button. Defaults to \"button\" if not specified.\r\n         */\r\n        this.type = 'button';\r\n    }\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @return {?}\r\n     */\r\n    _handleClick() {\r\n        this._stepper.previous();\r\n    }\r\n}\r\nCdkStepperPrevious.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'button[cdkStepperPrevious]',\r\n                host: {\r\n                    '[type]': 'type',\r\n                }\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkStepperPrevious.ctorParameters = () => [\r\n    { type: CdkStepper }\r\n];\r\nCdkStepperPrevious.propDecorators = {\r\n    type: [{ type: Input }],\r\n    _handleClick: [{ type: HostListener, args: ['click',] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass CdkStepperModule {\r\n}\r\nCdkStepperModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [BidiModule, CommonModule],\r\n                exports: [\r\n                    CdkStep,\r\n                    CdkStepper,\r\n                    CdkStepHeader,\r\n                    CdkStepLabel,\r\n                    CdkStepperNext,\r\n                    CdkStepperPrevious,\r\n                ],\r\n                declarations: [\r\n                    CdkStep,\r\n                    CdkStepper,\r\n                    CdkStepHeader,\r\n                    CdkStepLabel,\r\n                    CdkStepperNext,\r\n                    CdkStepperPrevious,\r\n                ]\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { StepperSelectionEvent, STEP_STATE, STEPPER_GLOBAL_OPTIONS, MAT_STEPPER_GLOBAL_OPTIONS, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule, CdkStepHeader };\r\n\r\n"]}