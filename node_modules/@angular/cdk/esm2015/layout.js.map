{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm2015/layout.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;CACC,yIAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CD,0HAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgMD,kOAGC","file":"layout.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { NgModule, Injectable, NgZone, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { combineLatest, concat, Observable, Subject } from 'rxjs';\r\nimport { debounceTime, map, skip, startWith, take, takeUntil } from 'rxjs/operators';\r\nimport { coerceArray } from '@angular/cdk/coercion';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass LayoutModule {\r\n}\r\nLayoutModule.decorators = [\r\n    { type: NgModule, args: [{},] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Global registry for all dynamically-created, injected media queries.\r\n * @type {?}\r\n */\r\nconst mediaQueriesForWebkitCompatibility = new Set();\r\n/**\r\n * Style tag that holds all of the dynamically-created media queries.\r\n * @type {?}\r\n */\r\nlet mediaQueryStyleNode;\r\n/**\r\n * A utility for calling matchMedia queries.\r\n */\r\nclass MediaMatcher {\r\n    /**\r\n     * @param {?} _platform\r\n     */\r\n    constructor(_platform) {\r\n        this._platform = _platform;\r\n        this._matchMedia = this._platform.isBrowser && window.matchMedia ?\r\n            // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\r\n            // call it from a different scope.\r\n            window.matchMedia.bind(window) :\r\n            noopMatchMedia;\r\n    }\r\n    /**\r\n     * Evaluates the given media query and returns the native MediaQueryList from which results\r\n     * can be retrieved.\r\n     * Confirms the layout engine will trigger for the selector query provided and returns the\r\n     * MediaQueryList for the query provided.\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    matchMedia(query) {\r\n        if (this._platform.WEBKIT) {\r\n            createEmptyStyleRule(query);\r\n        }\r\n        return this._matchMedia(query);\r\n    }\r\n}\r\nMediaMatcher.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nMediaMatcher.ctorParameters = () => [\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ MediaMatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function MediaMatcher_Factory() { return new MediaMatcher(ɵɵinject(Platform)); }, token: MediaMatcher, providedIn: \"root\" });\r\n/**\r\n * For Webkit engines that only trigger the MediaQueryListListener when\r\n * there is at least one CSS selector for the respective media query.\r\n * @param {?} query\r\n * @return {?}\r\n */\r\nfunction createEmptyStyleRule(query) {\r\n    if (mediaQueriesForWebkitCompatibility.has(query)) {\r\n        return;\r\n    }\r\n    try {\r\n        if (!mediaQueryStyleNode) {\r\n            mediaQueryStyleNode = document.createElement('style');\r\n            mediaQueryStyleNode.setAttribute('type', 'text/css');\r\n            (/** @type {?} */ (document.head)).appendChild(mediaQueryStyleNode);\r\n        }\r\n        if (mediaQueryStyleNode.sheet) {\r\n            ((/** @type {?} */ (mediaQueryStyleNode.sheet)))\r\n                .insertRule(`@media ${query} {.fx-query-test{ }}`, 0);\r\n            mediaQueriesForWebkitCompatibility.add(query);\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n}\r\n/**\r\n * No-op matchMedia replacement for non-browser platforms.\r\n * @param {?} query\r\n * @return {?}\r\n */\r\nfunction noopMatchMedia(query) {\r\n    // Use `as any` here to avoid adding additional necessary properties for\r\n    // the noop matcher.\r\n    return (/** @type {?} */ ({\r\n        matches: query === 'all' || query === '',\r\n        media: query,\r\n        addListener: (/**\r\n         * @return {?}\r\n         */\r\n        () => { }),\r\n        removeListener: (/**\r\n         * @return {?}\r\n         */\r\n        () => { })\r\n    }));\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Utility for checking the matching state of \\@media queries.\r\n */\r\nclass BreakpointObserver {\r\n    /**\r\n     * @param {?} _mediaMatcher\r\n     * @param {?} _zone\r\n     */\r\n    constructor(_mediaMatcher, _zone) {\r\n        this._mediaMatcher = _mediaMatcher;\r\n        this._zone = _zone;\r\n        /**\r\n         * A map of all media queries currently being listened for.\r\n         */\r\n        this._queries = new Map();\r\n        /**\r\n         * A subject for all other observables to takeUntil based on.\r\n         */\r\n        this._destroySubject = new Subject();\r\n    }\r\n    /**\r\n     * Completes the active subject, signalling to all other observables to complete.\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._destroySubject.next();\r\n        this._destroySubject.complete();\r\n    }\r\n    /**\r\n     * Whether one or more media queries match the current viewport size.\r\n     * @param {?} value One or more media queries to check.\r\n     * @return {?} Whether any of the media queries match.\r\n     */\r\n    isMatched(value) {\r\n        /** @type {?} */\r\n        const queries = splitQueries(coerceArray(value));\r\n        return queries.some((/**\r\n         * @param {?} mediaQuery\r\n         * @return {?}\r\n         */\r\n        mediaQuery => this._registerQuery(mediaQuery).mql.matches));\r\n    }\r\n    /**\r\n     * Gets an observable of results for the given queries that will emit new results for any changes\r\n     * in matching of the given queries.\r\n     * @param {?} value One or more media queries to check.\r\n     * @return {?} A stream of matches for the given queries.\r\n     */\r\n    observe(value) {\r\n        /** @type {?} */\r\n        const queries = splitQueries(coerceArray(value));\r\n        /** @type {?} */\r\n        const observables = queries.map((/**\r\n         * @param {?} query\r\n         * @return {?}\r\n         */\r\n        query => this._registerQuery(query).observable));\r\n        /** @type {?} */\r\n        let stateObservable = combineLatest(observables);\r\n        // Emit the first state immediately, and then debounce the subsequent emissions.\r\n        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));\r\n        return stateObservable.pipe(map((/**\r\n         * @param {?} breakpointStates\r\n         * @return {?}\r\n         */\r\n        (breakpointStates) => {\r\n            /** @type {?} */\r\n            const response = {\r\n                matches: false,\r\n                breakpoints: {},\r\n            };\r\n            breakpointStates.forEach((/**\r\n             * @param {?} state\r\n             * @return {?}\r\n             */\r\n            (state) => {\r\n                response.matches = response.matches || state.matches;\r\n                response.breakpoints[state.query] = state.matches;\r\n            }));\r\n            return response;\r\n        })));\r\n    }\r\n    /**\r\n     * Registers a specific query to be listened for.\r\n     * @private\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    _registerQuery(query) {\r\n        // Only set up a new MediaQueryList if it is not already being listened for.\r\n        if (this._queries.has(query)) {\r\n            return (/** @type {?} */ (this._queries.get(query)));\r\n        }\r\n        /** @type {?} */\r\n        const mql = this._mediaMatcher.matchMedia(query);\r\n        // Create callback for match changes and add it is as a listener.\r\n        /** @type {?} */\r\n        const queryObservable = new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => {\r\n            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\r\n            // back into the zone because matchMedia is only included in Zone.js by loading the\r\n            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\r\n            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\r\n            // patches it.\r\n            /** @type {?} */\r\n            const handler = (/**\r\n             * @param {?} e\r\n             * @return {?}\r\n             */\r\n            (e) => this._zone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => observer.next(e))));\r\n            mql.addListener(handler);\r\n            return (/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                mql.removeListener(handler);\r\n            });\r\n        })).pipe(startWith(mql), map((/**\r\n         * @param {?} nextMql\r\n         * @return {?}\r\n         */\r\n        (nextMql) => ({ query, matches: nextMql.matches }))), takeUntil(this._destroySubject));\r\n        // Add the MediaQueryList to the set of queries.\r\n        /** @type {?} */\r\n        const output = { observable: queryObservable, mql };\r\n        this._queries.set(query, output);\r\n        return output;\r\n    }\r\n}\r\nBreakpointObserver.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nBreakpointObserver.ctorParameters = () => [\r\n    { type: MediaMatcher },\r\n    { type: NgZone }\r\n];\r\n/** @nocollapse */ BreakpointObserver.ngInjectableDef = ɵɵdefineInjectable({ factory: function BreakpointObserver_Factory() { return new BreakpointObserver(ɵɵinject(MediaMatcher), ɵɵinject(NgZone)); }, token: BreakpointObserver, providedIn: \"root\" });\r\n/**\r\n * Split each query string into separate query strings if two queries are provided as comma\r\n * separated.\r\n * @param {?} queries\r\n * @return {?}\r\n */\r\nfunction splitQueries(queries) {\r\n    return queries.map((/**\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    (query) => query.split(',')))\r\n        .reduce((/**\r\n     * @param {?} a1\r\n     * @param {?} a2\r\n     * @return {?}\r\n     */\r\n    (a1, a2) => a1.concat(a2)))\r\n        .map((/**\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    query => query.trim()));\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// PascalCase is being used as Breakpoints is used like an enum.\r\n// tslint:disable-next-line:variable-name\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n * @type {?}\r\n */\r\nconst Breakpoints = {\r\n    XSmall: '(max-width: 599.99px)',\r\n    Small: '(min-width: 600px) and (max-width: 959.99px)',\r\n    Medium: '(min-width: 960px) and (max-width: 1279.99px)',\r\n    Large: '(min-width: 1280px) and (max-width: 1919.99px)',\r\n    XLarge: '(min-width: 1920px)',\r\n    Handset: '(max-width: 599.99px) and (orientation: portrait), ' +\r\n        '(max-width: 959.99px) and (orientation: landscape)',\r\n    Tablet: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait), ' +\r\n        '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',\r\n    Web: '(min-width: 840px) and (orientation: portrait), ' +\r\n        '(min-width: 1280px) and (orientation: landscape)',\r\n    HandsetPortrait: '(max-width: 599.99px) and (orientation: portrait)',\r\n    TabletPortrait: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait)',\r\n    WebPortrait: '(min-width: 840px) and (orientation: portrait)',\r\n    HandsetLandscape: '(max-width: 959.99px) and (orientation: landscape)',\r\n    TabletLandscape: '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',\r\n    WebLandscape: '(min-width: 1280px) and (orientation: landscape)',\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { LayoutModule, BreakpointObserver, Breakpoints, MediaMatcher };\r\n\r\n"]}