{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm2015/scrolling.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyNC,+CAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwND,iZAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsND,oRAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAydD,aAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAubD,uUAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqBD,sBAkBC;;;;;;;;;;;;;;;;;CAMD,2BAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmID,gSAGC","file":"scrolling.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken, Directive, forwardRef, Input, Injectable, NgZone, Optional, SkipSelf, ElementRef, NgModule, IterableDiffers, TemplateRef, ViewContainerRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, Inject, Output, ViewChild, ViewEncapsulation, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { Subject, fromEvent, of, Observable, animationFrameScheduler, asapScheduler, merge } from 'rxjs';\r\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, shareReplay, switchMap } from 'rxjs/operators';\r\nimport { Platform, getRtlScrollAxisType, RtlScrollAxisType, supportsScrollBehavior, PlatformModule } from '@angular/cdk/platform';\r\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\r\nimport { ArrayDataSource, isDataSource } from '@angular/cdk/collections';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * The injection token used to specify the virtual scrolling strategy.\r\n * @type {?}\r\n */\r\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Virtual scrolling strategy for lists with items of known fixed size.\r\n */\r\nclass FixedSizeVirtualScrollStrategy {\r\n    /**\r\n     * @param {?} itemSize The size of the items in the virtually scrolling list.\r\n     * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     */\r\n    constructor(itemSize, minBufferPx, maxBufferPx) {\r\n        this._scrolledIndexChange = new Subject();\r\n        /**\r\n         * \\@docs-private Implemented as part of VirtualScrollStrategy.\r\n         */\r\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\r\n        /**\r\n         * The attached viewport.\r\n         */\r\n        this._viewport = null;\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n    }\r\n    /**\r\n     * Attaches this scroll strategy to a viewport.\r\n     * @param {?} viewport The viewport to attach this strategy to.\r\n     * @return {?}\r\n     */\r\n    attach(viewport) {\r\n        this._viewport = viewport;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /**\r\n     * Detaches this scroll strategy from the currently attached viewport.\r\n     * @return {?}\r\n     */\r\n    detach() {\r\n        this._scrolledIndexChange.complete();\r\n        this._viewport = null;\r\n    }\r\n    /**\r\n     * Update the item size and buffer size.\r\n     * @param {?} itemSize The size of the items in the virtually scrolling list.\r\n     * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     * @return {?}\r\n     */\r\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\r\n        if (maxBufferPx < minBufferPx) {\r\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\r\n        }\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /**\r\n     * \\@docs-private Implemented as part of VirtualScrollStrategy.\r\n     * @return {?}\r\n     */\r\n    onContentScrolled() {\r\n        this._updateRenderedRange();\r\n    }\r\n    /**\r\n     * \\@docs-private Implemented as part of VirtualScrollStrategy.\r\n     * @return {?}\r\n     */\r\n    onDataLengthChanged() {\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /**\r\n     * \\@docs-private Implemented as part of VirtualScrollStrategy.\r\n     * @return {?}\r\n     */\r\n    onContentRendered() { }\r\n    /**\r\n     * \\@docs-private Implemented as part of VirtualScrollStrategy.\r\n     * @return {?}\r\n     */\r\n    onRenderedOffsetChanged() { }\r\n    /**\r\n     * Scroll to the offset for the given index.\r\n     * @param {?} index The index of the element to scroll to.\r\n     * @param {?} behavior The ScrollBehavior to use when scrolling.\r\n     * @return {?}\r\n     */\r\n    scrollToIndex(index, behavior) {\r\n        if (this._viewport) {\r\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\r\n        }\r\n    }\r\n    /**\r\n     * Update the viewport's total content size.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateTotalContentSize() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\r\n    }\r\n    /**\r\n     * Update the viewport's rendered range.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateRenderedRange() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const scrollOffset = this._viewport.measureScrollOffset();\r\n        /** @type {?} */\r\n        const firstVisibleIndex = scrollOffset / this._itemSize;\r\n        /** @type {?} */\r\n        const renderedRange = this._viewport.getRenderedRange();\r\n        /** @type {?} */\r\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\r\n        /** @type {?} */\r\n        const viewportSize = this._viewport.getViewportSize();\r\n        /** @type {?} */\r\n        const dataLength = this._viewport.getDataLength();\r\n        /** @type {?} */\r\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\r\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\r\n            /** @type {?} */\r\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\r\n            newRange.start = Math.max(0, newRange.start - expandStart);\r\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\r\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\r\n                /** @type {?} */\r\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\r\n                if (expandEnd > 0) {\r\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\r\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\r\n                }\r\n            }\r\n        }\r\n        this._viewport.setRenderedRange(newRange);\r\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\r\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\r\n    }\r\n}\r\n/**\r\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\r\n * `FixedSizeVirtualScrollStrategy` from the given directive.\r\n * @param {?} fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\r\n *     `FixedSizeVirtualScrollStrategy` from.\r\n * @return {?}\r\n */\r\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\r\n    return fixedSizeDir._scrollStrategy;\r\n}\r\n/**\r\n * A virtual scroll strategy that supports fixed-size items.\r\n */\r\nclass CdkFixedSizeVirtualScroll {\r\n    constructor() {\r\n        this._itemSize = 20;\r\n        this._minBufferPx = 100;\r\n        this._maxBufferPx = 200;\r\n        /**\r\n         * The scroll strategy used by this directive.\r\n         */\r\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n    /**\r\n     * The size of the items in the list (in pixels).\r\n     * @return {?}\r\n     */\r\n    get itemSize() { return this._itemSize; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\r\n    /**\r\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\r\n     * @return {?}\r\n     */\r\n    get minBufferPx() { return this._minBufferPx; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\r\n    /**\r\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\r\n     * @return {?}\r\n     */\r\n    get maxBufferPx() { return this._maxBufferPx; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnChanges() {\r\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n}\r\nCdkFixedSizeVirtualScroll.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'cdk-virtual-scroll-viewport[itemSize]',\r\n                providers: [{\r\n                        provide: VIRTUAL_SCROLL_STRATEGY,\r\n                        useFactory: _fixedSizeVirtualScrollStrategyFactory,\r\n                        deps: [forwardRef((/**\r\n                             * @return {?}\r\n                             */\r\n                            () => CdkFixedSizeVirtualScroll))],\r\n                    }],\r\n            },] },\r\n];\r\nCdkFixedSizeVirtualScroll.propDecorators = {\r\n    itemSize: [{ type: Input }],\r\n    minBufferPx: [{ type: Input }],\r\n    maxBufferPx: [{ type: Input }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Time in ms to throttle the scrolling events by default.\r\n * @type {?}\r\n */\r\nconst DEFAULT_SCROLL_TIME = 20;\r\n/**\r\n * Service contained all registered Scrollable references and emits an event when any one of the\r\n * Scrollable references emit a scrolled event.\r\n */\r\nclass ScrollDispatcher {\r\n    /**\r\n     * @param {?} _ngZone\r\n     * @param {?} _platform\r\n     */\r\n    constructor(_ngZone, _platform) {\r\n        this._ngZone = _ngZone;\r\n        this._platform = _platform;\r\n        /**\r\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\r\n         */\r\n        this._scrolled = new Subject();\r\n        /**\r\n         * Keeps track of the global `scroll` and `resize` subscriptions.\r\n         */\r\n        this._globalSubscription = null;\r\n        /**\r\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\r\n         */\r\n        this._scrolledCount = 0;\r\n        /**\r\n         * Map of all the scrollable references that are registered with the service and their\r\n         * scroll event subscriptions.\r\n         */\r\n        this.scrollContainers = new Map();\r\n    }\r\n    /**\r\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\r\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\r\n     * @param {?} scrollable Scrollable instance to be registered.\r\n     * @return {?}\r\n     */\r\n    register(scrollable) {\r\n        if (!this.scrollContainers.has(scrollable)) {\r\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled()\r\n                .subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this._scrolled.next(scrollable))));\r\n        }\r\n    }\r\n    /**\r\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\n     * @param {?} scrollable Scrollable instance to be deregistered.\r\n     * @return {?}\r\n     */\r\n    deregister(scrollable) {\r\n        /** @type {?} */\r\n        const scrollableReference = this.scrollContainers.get(scrollable);\r\n        if (scrollableReference) {\r\n            scrollableReference.unsubscribe();\r\n            this.scrollContainers.delete(scrollable);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an observable that emits an event whenever any of the registered Scrollable\r\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\r\n     * to override the default \"throttle\" time.\r\n     *\r\n     * **Note:** in order to avoid hitting change detection for every scroll event,\r\n     * all of the events emitted from this stream will be run outside the Angular zone.\r\n     * If you need to update any data bindings as a result of a scroll event, you have\r\n     * to run the callback using `NgZone.run`.\r\n     * @param {?=} auditTimeInMs\r\n     * @return {?}\r\n     */\r\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\r\n        if (!this._platform.isBrowser) {\r\n            return of();\r\n        }\r\n        return new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => {\r\n            if (!this._globalSubscription) {\r\n                this._addGlobalListener();\r\n            }\r\n            // In the case of a 0ms delay, use an observable without auditTime\r\n            // since it does add a perceptible delay in processing overhead.\r\n            /** @type {?} */\r\n            const subscription = auditTimeInMs > 0 ?\r\n                this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\r\n                this._scrolled.subscribe(observer);\r\n            this._scrolledCount++;\r\n            return (/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                subscription.unsubscribe();\r\n                this._scrolledCount--;\r\n                if (!this._scrolledCount) {\r\n                    this._removeGlobalListener();\r\n                }\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._removeGlobalListener();\r\n        this.scrollContainers.forEach((/**\r\n         * @param {?} _\r\n         * @param {?} container\r\n         * @return {?}\r\n         */\r\n        (_, container) => this.deregister(container)));\r\n        this._scrolled.complete();\r\n    }\r\n    /**\r\n     * Returns an observable that emits whenever any of the\r\n     * scrollable ancestors of an element are scrolled.\r\n     * @param {?} elementRef Element whose ancestors to listen for.\r\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\r\n     * @return {?}\r\n     */\r\n    ancestorScrolled(elementRef, auditTimeInMs) {\r\n        /** @type {?} */\r\n        const ancestors = this.getAncestorScrollContainers(elementRef);\r\n        return this.scrolled(auditTimeInMs).pipe(filter((/**\r\n         * @param {?} target\r\n         * @return {?}\r\n         */\r\n        target => {\r\n            return !target || ancestors.indexOf(target) > -1;\r\n        })));\r\n    }\r\n    /**\r\n     * Returns all registered Scrollables that contain the provided element.\r\n     * @param {?} elementRef\r\n     * @return {?}\r\n     */\r\n    getAncestorScrollContainers(elementRef) {\r\n        /** @type {?} */\r\n        const scrollingContainers = [];\r\n        this.scrollContainers.forEach((/**\r\n         * @param {?} _subscription\r\n         * @param {?} scrollable\r\n         * @return {?}\r\n         */\r\n        (_subscription, scrollable) => {\r\n            if (this._scrollableContainsElement(scrollable, elementRef)) {\r\n                scrollingContainers.push(scrollable);\r\n            }\r\n        }));\r\n        return scrollingContainers;\r\n    }\r\n    /**\r\n     * Returns true if the element is contained within the provided Scrollable.\r\n     * @private\r\n     * @param {?} scrollable\r\n     * @param {?} elementRef\r\n     * @return {?}\r\n     */\r\n    _scrollableContainsElement(scrollable, elementRef) {\r\n        /** @type {?} */\r\n        let element = elementRef.nativeElement;\r\n        /** @type {?} */\r\n        let scrollableElement = scrollable.getElementRef().nativeElement;\r\n        // Traverse through the element parents until we reach null, checking if any of the elements\r\n        // are the scrollable's element.\r\n        do {\r\n            if (element == scrollableElement) {\r\n                return true;\r\n            }\r\n        } while (element = (/** @type {?} */ (element)).parentElement);\r\n        return false;\r\n    }\r\n    /**\r\n     * Sets up the global scroll listeners.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _addGlobalListener() {\r\n        this._globalSubscription = this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            return fromEvent(window.document, 'scroll').subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this._scrolled.next()));\r\n        }));\r\n    }\r\n    /**\r\n     * Cleans up the global scroll listener.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _removeGlobalListener() {\r\n        if (this._globalSubscription) {\r\n            this._globalSubscription.unsubscribe();\r\n            this._globalSubscription = null;\r\n        }\r\n    }\r\n}\r\nScrollDispatcher.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nScrollDispatcher.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ ScrollDispatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(ɵɵinject(NgZone), ɵɵinject(Platform)); }, token: ScrollDispatcher, providedIn: \"root\" });\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentDispatcher\r\n * @param {?} ngZone\r\n * @param {?} platform\r\n * @return {?}\r\n */\r\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\r\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nconst SCROLL_DISPATCHER_PROVIDER = {\r\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\r\n    provide: ScrollDispatcher,\r\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\r\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Sends an event when the directive's element is scrolled. Registers itself with the\r\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\r\n * can be listened to through the service.\r\n */\r\nclass CdkScrollable {\r\n    /**\r\n     * @param {?} elementRef\r\n     * @param {?} scrollDispatcher\r\n     * @param {?} ngZone\r\n     * @param {?=} dir\r\n     */\r\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\r\n        this.elementRef = elementRef;\r\n        this.scrollDispatcher = scrollDispatcher;\r\n        this.ngZone = ngZone;\r\n        this.dir = dir;\r\n        this._destroyed = new Subject();\r\n        this._elementScrolled = new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => this.ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\r\n            .subscribe(observer)))));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.scrollDispatcher.register(this);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.scrollDispatcher.deregister(this);\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /**\r\n     * Returns observable that emits when a scroll event is fired on the host element.\r\n     * @return {?}\r\n     */\r\n    elementScrolled() {\r\n        return this._elementScrolled;\r\n    }\r\n    /**\r\n     * Gets the ElementRef for the viewport.\r\n     * @return {?}\r\n     */\r\n    getElementRef() {\r\n        return this.elementRef;\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param {?} options specified the offsets to scroll to.\r\n     * @return {?}\r\n     */\r\n    scrollTo(options) {\r\n        /** @type {?} */\r\n        const el = this.elementRef.nativeElement;\r\n        /** @type {?} */\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        // Rewrite start & end offsets as right or left offsets.\r\n        options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;\r\n        options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;\r\n        // Rewrite the bottom offset as a top offset.\r\n        if (options.bottom != null) {\r\n            ((/** @type {?} */ (options))).top =\r\n                el.scrollHeight - el.clientHeight - options.bottom;\r\n        }\r\n        // Rewrite the right offset as a left offset.\r\n        if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\r\n            if (options.left != null) {\r\n                ((/** @type {?} */ (options))).right =\r\n                    el.scrollWidth - el.clientWidth - options.left;\r\n            }\r\n            if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\r\n                options.left = options.right;\r\n            }\r\n            else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\r\n                options.left = options.right ? -options.right : options.right;\r\n            }\r\n        }\r\n        else {\r\n            if (options.right != null) {\r\n                ((/** @type {?} */ (options))).left =\r\n                    el.scrollWidth - el.clientWidth - options.right;\r\n            }\r\n        }\r\n        this._applyScrollToOptions(options);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    _applyScrollToOptions(options) {\r\n        /** @type {?} */\r\n        const el = this.elementRef.nativeElement;\r\n        if (supportsScrollBehavior()) {\r\n            el.scrollTo(options);\r\n        }\r\n        else {\r\n            if (options.top != null) {\r\n                el.scrollTop = options.top;\r\n            }\r\n            if (options.left != null) {\r\n                el.scrollLeft = options.left;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\r\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\r\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param {?} from The edge to measure from.\r\n     * @return {?}\r\n     */\r\n    measureScrollOffset(from) {\r\n        /** @type {?} */\r\n        const LEFT = 'left';\r\n        /** @type {?} */\r\n        const RIGHT = 'right';\r\n        /** @type {?} */\r\n        const el = this.elementRef.nativeElement;\r\n        if (from == 'top') {\r\n            return el.scrollTop;\r\n        }\r\n        if (from == 'bottom') {\r\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\r\n        }\r\n        // Rewrite start & end as left or right offsets.\r\n        /** @type {?} */\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        if (from == 'start') {\r\n            from = isRtl ? RIGHT : LEFT;\r\n        }\r\n        else if (from == 'end') {\r\n            from = isRtl ? LEFT : RIGHT;\r\n        }\r\n        if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\r\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollLeft;\r\n            }\r\n        }\r\n        else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\r\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\r\n            }\r\n            else {\r\n                return -el.scrollLeft;\r\n            }\r\n        }\r\n        else {\r\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\r\n            // (scrollWidth - clientWidth) when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n        }\r\n    }\r\n}\r\nCdkScrollable.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdk-scrollable], [cdkScrollable]'\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkScrollable.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ScrollDispatcher },\r\n    { type: NgZone },\r\n    { type: Directionality, decorators: [{ type: Optional }] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Checks if the given ranges are equal.\r\n * @param {?} r1\r\n * @param {?} r2\r\n * @return {?}\r\n */\r\nfunction rangesEqual(r1, r2) {\r\n    return r1.start == r2.start && r1.end == r2.end;\r\n}\r\n/**\r\n * Scheduler to be used for scroll events. Needs to fall back to\r\n * something that doesn't rely on requestAnimationFrame on environments\r\n * that don't support it (e.g. server-side rendering).\r\n * @type {?}\r\n */\r\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\r\n/**\r\n * A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`.\r\n */\r\nclass CdkVirtualScrollViewport extends CdkScrollable {\r\n    /**\r\n     * @param {?} elementRef\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} ngZone\r\n     * @param {?} _scrollStrategy\r\n     * @param {?} dir\r\n     * @param {?} scrollDispatcher\r\n     */\r\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher) {\r\n        super(elementRef, scrollDispatcher, ngZone, dir);\r\n        this.elementRef = elementRef;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._scrollStrategy = _scrollStrategy;\r\n        /**\r\n         * Emits when the viewport is detached from a CdkVirtualForOf.\r\n         */\r\n        this._detachedSubject = new Subject();\r\n        /**\r\n         * Emits when the rendered range changes.\r\n         */\r\n        this._renderedRangeSubject = new Subject();\r\n        this._orientation = 'vertical';\r\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\r\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\r\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\r\n        // performance.\r\n        /**\r\n         * Emits when the index of the first element visible in the viewport changes.\r\n         */\r\n        this.scrolledIndexChange = new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => this._scrollStrategy.scrolledIndexChange.subscribe((/**\r\n         * @param {?} index\r\n         * @return {?}\r\n         */\r\n        index => Promise.resolve().then((/**\r\n         * @return {?}\r\n         */\r\n        () => this.ngZone.run((/**\r\n         * @return {?}\r\n         */\r\n        () => observer.next(index)))))))));\r\n        /**\r\n         * A stream that emits whenever the rendered range changes.\r\n         */\r\n        this.renderedRangeStream = this._renderedRangeSubject.asObservable();\r\n        /**\r\n         * The total size of all content (in pixels), including content that is not currently rendered.\r\n         */\r\n        this._totalContentSize = 0;\r\n        /**\r\n         * A string representing the `style.width` property value to be used for the spacer element.\r\n         */\r\n        this._totalContentWidth = '';\r\n        /**\r\n         * A string representing the `style.height` property value to be used for the spacer element.\r\n         */\r\n        this._totalContentHeight = '';\r\n        /**\r\n         * The currently rendered range of indices.\r\n         */\r\n        this._renderedRange = { start: 0, end: 0 };\r\n        /**\r\n         * The length of the data bound to this viewport (in number of items).\r\n         */\r\n        this._dataLength = 0;\r\n        /**\r\n         * The size of the viewport (in pixels).\r\n         */\r\n        this._viewportSize = 0;\r\n        /**\r\n         * The last rendered content offset that was set.\r\n         */\r\n        this._renderedContentOffset = 0;\r\n        /**\r\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\r\n         * be rewritten as an offset to the start of the content).\r\n         */\r\n        this._renderedContentOffsetNeedsRewrite = false;\r\n        /**\r\n         * Whether there is a pending change detection cycle.\r\n         */\r\n        this._isChangeDetectionPending = false;\r\n        /**\r\n         * A list of functions to run after the next change detection cycle.\r\n         */\r\n        this._runAfterChangeDetection = [];\r\n        if (!_scrollStrategy) {\r\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\r\n        }\r\n    }\r\n    /**\r\n     * The direction the viewport scrolls.\r\n     * @return {?}\r\n     */\r\n    get orientation() {\r\n        return this._orientation;\r\n    }\r\n    /**\r\n     * @param {?} orientation\r\n     * @return {?}\r\n     */\r\n    set orientation(orientation) {\r\n        if (this._orientation !== orientation) {\r\n            this._orientation = orientation;\r\n            this._calculateSpacerSize();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        super.ngOnInit();\r\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\r\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\r\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\r\n        // ourselves instead.\r\n        this.ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => Promise.resolve().then((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._measureViewportSize();\r\n            this._scrollStrategy.attach(this);\r\n            this.elementScrolled()\r\n                .pipe(\r\n            // Start off with a fake scroll event so we properly detect our initial position.\r\n            startWith((/** @type {?} */ (null))), \r\n            // Collect multiple events into one until the next animation frame. This way if\r\n            // there are multiple scroll events in the same frame we only need to recheck\r\n            // our layout once.\r\n            auditTime(0, SCROLL_SCHEDULER))\r\n                .subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this._scrollStrategy.onContentScrolled()));\r\n            this._markChangeDetectionNeeded();\r\n        }))));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.detach();\r\n        this._scrollStrategy.detach();\r\n        // Complete all subjects\r\n        this._renderedRangeSubject.complete();\r\n        this._detachedSubject.complete();\r\n        super.ngOnDestroy();\r\n    }\r\n    /**\r\n     * Attaches a `CdkVirtualForOf` to this viewport.\r\n     * @param {?} forOf\r\n     * @return {?}\r\n     */\r\n    attach(forOf) {\r\n        if (this._forOf) {\r\n            throw Error('CdkVirtualScrollViewport is already attached.');\r\n        }\r\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\r\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\r\n        // change detection loop ourselves.\r\n        this.ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._forOf = forOf;\r\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((/**\r\n             * @param {?} data\r\n             * @return {?}\r\n             */\r\n            data => {\r\n                /** @type {?} */\r\n                const newLength = data.length;\r\n                if (newLength !== this._dataLength) {\r\n                    this._dataLength = newLength;\r\n                    this._scrollStrategy.onDataLengthChanged();\r\n                }\r\n                this._doChangeDetection();\r\n            }));\r\n        }));\r\n    }\r\n    /**\r\n     * Detaches the current `CdkVirtualForOf`.\r\n     * @return {?}\r\n     */\r\n    detach() {\r\n        this._forOf = null;\r\n        this._detachedSubject.next();\r\n    }\r\n    /**\r\n     * Gets the length of the data bound to this viewport (in number of items).\r\n     * @return {?}\r\n     */\r\n    getDataLength() {\r\n        return this._dataLength;\r\n    }\r\n    /**\r\n     * Gets the size of the viewport (in pixels).\r\n     * @return {?}\r\n     */\r\n    getViewportSize() {\r\n        return this._viewportSize;\r\n    }\r\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\r\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\r\n    // setting it to something else, but its error prone and should probably be split into\r\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\r\n    /**\r\n     * Get the current rendered range of items.\r\n     * @return {?}\r\n     */\r\n    getRenderedRange() {\r\n        return this._renderedRange;\r\n    }\r\n    /**\r\n     * Sets the total size of all content (in pixels), including content that is not currently\r\n     * rendered.\r\n     * @param {?} size\r\n     * @return {?}\r\n     */\r\n    setTotalContentSize(size) {\r\n        if (this._totalContentSize !== size) {\r\n            this._totalContentSize = size;\r\n            this._calculateSpacerSize();\r\n            this._markChangeDetectionNeeded();\r\n        }\r\n    }\r\n    /**\r\n     * Sets the currently rendered range of indices.\r\n     * @param {?} range\r\n     * @return {?}\r\n     */\r\n    setRenderedRange(range) {\r\n        if (!rangesEqual(this._renderedRange, range)) {\r\n            this._renderedRangeSubject.next(this._renderedRange = range);\r\n            this._markChangeDetectionNeeded((/**\r\n             * @return {?}\r\n             */\r\n            () => this._scrollStrategy.onContentRendered()));\r\n        }\r\n    }\r\n    /**\r\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\r\n     * @return {?}\r\n     */\r\n    getOffsetToRenderedContentStart() {\r\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\r\n    }\r\n    /**\r\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\r\n     * (in pixels).\r\n     * @param {?} offset\r\n     * @param {?=} to\r\n     * @return {?}\r\n     */\r\n    setRenderedContentOffset(offset, to = 'to-start') {\r\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\r\n        // in the negative direction.\r\n        /** @type {?} */\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        /** @type {?} */\r\n        const isHorizontal = this.orientation == 'horizontal';\r\n        /** @type {?} */\r\n        const axis = isHorizontal ? 'X' : 'Y';\r\n        /** @type {?} */\r\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\r\n        /** @type {?} */\r\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\r\n        this._renderedContentOffset = offset;\r\n        if (to === 'to-end') {\r\n            transform += ` translate${axis}(-100%)`;\r\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\r\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\r\n            // expand upward).\r\n            this._renderedContentOffsetNeedsRewrite = true;\r\n        }\r\n        if (this._renderedContentTransform != transform) {\r\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\r\n            // into the string.\r\n            this._renderedContentTransform = transform;\r\n            this._markChangeDetectionNeeded((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                if (this._renderedContentOffsetNeedsRewrite) {\r\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\r\n                    this._renderedContentOffsetNeedsRewrite = false;\r\n                    this.setRenderedContentOffset(this._renderedContentOffset);\r\n                }\r\n                else {\r\n                    this._scrollStrategy.onRenderedOffsetChanged();\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\r\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\r\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\r\n     * @param {?} offset The offset to scroll to.\r\n     * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     * @return {?}\r\n     */\r\n    scrollToOffset(offset, behavior = 'auto') {\r\n        /** @type {?} */\r\n        const options = { behavior };\r\n        if (this.orientation === 'horizontal') {\r\n            options.start = offset;\r\n        }\r\n        else {\r\n            options.top = offset;\r\n        }\r\n        this.scrollTo(options);\r\n    }\r\n    /**\r\n     * Scrolls to the offset for the given index.\r\n     * @param {?} index The index of the element to scroll to.\r\n     * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     * @return {?}\r\n     */\r\n    scrollToIndex(index, behavior = 'auto') {\r\n        this._scrollStrategy.scrollToIndex(index, behavior);\r\n    }\r\n    /**\r\n     * Gets the current scroll offset from the start of the viewport (in pixels).\r\n     * @param {?=} from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\r\n     *     in horizontal mode.\r\n     * @return {?}\r\n     */\r\n    measureScrollOffset(from) {\r\n        return super.measureScrollOffset(from ? from : this.orientation === 'horizontal' ? 'start' : 'top');\r\n    }\r\n    /**\r\n     * Measure the combined size of all of the rendered items.\r\n     * @return {?}\r\n     */\r\n    measureRenderedContentSize() {\r\n        /** @type {?} */\r\n        const contentEl = this._contentWrapper.nativeElement;\r\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\r\n    }\r\n    /**\r\n     * Measure the total combined size of the given range. Throws if the range includes items that are\r\n     * not rendered.\r\n     * @param {?} range\r\n     * @return {?}\r\n     */\r\n    measureRangeSize(range) {\r\n        if (!this._forOf) {\r\n            return 0;\r\n        }\r\n        return this._forOf.measureRangeSize(range, this.orientation);\r\n    }\r\n    /**\r\n     * Update the viewport dimensions and re-render.\r\n     * @return {?}\r\n     */\r\n    checkViewportSize() {\r\n        // TODO: Cleanup later when add logic for handling content resize\r\n        this._measureViewportSize();\r\n        this._scrollStrategy.onDataLengthChanged();\r\n    }\r\n    /**\r\n     * Measure the viewport size.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _measureViewportSize() {\r\n        /** @type {?} */\r\n        const viewportEl = this.elementRef.nativeElement;\r\n        this._viewportSize = this.orientation === 'horizontal' ?\r\n            viewportEl.clientWidth : viewportEl.clientHeight;\r\n    }\r\n    /**\r\n     * Queue up change detection to run.\r\n     * @private\r\n     * @param {?=} runAfter\r\n     * @return {?}\r\n     */\r\n    _markChangeDetectionNeeded(runAfter) {\r\n        if (runAfter) {\r\n            this._runAfterChangeDetection.push(runAfter);\r\n        }\r\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\r\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\r\n        if (!this._isChangeDetectionPending) {\r\n            this._isChangeDetectionPending = true;\r\n            this.ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => Promise.resolve().then((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this._doChangeDetection();\r\n            }))));\r\n        }\r\n    }\r\n    /**\r\n     * Run change detection.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _doChangeDetection() {\r\n        this._isChangeDetectionPending = false;\r\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\r\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\r\n        // instead does not properly check the projected content.\r\n        this.ngZone.run((/**\r\n         * @return {?}\r\n         */\r\n        () => this._changeDetectorRef.markForCheck()));\r\n        // Apply the content transform. The transform can't be set via an Angular binding because\r\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\r\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\r\n        // the `Number` function first to coerce it to a numeric value.\r\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\r\n        /** @type {?} */\r\n        const runAfterChangeDetection = this._runAfterChangeDetection;\r\n        this._runAfterChangeDetection = [];\r\n        for (const fn of runAfterChangeDetection) {\r\n            fn();\r\n        }\r\n    }\r\n    /**\r\n     * Calculates the `style.width` and `style.height` for the spacer element.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _calculateSpacerSize() {\r\n        this._totalContentHeight =\r\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\r\n        this._totalContentWidth =\r\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\r\n    }\r\n}\r\nCdkVirtualScrollViewport.decorators = [\r\n    { type: Component, args: [{selector: 'cdk-virtual-scroll-viewport',\r\n                template: \"<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\"><ng-content></ng-content></div><div class=\\\"cdk-virtual-scroll-spacer\\\" [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\",\r\n                styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:0}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:0}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\"],\r\n                host: {\r\n                    'class': 'cdk-virtual-scroll-viewport',\r\n                    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\r\n                    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                providers: [{\r\n                        provide: CdkScrollable,\r\n                        useExisting: CdkVirtualScrollViewport,\r\n                    }]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkVirtualScrollViewport.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ChangeDetectorRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [VIRTUAL_SCROLL_STRATEGY,] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: ScrollDispatcher }\r\n];\r\nCdkVirtualScrollViewport.propDecorators = {\r\n    orientation: [{ type: Input }],\r\n    scrolledIndexChange: [{ type: Output }],\r\n    _contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { static: true },] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Helper to extract size from a DOM Node.\r\n * @param {?} orientation\r\n * @param {?} node\r\n * @return {?}\r\n */\r\nfunction getSize(orientation, node) {\r\n    /** @type {?} */\r\n    const el = (/** @type {?} */ (node));\r\n    if (!el.getBoundingClientRect) {\r\n        return 0;\r\n    }\r\n    /** @type {?} */\r\n    const rect = el.getBoundingClientRect();\r\n    return orientation == 'horizontal' ? rect.width : rect.height;\r\n}\r\n/**\r\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\r\n * container.\r\n * @template T\r\n */\r\nclass CdkVirtualForOf {\r\n    /**\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} _template\r\n     * @param {?} _differs\r\n     * @param {?} _viewport\r\n     * @param {?} ngZone\r\n     */\r\n    constructor(_viewContainerRef, _template, _differs, _viewport, ngZone) {\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._template = _template;\r\n        this._differs = _differs;\r\n        this._viewport = _viewport;\r\n        /**\r\n         * Emits when the rendered view of the data changes.\r\n         */\r\n        this.viewChange = new Subject();\r\n        /**\r\n         * Subject that emits when a new DataSource instance is given.\r\n         */\r\n        this._dataSourceChanges = new Subject();\r\n        /**\r\n         * The size of the cache used to store templates that are not being used for re-use later.\r\n         * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\r\n         */\r\n        this.cdkVirtualForTemplateCacheSize = 20;\r\n        /**\r\n         * Emits whenever the data in the current DataSource changes.\r\n         */\r\n        this.dataStream = this._dataSourceChanges\r\n            .pipe(\r\n        // Start off with null `DataSource`.\r\n        startWith((/** @type {?} */ (null))), \r\n        // Bundle up the previous and current data sources so we can work with both.\r\n        pairwise(), \r\n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\r\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\r\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\r\n        switchMap((/**\r\n         * @param {?} __0\r\n         * @return {?}\r\n         */\r\n        ([prev, cur]) => this._changeDataSource(prev, cur))), \r\n        // Replay the last emitted data when someone subscribes.\r\n        shareReplay(1));\r\n        /**\r\n         * The differ used to calculate changes to the data.\r\n         */\r\n        this._differ = null;\r\n        /**\r\n         * The template cache used to hold on ot template instancess that have been stamped out, but don't\r\n         * currently need to be rendered. These instances will be reused in the future rather than\r\n         * stamping out brand new ones.\r\n         */\r\n        this._templateCache = [];\r\n        /**\r\n         * Whether the rendered data should be updated during the next ngDoCheck cycle.\r\n         */\r\n        this._needsUpdate = false;\r\n        this._destroyed = new Subject();\r\n        this.dataStream.subscribe((/**\r\n         * @param {?} data\r\n         * @return {?}\r\n         */\r\n        data => {\r\n            this._data = data;\r\n            this._onRenderedDataChange();\r\n        }));\r\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((/**\r\n         * @param {?} range\r\n         * @return {?}\r\n         */\r\n        range => {\r\n            this._renderedRange = range;\r\n            ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => this.viewChange.next(this._renderedRange)));\r\n            this._onRenderedDataChange();\r\n        }));\r\n        this._viewport.attach(this);\r\n    }\r\n    /**\r\n     * The DataSource to display.\r\n     * @return {?}\r\n     */\r\n    get cdkVirtualForOf() {\r\n        return this._cdkVirtualForOf;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set cdkVirtualForOf(value) {\r\n        this._cdkVirtualForOf = value;\r\n        /** @type {?} */\r\n        const ds = isDataSource(value) ? value :\r\n            // Slice the value if its an NgIterable to ensure we're working with an array.\r\n            new ArrayDataSource(value instanceof Observable ? value : Array.prototype.slice.call(value || []));\r\n        this._dataSourceChanges.next(ds);\r\n    }\r\n    /**\r\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\r\n     * the item and produces a value to be used as the item's identity when tracking changes.\r\n     * @return {?}\r\n     */\r\n    get cdkVirtualForTrackBy() {\r\n        return this._cdkVirtualForTrackBy;\r\n    }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    set cdkVirtualForTrackBy(fn) {\r\n        this._needsUpdate = true;\r\n        this._cdkVirtualForTrackBy = fn ?\r\n            (/**\r\n             * @param {?} index\r\n             * @param {?} item\r\n             * @return {?}\r\n             */\r\n            (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item)) :\r\n            undefined;\r\n    }\r\n    /**\r\n     * The template used to stamp out new elements.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set cdkVirtualForTemplate(value) {\r\n        if (value) {\r\n            this._needsUpdate = true;\r\n            this._template = value;\r\n        }\r\n    }\r\n    /**\r\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\r\n     * in the specified range. Throws an error if the range includes items that are not currently\r\n     * rendered.\r\n     * @param {?} range\r\n     * @param {?} orientation\r\n     * @return {?}\r\n     */\r\n    measureRangeSize(range, orientation) {\r\n        if (range.start >= range.end) {\r\n            return 0;\r\n        }\r\n        if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {\r\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\r\n        }\r\n        // The index into the list of rendered views for the first item in the range.\r\n        /** @type {?} */\r\n        const renderedStartIndex = range.start - this._renderedRange.start;\r\n        // The length of the range we're measuring.\r\n        /** @type {?} */\r\n        const rangeLen = range.end - range.start;\r\n        // Loop over all root nodes for all items in the range and sum up their size.\r\n        /** @type {?} */\r\n        let totalSize = 0;\r\n        /** @type {?} */\r\n        let i = rangeLen;\r\n        while (i--) {\r\n            /** @type {?} */\r\n            const view = (/** @type {?} */ (this._viewContainerRef.get(i + renderedStartIndex)));\r\n            /** @type {?} */\r\n            let j = view ? view.rootNodes.length : 0;\r\n            while (j--) {\r\n                totalSize += getSize(orientation, (/** @type {?} */ (view)).rootNodes[j]);\r\n            }\r\n        }\r\n        return totalSize;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngDoCheck() {\r\n        if (this._differ && this._needsUpdate) {\r\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\r\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\r\n            // changing (need to do this diff).\r\n            /** @type {?} */\r\n            const changes = this._differ.diff(this._renderedItems);\r\n            if (!changes) {\r\n                this._updateContext();\r\n            }\r\n            else {\r\n                this._applyChanges(changes);\r\n            }\r\n            this._needsUpdate = false;\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._viewport.detach();\r\n        this._dataSourceChanges.next();\r\n        this._dataSourceChanges.complete();\r\n        this.viewChange.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n        for (let view of this._templateCache) {\r\n            view.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * React to scroll state changes in the viewport.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _onRenderedDataChange() {\r\n        if (!this._renderedRange) {\r\n            return;\r\n        }\r\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\r\n        if (!this._differ) {\r\n            this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);\r\n        }\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Swap out one `DataSource` for another.\r\n     * @private\r\n     * @param {?} oldDs\r\n     * @param {?} newDs\r\n     * @return {?}\r\n     */\r\n    _changeDataSource(oldDs, newDs) {\r\n        if (oldDs) {\r\n            oldDs.disconnect(this);\r\n        }\r\n        this._needsUpdate = true;\r\n        return newDs ? newDs.connect(this) : of();\r\n    }\r\n    /**\r\n     * Update the `CdkVirtualForOfContext` for all views.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateContext() {\r\n        /** @type {?} */\r\n        const count = this._data.length;\r\n        /** @type {?} */\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            /** @type {?} */\r\n            let view = (/** @type {?} */ (this._viewContainerRef.get(i)));\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n            view.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * Apply changes to the DOM.\r\n     * @private\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    _applyChanges(changes) {\r\n        // Rearrange the views to put them in the right location.\r\n        changes.forEachOperation((/**\r\n         * @param {?} record\r\n         * @param {?} adjustedPreviousIndex\r\n         * @param {?} currentIndex\r\n         * @return {?}\r\n         */\r\n        (record, adjustedPreviousIndex, currentIndex) => {\r\n            if (record.previousIndex == null) { // Item added.\r\n                // Item added.\r\n                /** @type {?} */\r\n                const view = this._insertViewForNewItem((/** @type {?} */ (currentIndex)));\r\n                view.context.$implicit = record.item;\r\n            }\r\n            else if (currentIndex == null) { // Item removed.\r\n                this._cacheView(this._detachView((/** @type {?} */ (adjustedPreviousIndex))));\r\n            }\r\n            else { // Item moved.\r\n                // Item moved.\r\n                /** @type {?} */\r\n                const view = (/** @type {?} */ (this._viewContainerRef.get((/** @type {?} */ (adjustedPreviousIndex)))));\r\n                this._viewContainerRef.move(view, currentIndex);\r\n                view.context.$implicit = record.item;\r\n            }\r\n        }));\r\n        // Update $implicit for any items that had an identity change.\r\n        changes.forEachIdentityChange((/**\r\n         * @param {?} record\r\n         * @return {?}\r\n         */\r\n        (record) => {\r\n            /** @type {?} */\r\n            const view = (/** @type {?} */ (this._viewContainerRef.get((/** @type {?} */ (record.currentIndex)))));\r\n            view.context.$implicit = record.item;\r\n        }));\r\n        // Update the context variables on all items.\r\n        /** @type {?} */\r\n        const count = this._data.length;\r\n        /** @type {?} */\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            /** @type {?} */\r\n            const view = (/** @type {?} */ (this._viewContainerRef.get(i)));\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n        }\r\n    }\r\n    /**\r\n     * Cache the given detached view.\r\n     * @private\r\n     * @param {?} view\r\n     * @return {?}\r\n     */\r\n    _cacheView(view) {\r\n        if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {\r\n            this._templateCache.push(view);\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            const index = this._viewContainerRef.indexOf(view);\r\n            // It's very unlikely that the index will ever be -1, but just in case,\r\n            // destroy the view on its own, otherwise destroy it through the\r\n            // container to ensure that all the references are removed.\r\n            if (index === -1) {\r\n                view.destroy();\r\n            }\r\n            else {\r\n                this._viewContainerRef.remove(index);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a view for a new item, either from the cache or by creating a new one.\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _insertViewForNewItem(index) {\r\n        return this._insertViewFromCache(index) || this._createEmbeddedViewAt(index);\r\n    }\r\n    /**\r\n     * Update the computed properties on the `CdkVirtualForOfContext`.\r\n     * @private\r\n     * @param {?} context\r\n     * @return {?}\r\n     */\r\n    _updateComputedContextProperties(context) {\r\n        context.first = context.index === 0;\r\n        context.last = context.index === context.count - 1;\r\n        context.even = context.index % 2 === 0;\r\n        context.odd = !context.even;\r\n    }\r\n    /**\r\n     * Creates a new embedded view and moves it to the given index\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _createEmbeddedViewAt(index) {\r\n        // Note that it's important that we insert the item directly at the proper index,\r\n        // rather than inserting it and the moving it in place, because if there's a directive\r\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\r\n        // comment node which can throw off the move when it's being repeated for all items.\r\n        return this._viewContainerRef.createEmbeddedView(this._template, {\r\n            $implicit: (/** @type {?} */ (null)),\r\n            cdkVirtualForOf: this._cdkVirtualForOf,\r\n            index: -1,\r\n            count: -1,\r\n            first: false,\r\n            last: false,\r\n            odd: false,\r\n            even: false\r\n        }, index);\r\n    }\r\n    /**\r\n     * Inserts a recycled view from the cache at the given index.\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _insertViewFromCache(index) {\r\n        /** @type {?} */\r\n        const cachedView = this._templateCache.pop();\r\n        if (cachedView) {\r\n            this._viewContainerRef.insert(cachedView, index);\r\n        }\r\n        return cachedView || null;\r\n    }\r\n    /**\r\n     * Detaches the embedded view at the given index.\r\n     * @private\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    _detachView(index) {\r\n        return (/** @type {?} */ (this._viewContainerRef.detach(index)));\r\n    }\r\n}\r\nCdkVirtualForOf.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkVirtualFor][cdkVirtualForOf]',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkVirtualForOf.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: CdkVirtualScrollViewport, decorators: [{ type: SkipSelf }] },\r\n    { type: NgZone }\r\n];\r\nCdkVirtualForOf.propDecorators = {\r\n    cdkVirtualForOf: [{ type: Input }],\r\n    cdkVirtualForTrackBy: [{ type: Input }],\r\n    cdkVirtualForTemplate: [{ type: Input }],\r\n    cdkVirtualForTemplateCacheSize: [{ type: Input }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass ScrollingModule {\r\n}\r\nScrollingModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [BidiModule, PlatformModule],\r\n                exports: [\r\n                    BidiModule,\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkScrollable,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ],\r\n                declarations: [\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkScrollable,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ],\r\n            },] },\r\n];\r\n/**\r\n * @deprecated ScrollDispatchModule has been renamed to ScrollingModule.\r\n * \\@breaking-change 8.0.0 delete this alias\r\n */\r\nclass ScrollDispatchModule {\r\n}\r\nScrollDispatchModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [ScrollingModule],\r\n                exports: [ScrollingModule],\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Time in ms to throttle the resize events by default.\r\n * @type {?}\r\n */\r\nconst DEFAULT_RESIZE_TIME = 20;\r\n/**\r\n * Simple utility for getting the bounds of the browser viewport.\r\n * \\@docs-private\r\n */\r\nclass ViewportRuler {\r\n    /**\r\n     * @param {?} _platform\r\n     * @param {?} ngZone\r\n     */\r\n    constructor(_platform, ngZone) {\r\n        this._platform = _platform;\r\n        ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._change = _platform.isBrowser ?\r\n                merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange')) :\r\n                of();\r\n            // Note that we need to do the subscription inside `runOutsideAngular`\r\n            // since subscribing is what causes the event listener to be added.\r\n            this._invalidateCache = this.change().subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this._updateViewportSize()));\r\n        }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._invalidateCache.unsubscribe();\r\n    }\r\n    /**\r\n     * Returns the viewport's width and height.\r\n     * @return {?}\r\n     */\r\n    getViewportSize() {\r\n        if (!this._viewportSize) {\r\n            this._updateViewportSize();\r\n        }\r\n        /** @type {?} */\r\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\r\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\r\n        if (!this._platform.isBrowser) {\r\n            this._viewportSize = (/** @type {?} */ (null));\r\n        }\r\n        return output;\r\n    }\r\n    /**\r\n     * Gets a ClientRect for the viewport's bounds.\r\n     * @return {?}\r\n     */\r\n    getViewportRect() {\r\n        // Use the document element's bounding rect rather than the window scroll properties\r\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n        // We use the documentElement instead of the body because, by default (without a css reset)\r\n        // browsers typically give the document body an 8px margin, which is not included in\r\n        // getBoundingClientRect().\r\n        /** @type {?} */\r\n        const scrollPosition = this.getViewportScrollPosition();\r\n        const { width, height } = this.getViewportSize();\r\n        return {\r\n            top: scrollPosition.top,\r\n            left: scrollPosition.left,\r\n            bottom: scrollPosition.top + height,\r\n            right: scrollPosition.left + width,\r\n            height,\r\n            width,\r\n        };\r\n    }\r\n    /**\r\n     * Gets the (top, left) scroll position of the viewport.\r\n     * @return {?}\r\n     */\r\n    getViewportScrollPosition() {\r\n        // While we can get a reference to the fake document\r\n        // during SSR, it doesn't have getBoundingClientRect.\r\n        if (!this._platform.isBrowser) {\r\n            return { top: 0, left: 0 };\r\n        }\r\n        // The top-left-corner of the viewport is determined by the scroll position of the document\r\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n        // `document.documentElement` works consistently, where the `top` and `left` values will\r\n        // equal negative the scroll position.\r\n        /** @type {?} */\r\n        const documentElement = (/** @type {?} */ (document.documentElement));\r\n        /** @type {?} */\r\n        const documentRect = documentElement.getBoundingClientRect();\r\n        /** @type {?} */\r\n        const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\r\n            documentElement.scrollTop || 0;\r\n        /** @type {?} */\r\n        const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\r\n            documentElement.scrollLeft || 0;\r\n        return { top, left };\r\n    }\r\n    /**\r\n     * Returns a stream that emits whenever the size of the viewport changes.\r\n     * @param {?=} throttleTime Time in milliseconds to throttle the stream.\r\n     * @return {?}\r\n     */\r\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\r\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\r\n    }\r\n    /**\r\n     * Updates the cached viewport size.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateViewportSize() {\r\n        this._viewportSize = this._platform.isBrowser ?\r\n            { width: window.innerWidth, height: window.innerHeight } :\r\n            { width: 0, height: 0 };\r\n    }\r\n}\r\nViewportRuler.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nViewportRuler.ctorParameters = () => [\r\n    { type: Platform },\r\n    { type: NgZone }\r\n];\r\n/** @nocollapse */ ViewportRuler.ngInjectableDef = ɵɵdefineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(ɵɵinject(Platform), ɵɵinject(NgZone)); }, token: ViewportRuler, providedIn: \"root\" });\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentRuler\r\n * @param {?} platform\r\n * @param {?} ngZone\r\n * @return {?}\r\n */\r\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\r\n    return parentRuler || new ViewportRuler(platform, ngZone);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nconst VIEWPORT_RULER_PROVIDER = {\r\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\r\n    provide: ViewportRuler,\r\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\r\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { _fixedSizeVirtualScrollStrategyFactory, FixedSizeVirtualScrollStrategy, CdkFixedSizeVirtualScroll, SCROLL_DISPATCHER_PROVIDER_FACTORY, DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, ScrollingModule, ScrollDispatchModule, VIEWPORT_RULER_PROVIDER_FACTORY, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER, CdkVirtualForOf, VIRTUAL_SCROLL_STRATEGY, CdkVirtualScrollViewport };\r\n\r\n"]}