{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm2015/observers.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;CAQC,6BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkHD,8OAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiGD,qHAMC;;;;;;;;;;;;;;;;;;;;;;;;CAaD,wLAOC","file":"observers.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { coerceBooleanProperty, coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\r\n * \\@docs-private\r\n */\r\nclass MutationObserverFactory {\r\n    /**\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    create(callback) {\r\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\r\n    }\r\n}\r\nMutationObserverFactory.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */ MutationObserverFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\r\n/**\r\n * An injectable service that allows watching elements for changes to their content.\r\n */\r\nclass ContentObserver {\r\n    /**\r\n     * @param {?} _mutationObserverFactory\r\n     */\r\n    constructor(_mutationObserverFactory) {\r\n        this._mutationObserverFactory = _mutationObserverFactory;\r\n        /**\r\n         * Keeps track of the existing MutationObservers so they can be reused.\r\n         */\r\n        this._observedElements = new Map();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._observedElements.forEach((/**\r\n         * @param {?} _\r\n         * @param {?} element\r\n         * @return {?}\r\n         */\r\n        (_, element) => this._cleanupObserver(element)));\r\n    }\r\n    /**\r\n     * @param {?} elementOrRef\r\n     * @return {?}\r\n     */\r\n    observe(elementOrRef) {\r\n        /** @type {?} */\r\n        const element = coerceElement(elementOrRef);\r\n        return new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        (observer) => {\r\n            /** @type {?} */\r\n            const stream = this._observeElement(element);\r\n            /** @type {?} */\r\n            const subscription = stream.subscribe(observer);\r\n            return (/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                subscription.unsubscribe();\r\n                this._unobserveElement(element);\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Observes the given element by using the existing MutationObserver if available, or creating a\r\n     * new one if not.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _observeElement(element) {\r\n        if (!this._observedElements.has(element)) {\r\n            /** @type {?} */\r\n            const stream = new Subject();\r\n            /** @type {?} */\r\n            const observer = this._mutationObserverFactory.create((/**\r\n             * @param {?} mutations\r\n             * @return {?}\r\n             */\r\n            mutations => stream.next(mutations)));\r\n            if (observer) {\r\n                observer.observe(element, {\r\n                    characterData: true,\r\n                    childList: true,\r\n                    subtree: true\r\n                });\r\n            }\r\n            this._observedElements.set(element, { observer, stream, count: 1 });\r\n        }\r\n        else {\r\n            (/** @type {?} */ (this._observedElements.get(element))).count++;\r\n        }\r\n        return (/** @type {?} */ (this._observedElements.get(element))).stream;\r\n    }\r\n    /**\r\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\r\n     * observing this element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _unobserveElement(element) {\r\n        if (this._observedElements.has(element)) {\r\n            (/** @type {?} */ (this._observedElements.get(element))).count--;\r\n            if (!(/** @type {?} */ (this._observedElements.get(element))).count) {\r\n                this._cleanupObserver(element);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Clean up the underlying MutationObserver for the specified element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _cleanupObserver(element) {\r\n        if (this._observedElements.has(element)) {\r\n            const { observer, stream } = (/** @type {?} */ (this._observedElements.get(element)));\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n            stream.complete();\r\n            this._observedElements.delete(element);\r\n        }\r\n    }\r\n}\r\nContentObserver.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nContentObserver.ctorParameters = () => [\r\n    { type: MutationObserverFactory }\r\n];\r\n/** @nocollapse */ ContentObserver.ngInjectableDef = ɵɵdefineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(ɵɵinject(MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\r\n/**\r\n * Directive that triggers a callback whenever the content of\r\n * its associated element has changed.\r\n */\r\nclass CdkObserveContent {\r\n    /**\r\n     * @param {?} _contentObserver\r\n     * @param {?} _elementRef\r\n     * @param {?} _ngZone\r\n     */\r\n    constructor(_contentObserver, _elementRef, _ngZone) {\r\n        this._contentObserver = _contentObserver;\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        /**\r\n         * Event emitted for each change in the element's content.\r\n         */\r\n        this.event = new EventEmitter();\r\n        this._disabled = false;\r\n        this._currentSubscription = null;\r\n    }\r\n    /**\r\n     * Whether observing content is disabled. This option can be used\r\n     * to disconnect the underlying MutationObserver until it is needed.\r\n     * @return {?}\r\n     */\r\n    get disabled() { return this._disabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        this._disabled ? this._unsubscribe() : this._subscribe();\r\n    }\r\n    /**\r\n     * Debounce interval for emitting the changes.\r\n     * @return {?}\r\n     */\r\n    get debounce() { return this._debounce; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set debounce(value) {\r\n        this._debounce = coerceNumberProperty(value);\r\n        this._subscribe();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        if (!this._currentSubscription && !this.disabled) {\r\n            this._subscribe();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._unsubscribe();\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _subscribe() {\r\n        this._unsubscribe();\r\n        /** @type {?} */\r\n        const stream = this._contentObserver.observe(this._elementRef);\r\n        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\r\n        // Consider brining it back inside the zone next time we're making breaking changes.\r\n        // Bringing it back inside can cause things like infinite change detection loops and changed\r\n        // after checked errors if people's code isn't handling it properly.\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._currentSubscription =\r\n                (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _unsubscribe() {\r\n        if (this._currentSubscription) {\r\n            this._currentSubscription.unsubscribe();\r\n        }\r\n    }\r\n}\r\nCdkObserveContent.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkObserveContent]',\r\n                exportAs: 'cdkObserveContent',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkObserveContent.ctorParameters = () => [\r\n    { type: ContentObserver },\r\n    { type: ElementRef },\r\n    { type: NgZone }\r\n];\r\nCdkObserveContent.propDecorators = {\r\n    event: [{ type: Output, args: ['cdkObserveContent',] }],\r\n    disabled: [{ type: Input, args: ['cdkObserveContentDisabled',] }],\r\n    debounce: [{ type: Input }]\r\n};\r\nclass ObserversModule {\r\n}\r\nObserversModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                exports: [CdkObserveContent],\r\n                declarations: [CdkObserveContent],\r\n                providers: [MutationObserverFactory]\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MutationObserverFactory, ContentObserver, CdkObserveContent, ObserversModule };\r\n\r\n"]}