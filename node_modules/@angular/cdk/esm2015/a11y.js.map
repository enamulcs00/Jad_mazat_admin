{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm2015/a11y.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0VC,6ZAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAumBD,yJAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmgBD,gGAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8ED,wGAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6JD,qMAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ED,6FAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkcD,ssBAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCD,wDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDD,+LAOC","file":"a11y.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { Inject, Injectable, Optional, SkipSelf, QueryList, Directive, ElementRef, Input, NgZone, isDevMode, InjectionToken, EventEmitter, Output, NgModule, ÉµÉµdefineInjectable, ÉµÉµinject } from '@angular/core';\r\nimport { Subject, Subscription, of } from 'rxjs';\r\nimport { UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, TAB, A, Z, ZERO, NINE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { debounceTime, filter, map, tap, take } from 'rxjs/operators';\r\nimport { Platform, normalizePassiveListenerOptions, PlatformModule } from '@angular/cdk/platform';\r\nimport { coerceBooleanProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { ContentObserver, ObserversModule } from '@angular/cdk/observers';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * IDs are deliminated by an empty space, as per the spec.\r\n * @type {?}\r\n */\r\nconst ID_DELIMINATOR = ' ';\r\n/**\r\n * Adds the given ID to the specified ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @param {?} id\r\n * @return {?}\r\n */\r\nfunction addAriaReferencedId(el, attr, id) {\r\n    /** @type {?} */\r\n    const ids = getAriaReferenceIds(el, attr);\r\n    if (ids.some((/**\r\n     * @param {?} existingId\r\n     * @return {?}\r\n     */\r\n    existingId => existingId.trim() == id.trim()))) {\r\n        return;\r\n    }\r\n    ids.push(id.trim());\r\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\r\n}\r\n/**\r\n * Removes the given ID from the specified ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @param {?} id\r\n * @return {?}\r\n */\r\nfunction removeAriaReferencedId(el, attr, id) {\r\n    /** @type {?} */\r\n    const ids = getAriaReferenceIds(el, attr);\r\n    /** @type {?} */\r\n    const filteredIds = ids.filter((/**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\r\n    val => val != id.trim()));\r\n    if (filteredIds.length) {\r\n        el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\r\n    }\r\n    else {\r\n        el.removeAttribute(attr);\r\n    }\r\n}\r\n/**\r\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @return {?}\r\n */\r\nfunction getAriaReferenceIds(el, attr) {\r\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\r\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * ID used for the body container where all messages are appended.\r\n * @type {?}\r\n */\r\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\r\n/**\r\n * ID prefix used for each created message element.\r\n * @type {?}\r\n */\r\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\r\n/**\r\n * Attribute given to each host element that is described by a message element.\r\n * @type {?}\r\n */\r\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\r\n/**\r\n * Global incremental identifier for each registered message element.\r\n * @type {?}\r\n */\r\nlet nextId = 0;\r\n/**\r\n * Global map of all registered message elements that have been placed into the document.\r\n * @type {?}\r\n */\r\nconst messageRegistry = new Map();\r\n/**\r\n * Container for all registered messages.\r\n * @type {?}\r\n */\r\nlet messagesContainer = null;\r\n/**\r\n * Utility that creates visually hidden elements with a message content. Useful for elements that\r\n * want to use aria-describedby to further describe themselves without adding additional visual\r\n * content.\r\n */\r\nclass AriaDescriber {\r\n    /**\r\n     * @param {?} _document\r\n     */\r\n    constructor(_document) {\r\n        this._document = _document;\r\n    }\r\n    /**\r\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\r\n     * the message. If the same message has already been registered, then it will reuse the created\r\n     * message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    describe(hostElement, message) {\r\n        if (!this._canBeDescribed(hostElement, message)) {\r\n            return;\r\n        }\r\n        if (typeof message !== 'string') {\r\n            // We need to ensure that the element has an ID.\r\n            this._setMessageId(message);\r\n            messageRegistry.set(message, { messageElement: message, referenceCount: 0 });\r\n        }\r\n        else if (!messageRegistry.has(message)) {\r\n            this._createMessageElement(message);\r\n        }\r\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\r\n            this._addMessageReference(hostElement, message);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the host element's aria-describedby reference to the message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    removeDescription(hostElement, message) {\r\n        if (!this._isElementNode(hostElement)) {\r\n            return;\r\n        }\r\n        if (this._isElementDescribedByMessage(hostElement, message)) {\r\n            this._removeMessageReference(hostElement, message);\r\n        }\r\n        // If the message is a string, it means that it's one that we created for the\r\n        // consumer so we can remove it safely, otherwise we should leave it in place.\r\n        if (typeof message === 'string') {\r\n            /** @type {?} */\r\n            const registeredMessage = messageRegistry.get(message);\r\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\r\n                this._deleteMessageElement(message);\r\n            }\r\n        }\r\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\r\n            this._deleteMessagesContainer();\r\n        }\r\n    }\r\n    /**\r\n     * Unregisters all created message elements and removes the message container.\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        /** @type {?} */\r\n        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\r\n        for (let i = 0; i < describedElements.length; i++) {\r\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\r\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n        }\r\n        if (messagesContainer) {\r\n            this._deleteMessagesContainer();\r\n        }\r\n        messageRegistry.clear();\r\n    }\r\n    /**\r\n     * Creates a new element in the visually hidden message container element with the message\r\n     * as its content and adds it to the message registry.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _createMessageElement(message) {\r\n        /** @type {?} */\r\n        const messageElement = this._document.createElement('div');\r\n        this._setMessageId(messageElement);\r\n        messageElement.textContent = message;\r\n        this._createMessagesContainer();\r\n        (/** @type {?} */ (messagesContainer)).appendChild(messageElement);\r\n        messageRegistry.set(message, { messageElement, referenceCount: 0 });\r\n    }\r\n    /**\r\n     * Assigns a unique ID to an element, if it doesn't have one already.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _setMessageId(element) {\r\n        if (!element.id) {\r\n            element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`;\r\n        }\r\n    }\r\n    /**\r\n     * Deletes the message element from the global messages container.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _deleteMessageElement(message) {\r\n        /** @type {?} */\r\n        const registeredMessage = messageRegistry.get(message);\r\n        /** @type {?} */\r\n        const messageElement = registeredMessage && registeredMessage.messageElement;\r\n        if (messagesContainer && messageElement) {\r\n            messagesContainer.removeChild(messageElement);\r\n        }\r\n        messageRegistry.delete(message);\r\n    }\r\n    /**\r\n     * Creates the global container for all aria-describedby messages.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createMessagesContainer() {\r\n        if (!messagesContainer) {\r\n            /** @type {?} */\r\n            const preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\r\n            // When going from the server to the client, we may end up in a situation where there's\r\n            // already a container on the page, but we don't have a reference to it. Clear the\r\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\r\n            // container, should be slightly faster.\r\n            if (preExistingContainer) {\r\n                (/** @type {?} */ (preExistingContainer.parentNode)).removeChild(preExistingContainer);\r\n            }\r\n            messagesContainer = this._document.createElement('div');\r\n            messagesContainer.id = MESSAGES_CONTAINER_ID;\r\n            messagesContainer.setAttribute('aria-hidden', 'true');\r\n            messagesContainer.style.display = 'none';\r\n            this._document.body.appendChild(messagesContainer);\r\n        }\r\n    }\r\n    /**\r\n     * Deletes the global messages container.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _deleteMessagesContainer() {\r\n        if (messagesContainer && messagesContainer.parentNode) {\r\n            messagesContainer.parentNode.removeChild(messagesContainer);\r\n            messagesContainer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Removes all cdk-describedby messages that are hosted through the element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _removeCdkDescribedByReferenceIds(element) {\r\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\r\n        /** @type {?} */\r\n        const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\r\n            .filter((/**\r\n         * @param {?} id\r\n         * @return {?}\r\n         */\r\n        id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0));\r\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\r\n    }\r\n    /**\r\n     * Adds a message reference to the element using aria-describedby and increments the registered\r\n     * message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _addMessageReference(element, message) {\r\n        /** @type {?} */\r\n        const registeredMessage = (/** @type {?} */ (messageRegistry.get(message)));\r\n        // Add the aria-describedby reference and set the\r\n        // describedby_host attribute to mark the element.\r\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\r\n        registeredMessage.referenceCount++;\r\n    }\r\n    /**\r\n     * Removes a message reference from the element using aria-describedby\r\n     * and decrements the registered message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _removeMessageReference(element, message) {\r\n        /** @type {?} */\r\n        const registeredMessage = (/** @type {?} */ (messageRegistry.get(message)));\r\n        registeredMessage.referenceCount--;\r\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n    }\r\n    /**\r\n     * Returns true if the element has been described by the provided message ID.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _isElementDescribedByMessage(element, message) {\r\n        /** @type {?} */\r\n        const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\r\n        /** @type {?} */\r\n        const registeredMessage = messageRegistry.get(message);\r\n        /** @type {?} */\r\n        const messageId = registeredMessage && registeredMessage.messageElement.id;\r\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\r\n    }\r\n    /**\r\n     * Determines whether a message can be described on a particular element.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    _canBeDescribed(element, message) {\r\n        if (!this._isElementNode(element)) {\r\n            return false;\r\n        }\r\n        if (message && typeof message === 'object') {\r\n            // We'd have to make some assumptions about the description element's text, if the consumer\r\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\r\n            // that it can be used as a description.\r\n            return true;\r\n        }\r\n        /** @type {?} */\r\n        const trimmedMessage = message == null ? '' : `${message}`.trim();\r\n        /** @type {?} */\r\n        const ariaLabel = element.getAttribute('aria-label');\r\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\r\n        // element, because screen readers will end up reading out the same text twice in a row.\r\n        return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\r\n    }\r\n    /**\r\n     * Checks whether a node is an Element node.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    _isElementNode(element) {\r\n        return element.nodeType === this._document.ELEMENT_NODE;\r\n    }\r\n}\r\nAriaDescriber.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nAriaDescriber.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n/** @nocollapse */ AriaDescriber.ngInjectableDef = ÉµÉµdefineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(ÉµÉµinject(DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentDispatcher\r\n * @param {?} _document\r\n * @return {?}\r\n */\r\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\r\n    return parentDispatcher || new AriaDescriber(_document);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nconst ARIA_DESCRIBER_PROVIDER = {\r\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\r\n    provide: AriaDescriber,\r\n    deps: [\r\n        [new Optional(), new SkipSelf(), AriaDescriber],\r\n        (/** @type {?} */ (DOCUMENT))\r\n    ],\r\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * This class manages keyboard events for selectable lists. If you pass it a query list\r\n * of items, it will set the active item correctly when arrow events occur.\r\n * @template T\r\n */\r\nclass ListKeyManager {\r\n    /**\r\n     * @param {?} _items\r\n     */\r\n    constructor(_items) {\r\n        this._items = _items;\r\n        this._activeItemIndex = -1;\r\n        this._activeItem = null;\r\n        this._wrap = false;\r\n        this._letterKeyStream = new Subject();\r\n        this._typeaheadSubscription = Subscription.EMPTY;\r\n        this._vertical = true;\r\n        this._allowedModifierKeys = [];\r\n        /**\r\n         * Predicate function that can be used to check whether an item should be skipped\r\n         * by the key manager. By default, disabled items are skipped.\r\n         */\r\n        this._skipPredicateFn = (/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        (item) => item.disabled);\r\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\r\n        this._pressedLetters = [];\r\n        /**\r\n         * Stream that emits any time the TAB key is pressed, so components can react\r\n         * when focus is shifted off of the list.\r\n         */\r\n        this.tabOut = new Subject();\r\n        /**\r\n         * Stream that emits whenever the active item of the list manager changes.\r\n         */\r\n        this.change = new Subject();\r\n        // We allow for the items to be an array because, in some cases, the consumer may\r\n        // not have access to a QueryList of the items they want to manage (e.g. when the\r\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\r\n        if (_items instanceof QueryList) {\r\n            _items.changes.subscribe((/**\r\n             * @param {?} newItems\r\n             * @return {?}\r\n             */\r\n            (newItems) => {\r\n                if (this._activeItem) {\r\n                    /** @type {?} */\r\n                    const itemArray = newItems.toArray();\r\n                    /** @type {?} */\r\n                    const newIndex = itemArray.indexOf(this._activeItem);\r\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\r\n                        this._activeItemIndex = newIndex;\r\n                    }\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Sets the predicate function that determines which items should be skipped by the\r\n     * list key manager.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} predicate Function that determines whether the given item should be skipped.\r\n     * @return {THIS}\r\n     */\r\n    skipPredicate(predicate) {\r\n        (/** @type {?} */ (this))._skipPredicateFn = predicate;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * Configures wrapping mode, which determines whether the active item will wrap to\r\n     * the other end of list when there are no more items in the given direction.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\r\n     * @return {THIS}\r\n     */\r\n    withWrap(shouldWrap = true) {\r\n        (/** @type {?} */ (this))._wrap = shouldWrap;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * Configures whether the key manager should be able to move the selection vertically.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} enabled Whether vertical selection should be enabled.\r\n     * @return {THIS}\r\n     */\r\n    withVerticalOrientation(enabled = true) {\r\n        (/** @type {?} */ (this))._vertical = enabled;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * Configures the key manager to move the selection horizontally.\r\n     * Passing in `null` will disable horizontal movement.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} direction Direction in which the selection can be moved.\r\n     * @return {THIS}\r\n     */\r\n    withHorizontalOrientation(direction) {\r\n        (/** @type {?} */ (this))._horizontal = direction;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\r\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} keys\r\n     * @return {THIS}\r\n     */\r\n    withAllowedModifierKeys(keys) {\r\n        (/** @type {?} */ (this))._allowedModifierKeys = keys;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * Turns on typeahead mode which allows users to set the active item by typing.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\r\n     * @return {THIS}\r\n     */\r\n    withTypeAhead(debounceInterval = 200) {\r\n        if ((/** @type {?} */ (this))._items.length && (/** @type {?} */ (this))._items.some((/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        item => typeof item.getLabel !== 'function'))) {\r\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\r\n        }\r\n        (/** @type {?} */ (this))._typeaheadSubscription.unsubscribe();\r\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\r\n        // and convert those letters back into a string. Afterwards find the first item that starts\r\n        // with that string and select it.\r\n        (/** @type {?} */ (this))._typeaheadSubscription = (/** @type {?} */ (this))._letterKeyStream.pipe(tap((/**\r\n         * @param {?} keyCode\r\n         * @return {?}\r\n         */\r\n        keyCode => (/** @type {?} */ (this))._pressedLetters.push(keyCode))), debounceTime(debounceInterval), filter((/**\r\n         * @return {?}\r\n         */\r\n        () => (/** @type {?} */ (this))._pressedLetters.length > 0)), map((/**\r\n         * @return {?}\r\n         */\r\n        () => (/** @type {?} */ (this))._pressedLetters.join('')))).subscribe((/**\r\n         * @param {?} inputString\r\n         * @return {?}\r\n         */\r\n        inputString => {\r\n            /** @type {?} */\r\n            const items = (/** @type {?} */ (this))._getItemsArray();\r\n            // Start at 1 because we want to start searching at the item immediately\r\n            // following the current active item.\r\n            for (let i = 1; i < items.length + 1; i++) {\r\n                /** @type {?} */\r\n                const index = ((/** @type {?} */ (this))._activeItemIndex + i) % items.length;\r\n                /** @type {?} */\r\n                const item = items[index];\r\n                if (!(/** @type {?} */ (this))._skipPredicateFn(item) &&\r\n                    (/** @type {?} */ (item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\r\n                    (/** @type {?} */ (this)).setActiveItem(index);\r\n                    break;\r\n                }\r\n            }\r\n            (/** @type {?} */ (this))._pressedLetters = [];\r\n        }));\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    setActiveItem(item) {\r\n        /** @type {?} */\r\n        const previousIndex = this._activeItemIndex;\r\n        this.updateActiveItem(item);\r\n        if (this._activeItemIndex !== previousIndex) {\r\n            this.change.next(this._activeItemIndex);\r\n        }\r\n    }\r\n    /**\r\n     * Sets the active item depending on the key event passed in.\r\n     * @param {?} event Keyboard event to be used for determining which element should be active.\r\n     * @return {?}\r\n     */\r\n    onKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        /** @type {?} */\r\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\r\n        /** @type {?} */\r\n        const isModifierAllowed = modifiers.every((/**\r\n         * @param {?} modifier\r\n         * @return {?}\r\n         */\r\n        modifier => {\r\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\r\n        }));\r\n        switch (keyCode) {\r\n            case TAB:\r\n                this.tabOut.next();\r\n                return;\r\n            case DOWN_ARROW:\r\n                if (this._vertical && isModifierAllowed) {\r\n                    this.setNextItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case UP_ARROW:\r\n                if (this._vertical && isModifierAllowed) {\r\n                    this.setPreviousItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case RIGHT_ARROW:\r\n                if (this._horizontal && isModifierAllowed) {\r\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case LEFT_ARROW:\r\n                if (this._horizontal && isModifierAllowed) {\r\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            default:\r\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\r\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\r\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\r\n                    if (event.key && event.key.length === 1) {\r\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\r\n                    }\r\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\r\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\r\n                    }\r\n                }\r\n                // Note that we return here, in order to avoid preventing\r\n                // the default action of non-navigational keys.\r\n                return;\r\n        }\r\n        this._pressedLetters = [];\r\n        event.preventDefault();\r\n    }\r\n    /**\r\n     * Index of the currently active item.\r\n     * @return {?}\r\n     */\r\n    get activeItemIndex() {\r\n        return this._activeItemIndex;\r\n    }\r\n    /**\r\n     * The active item.\r\n     * @return {?}\r\n     */\r\n    get activeItem() {\r\n        return this._activeItem;\r\n    }\r\n    /**\r\n     * Sets the active item to the first enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    setFirstItemActive() {\r\n        this._setActiveItemByIndex(0, 1);\r\n    }\r\n    /**\r\n     * Sets the active item to the last enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    setLastItemActive() {\r\n        this._setActiveItemByIndex(this._items.length - 1, -1);\r\n    }\r\n    /**\r\n     * Sets the active item to the next enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    setNextItemActive() {\r\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\r\n    }\r\n    /**\r\n     * Sets the active item to a previous enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    setPreviousItemActive() {\r\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\r\n            : this._setActiveItemByDelta(-1);\r\n    }\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    updateActiveItem(item) {\r\n        /** @type {?} */\r\n        const itemArray = this._getItemsArray();\r\n        /** @type {?} */\r\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\r\n        /** @type {?} */\r\n        const activeItem = itemArray[index];\r\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\r\n        this._activeItem = activeItem == null ? null : activeItem;\r\n        this._activeItemIndex = index;\r\n    }\r\n    /**\r\n     * Allows setting of the activeItemIndex without any other effects.\r\n     * @deprecated Use `updateActiveItem` instead.\r\n     * \\@breaking-change 8.0.0\r\n     * @param {?} index The new activeItemIndex.\r\n     * @return {?}\r\n     */\r\n    updateActiveItemIndex(index) {\r\n        this.updateActiveItem(index);\r\n    }\r\n    /**\r\n     * This method sets the active item, given a list of items and the delta between the\r\n     * currently active item and the new active item. It will calculate differently\r\n     * depending on whether wrap mode is turned on.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    _setActiveItemByDelta(delta) {\r\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\r\n    }\r\n    /**\r\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\r\n     * down the list until it finds an item that is not disabled, and it will wrap if it\r\n     * encounters either end of the list.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    _setActiveInWrapMode(delta) {\r\n        /** @type {?} */\r\n        const items = this._getItemsArray();\r\n        for (let i = 1; i <= items.length; i++) {\r\n            /** @type {?} */\r\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\r\n            /** @type {?} */\r\n            const item = items[index];\r\n            if (!this._skipPredicateFn(item)) {\r\n                this.setActiveItem(index);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sets the active item properly given the default mode. In other words, it will\r\n     * continue to move down the list until it finds an item that is not disabled. If\r\n     * it encounters either end of the list, it will stop and not wrap.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    _setActiveInDefaultMode(delta) {\r\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\r\n    }\r\n    /**\r\n     * Sets the active item to the first enabled item starting at the index specified. If the\r\n     * item is disabled, it will move in the fallbackDelta direction until it either\r\n     * finds an enabled item or encounters the end of the list.\r\n     * @private\r\n     * @param {?} index\r\n     * @param {?} fallbackDelta\r\n     * @return {?}\r\n     */\r\n    _setActiveItemByIndex(index, fallbackDelta) {\r\n        /** @type {?} */\r\n        const items = this._getItemsArray();\r\n        if (!items[index]) {\r\n            return;\r\n        }\r\n        while (this._skipPredicateFn(items[index])) {\r\n            index += fallbackDelta;\r\n            if (!items[index]) {\r\n                return;\r\n            }\r\n        }\r\n        this.setActiveItem(index);\r\n    }\r\n    /**\r\n     * Returns the items as an array.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getItemsArray() {\r\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\r\n    }\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n */\r\nclass ActiveDescendantKeyManager extends ListKeyManager {\r\n    /**\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    setActiveItem(index) {\r\n        if (this.activeItem) {\r\n            this.activeItem.setInactiveStyles();\r\n        }\r\n        super.setActiveItem(index);\r\n        if (this.activeItem) {\r\n            this.activeItem.setActiveStyles();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n */\r\nclass FocusKeyManager extends ListKeyManager {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._origin = 'program';\r\n    }\r\n    /**\r\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} origin Focus origin to be used when focusing items.\r\n     * @return {THIS}\r\n     */\r\n    setFocusOrigin(origin) {\r\n        (/** @type {?} */ (this))._origin = origin;\r\n        return (/** @type {?} */ (this));\r\n    }\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    setActiveItem(item) {\r\n        super.setActiveItem(item);\r\n        if (this.activeItem) {\r\n            this.activeItem.focus(this._origin);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\r\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\r\n// supported.\r\n/**\r\n * Utility for checking the interactivity of an element, such as whether is is focusable or\r\n * tabbable.\r\n */\r\nclass InteractivityChecker {\r\n    /**\r\n     * @param {?} _platform\r\n     */\r\n    constructor(_platform) {\r\n        this._platform = _platform;\r\n    }\r\n    /**\r\n     * Gets whether an element is disabled.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is disabled.\r\n     */\r\n    isDisabled(element) {\r\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\r\n        // a form control inside of a disabled form, but should capture the most common cases.\r\n        return element.hasAttribute('disabled');\r\n    }\r\n    /**\r\n     * Gets whether an element is visible for the purposes of interactivity.\r\n     *\r\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\r\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\r\n     *\r\n     * @param {?} element\r\n     * @return {?} Whether the element is visible.\r\n     */\r\n    isVisible(element) {\r\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\r\n    }\r\n    /**\r\n     * Gets whether an element can be reached via Tab key.\r\n     * Assumes that the element has already been checked with isFocusable.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is tabbable.\r\n     */\r\n    isTabbable(element) {\r\n        // Nothing is tabbable on the server ðŸ˜Ž\r\n        if (!this._platform.isBrowser) {\r\n            return false;\r\n        }\r\n        /** @type {?} */\r\n        const frameElement = getFrameElement(getWindow(element));\r\n        if (frameElement) {\r\n            /** @type {?} */\r\n            const frameType = frameElement && frameElement.nodeName.toLowerCase();\r\n            // Frame elements inherit their tabindex onto all child elements.\r\n            if (getTabIndexValue(frameElement) === -1) {\r\n                return false;\r\n            }\r\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\r\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\r\n                return false;\r\n            }\r\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\r\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\r\n                return false;\r\n            }\r\n        }\r\n        /** @type {?} */\r\n        let nodeName = element.nodeName.toLowerCase();\r\n        /** @type {?} */\r\n        let tabIndexValue = getTabIndexValue(element);\r\n        if (element.hasAttribute('contenteditable')) {\r\n            return tabIndexValue !== -1;\r\n        }\r\n        if (nodeName === 'iframe') {\r\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\r\n            // investigate the content of the frames.\r\n            return false;\r\n        }\r\n        if (nodeName === 'audio') {\r\n            if (!element.hasAttribute('controls')) {\r\n                // By default an <audio> element without the controls enabled is not tabbable.\r\n                return false;\r\n            }\r\n            else if (this._platform.BLINK) {\r\n                // In Blink <audio controls> elements are always tabbable.\r\n                return true;\r\n            }\r\n        }\r\n        if (nodeName === 'video') {\r\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\r\n                // In Trident a <video> element without the controls enabled is not tabbable.\r\n                return false;\r\n            }\r\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\r\n                // In Chrome and Firefox <video controls> elements are always tabbable.\r\n                return true;\r\n            }\r\n        }\r\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\r\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\r\n            return false;\r\n        }\r\n        // In iOS the browser only considers some specific elements as tabbable.\r\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\r\n            return false;\r\n        }\r\n        return element.tabIndex >= 0;\r\n    }\r\n    /**\r\n     * Gets whether an element can be focused by the user.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is focusable.\r\n     */\r\n    isFocusable(element) {\r\n        // Perform checks in order of left to most expensive.\r\n        // Again, naive approach that does not capture many edge cases and browser quirks.\r\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\r\n    }\r\n}\r\nInteractivityChecker.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nInteractivityChecker.ctorParameters = () => [\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ InteractivityChecker.ngInjectableDef = ÉµÉµdefineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(ÉµÉµinject(Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\r\n/**\r\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\r\n * the frameElement property is being accessed from a different host address, this property\r\n * should be accessed carefully.\r\n * @param {?} window\r\n * @return {?}\r\n */\r\nfunction getFrameElement(window) {\r\n    try {\r\n        return (/** @type {?} */ (window.frameElement));\r\n    }\r\n    catch (_a) {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Checks whether the specified element has any geometry / rectangles.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction hasGeometry(element) {\r\n    // Use logic from jQuery to check for an invisible element.\r\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\r\n    return !!(element.offsetWidth || element.offsetHeight ||\r\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\r\n}\r\n/**\r\n * Gets whether an element's\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isNativeFormElement(element) {\r\n    /** @type {?} */\r\n    let nodeName = element.nodeName.toLowerCase();\r\n    return nodeName === 'input' ||\r\n        nodeName === 'select' ||\r\n        nodeName === 'button' ||\r\n        nodeName === 'textarea';\r\n}\r\n/**\r\n * Gets whether an element is an `<input type=\"hidden\">`.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isHiddenInput(element) {\r\n    return isInputElement(element) && element.type == 'hidden';\r\n}\r\n/**\r\n * Gets whether an element is an anchor that has an href attribute.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isAnchorWithHref(element) {\r\n    return isAnchorElement(element) && element.hasAttribute('href');\r\n}\r\n/**\r\n * Gets whether an element is an input element.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isInputElement(element) {\r\n    return element.nodeName.toLowerCase() == 'input';\r\n}\r\n/**\r\n * Gets whether an element is an anchor element.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isAnchorElement(element) {\r\n    return element.nodeName.toLowerCase() == 'a';\r\n}\r\n/**\r\n * Gets whether an element has a valid tabindex.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction hasValidTabIndex(element) {\r\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\r\n        return false;\r\n    }\r\n    /** @type {?} */\r\n    let tabIndex = element.getAttribute('tabindex');\r\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\r\n    if (tabIndex == '-32768') {\r\n        return false;\r\n    }\r\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\r\n}\r\n/**\r\n * Returns the parsed tabindex from the element attributes instead of returning the\r\n * evaluated tabindex from the browsers defaults.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction getTabIndexValue(element) {\r\n    if (!hasValidTabIndex(element)) {\r\n        return null;\r\n    }\r\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\r\n    /** @type {?} */\r\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\r\n    return isNaN(tabIndex) ? -1 : tabIndex;\r\n}\r\n/**\r\n * Checks whether the specified element is potentially tabbable on iOS\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isPotentiallyTabbableIOS(element) {\r\n    /** @type {?} */\r\n    let nodeName = element.nodeName.toLowerCase();\r\n    /** @type {?} */\r\n    let inputType = nodeName === 'input' && ((/** @type {?} */ (element))).type;\r\n    return inputType === 'text'\r\n        || inputType === 'password'\r\n        || nodeName === 'select'\r\n        || nodeName === 'textarea';\r\n}\r\n/**\r\n * Gets whether an element is potentially focusable without taking current visible/disabled state\r\n * into account.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isPotentiallyFocusable(element) {\r\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\r\n    if (isHiddenInput(element)) {\r\n        return false;\r\n    }\r\n    return isNativeFormElement(element) ||\r\n        isAnchorWithHref(element) ||\r\n        element.hasAttribute('contenteditable') ||\r\n        hasValidTabIndex(element);\r\n}\r\n/**\r\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\r\n * @param {?} node\r\n * @return {?}\r\n */\r\nfunction getWindow(node) {\r\n    // ownerDocument is null if `node` itself *is* a document.\r\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Class that allows for trapping focus within a DOM element.\r\n *\r\n * This class currently uses a relatively simple approach to focus trapping.\r\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\r\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\r\n */\r\nclass FocusTrap {\r\n    /**\r\n     * @param {?} _element\r\n     * @param {?} _checker\r\n     * @param {?} _ngZone\r\n     * @param {?} _document\r\n     * @param {?=} deferAnchors\r\n     */\r\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\r\n        this._element = _element;\r\n        this._checker = _checker;\r\n        this._ngZone = _ngZone;\r\n        this._document = _document;\r\n        this._hasAttached = false;\r\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\r\n        this.startAnchorListener = (/**\r\n         * @return {?}\r\n         */\r\n        () => this.focusLastTabbableElement());\r\n        this.endAnchorListener = (/**\r\n         * @return {?}\r\n         */\r\n        () => this.focusFirstTabbableElement());\r\n        this._enabled = true;\r\n        if (!deferAnchors) {\r\n            this.attachAnchors();\r\n        }\r\n    }\r\n    /**\r\n     * Whether the focus trap is active.\r\n     * @return {?}\r\n     */\r\n    get enabled() { return this._enabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set enabled(value) {\r\n        this._enabled = value;\r\n        if (this._startAnchor && this._endAnchor) {\r\n            this._toggleAnchorTabIndex(value, this._startAnchor);\r\n            this._toggleAnchorTabIndex(value, this._endAnchor);\r\n        }\r\n    }\r\n    /**\r\n     * Destroys the focus trap by cleaning up the anchors.\r\n     * @return {?}\r\n     */\r\n    destroy() {\r\n        /** @type {?} */\r\n        const startAnchor = this._startAnchor;\r\n        /** @type {?} */\r\n        const endAnchor = this._endAnchor;\r\n        if (startAnchor) {\r\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\r\n            if (startAnchor.parentNode) {\r\n                startAnchor.parentNode.removeChild(startAnchor);\r\n            }\r\n        }\r\n        if (endAnchor) {\r\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\r\n            if (endAnchor.parentNode) {\r\n                endAnchor.parentNode.removeChild(endAnchor);\r\n            }\r\n        }\r\n        this._startAnchor = this._endAnchor = null;\r\n    }\r\n    /**\r\n     * Inserts the anchors into the DOM. This is usually done automatically\r\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\r\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\r\n     * if the target element isn't currently in the DOM.\r\n     */\r\n    attachAnchors() {\r\n        // If we're not on the browser, there can be no focus to trap.\r\n        if (this._hasAttached) {\r\n            return true;\r\n        }\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            if (!this._startAnchor) {\r\n                this._startAnchor = this._createAnchor();\r\n                (/** @type {?} */ (this._startAnchor)).addEventListener('focus', this.startAnchorListener);\r\n            }\r\n            if (!this._endAnchor) {\r\n                this._endAnchor = this._createAnchor();\r\n                (/** @type {?} */ (this._endAnchor)).addEventListener('focus', this.endAnchorListener);\r\n            }\r\n        }));\r\n        if (this._element.parentNode) {\r\n            this._element.parentNode.insertBefore((/** @type {?} */ (this._startAnchor)), this._element);\r\n            this._element.parentNode.insertBefore((/** @type {?} */ (this._endAnchor)), this._element.nextSibling);\r\n            this._hasAttached = true;\r\n        }\r\n        return this._hasAttached;\r\n    }\r\n    /**\r\n     * Waits for the zone to stabilize, then either focuses the first element that the\r\n     * user specified, or the first tabbable element.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    focusInitialElementWhenReady() {\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        resolve => {\r\n            this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            () => resolve(this.focusInitialElement())));\r\n        }));\r\n    }\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the first tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    focusFirstTabbableElementWhenReady() {\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        resolve => {\r\n            this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            () => resolve(this.focusFirstTabbableElement())));\r\n        }));\r\n    }\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the last tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    focusLastTabbableElementWhenReady() {\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        resolve => {\r\n            this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            () => resolve(this.focusLastTabbableElement())));\r\n        }));\r\n    }\r\n    /**\r\n     * Get the specified boundary element of the trapped region.\r\n     * @private\r\n     * @param {?} bound The boundary to get (start or end of trapped region).\r\n     * @return {?} The boundary element.\r\n     */\r\n    _getRegionBoundary(bound) {\r\n        // Contains the deprecated version of selector, for temporary backwards comparability.\r\n        /** @type {?} */\r\n        let markers = (/** @type {?} */ (this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\r\n            `[cdkFocusRegion${bound}], ` +\r\n            `[cdk-focus-${bound}]`)));\r\n        for (let i = 0; i < markers.length; i++) {\r\n            // @breaking-change 8.0.0\r\n            if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\r\n                console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\r\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\r\n                    `attribute will be removed in 8.0.0.`, markers[i]);\r\n            }\r\n            else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\r\n                console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\r\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\r\n                    `will be removed in 8.0.0.`, markers[i]);\r\n            }\r\n        }\r\n        if (bound == 'start') {\r\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\r\n        }\r\n        return markers.length ?\r\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\r\n    }\r\n    /**\r\n     * Focuses the element that should be focused when the focus trap is initialized.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    focusInitialElement() {\r\n        // Contains the deprecated version of selector, for temporary backwards comparability.\r\n        /** @type {?} */\r\n        const redirectToElement = (/** @type {?} */ (this._element.querySelector(`[cdk-focus-initial], ` +\r\n            `[cdkFocusInitial]`)));\r\n        if (redirectToElement) {\r\n            // @breaking-change 8.0.0\r\n            if (redirectToElement.hasAttribute(`cdk-focus-initial`)) {\r\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\r\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\r\n                    `will be removed in 8.0.0`, redirectToElement);\r\n            }\r\n            // Warn the consumer if the element they've pointed to\r\n            // isn't focusable, when not in production mode.\r\n            if (isDevMode() && !this._checker.isFocusable(redirectToElement)) {\r\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\r\n            }\r\n            redirectToElement.focus();\r\n            return true;\r\n        }\r\n        return this.focusFirstTabbableElement();\r\n    }\r\n    /**\r\n     * Focuses the first tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    focusFirstTabbableElement() {\r\n        /** @type {?} */\r\n        const redirectToElement = this._getRegionBoundary('start');\r\n        if (redirectToElement) {\r\n            redirectToElement.focus();\r\n        }\r\n        return !!redirectToElement;\r\n    }\r\n    /**\r\n     * Focuses the last tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    focusLastTabbableElement() {\r\n        /** @type {?} */\r\n        const redirectToElement = this._getRegionBoundary('end');\r\n        if (redirectToElement) {\r\n            redirectToElement.focus();\r\n        }\r\n        return !!redirectToElement;\r\n    }\r\n    /**\r\n     * Checks whether the focus trap has successfuly been attached.\r\n     * @return {?}\r\n     */\r\n    hasAttached() {\r\n        return this._hasAttached;\r\n    }\r\n    /**\r\n     * Get the first tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    _getFirstTabbableElement(root) {\r\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n            return root;\r\n        }\r\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\r\n        // back to `childNodes` which includes text nodes, comments etc.\r\n        /** @type {?} */\r\n        let children = root.children || root.childNodes;\r\n        for (let i = 0; i < children.length; i++) {\r\n            /** @type {?} */\r\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\r\n                this._getFirstTabbableElement((/** @type {?} */ (children[i]))) :\r\n                null;\r\n            if (tabbableChild) {\r\n                return tabbableChild;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get the last tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    _getLastTabbableElement(root) {\r\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n            return root;\r\n        }\r\n        // Iterate in reverse DOM order.\r\n        /** @type {?} */\r\n        let children = root.children || root.childNodes;\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            /** @type {?} */\r\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\r\n                this._getLastTabbableElement((/** @type {?} */ (children[i]))) :\r\n                null;\r\n            if (tabbableChild) {\r\n                return tabbableChild;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Creates an anchor element.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createAnchor() {\r\n        /** @type {?} */\r\n        const anchor = this._document.createElement('div');\r\n        this._toggleAnchorTabIndex(this._enabled, anchor);\r\n        anchor.classList.add('cdk-visually-hidden');\r\n        anchor.classList.add('cdk-focus-trap-anchor');\r\n        anchor.setAttribute('aria-hidden', 'true');\r\n        return anchor;\r\n    }\r\n    /**\r\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\r\n     * @private\r\n     * @param {?} isEnabled Whether the focus trap is enabled.\r\n     * @param {?} anchor Anchor on which to toggle the tabindex.\r\n     * @return {?}\r\n     */\r\n    _toggleAnchorTabIndex(isEnabled, anchor) {\r\n        // Remove the tabindex completely, rather than setting it to -1, because if the\r\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\r\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\r\n    }\r\n    /**\r\n     * Executes a function when the zone is stable.\r\n     * @private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    _executeOnStable(fn) {\r\n        if (this._ngZone.isStable) {\r\n            fn();\r\n        }\r\n        else {\r\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Factory that allows easy instantiation of focus traps.\r\n */\r\nclass FocusTrapFactory {\r\n    /**\r\n     * @param {?} _checker\r\n     * @param {?} _ngZone\r\n     * @param {?} _document\r\n     */\r\n    constructor(_checker, _ngZone, _document) {\r\n        this._checker = _checker;\r\n        this._ngZone = _ngZone;\r\n        this._document = _document;\r\n    }\r\n    /**\r\n     * Creates a focus-trapped region around the given element.\r\n     * @param {?} element The element around which focus will be trapped.\r\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\r\n     *     manually by the user.\r\n     * @return {?} The created focus trap instance.\r\n     */\r\n    create(element, deferCaptureElements = false) {\r\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\r\n    }\r\n}\r\nFocusTrapFactory.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nFocusTrapFactory.ctorParameters = () => [\r\n    { type: InteractivityChecker },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n/** @nocollapse */ FocusTrapFactory.ngInjectableDef = ÉµÉµdefineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(ÉµÉµinject(InteractivityChecker), ÉµÉµinject(NgZone), ÉµÉµinject(DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\r\n/**\r\n * Directive for trapping focus within a region.\r\n */\r\nclass CdkTrapFocus {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _focusTrapFactory\r\n     * @param {?} _document\r\n     */\r\n    constructor(_elementRef, _focusTrapFactory, _document) {\r\n        this._elementRef = _elementRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        /**\r\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\r\n         */\r\n        this._previouslyFocusedElement = null;\r\n        this._document = _document;\r\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n    }\r\n    /**\r\n     * Whether the focus trap is active.\r\n     * @return {?}\r\n     */\r\n    get enabled() { return this.focusTrap.enabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set enabled(value) { this.focusTrap.enabled = coerceBooleanProperty(value); }\r\n    /**\r\n     * Whether the directive should automatially move focus into the trapped region upon\r\n     * initialization and return focus to the previous activeElement upon destruction.\r\n     * @return {?}\r\n     */\r\n    get autoCapture() { return this._autoCapture; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set autoCapture(value) { this._autoCapture = coerceBooleanProperty(value); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.focusTrap.destroy();\r\n        // If we stored a previously focused element when using autoCapture, return focus to that\r\n        // element now that the trapped region is being destroyed.\r\n        if (this._previouslyFocusedElement) {\r\n            this._previouslyFocusedElement.focus();\r\n            this._previouslyFocusedElement = null;\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this.focusTrap.attachAnchors();\r\n        if (this.autoCapture) {\r\n            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));\r\n            this.focusTrap.focusInitialElementWhenReady();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngDoCheck() {\r\n        if (!this.focusTrap.hasAttached()) {\r\n            this.focusTrap.attachAnchors();\r\n        }\r\n    }\r\n}\r\nCdkTrapFocus.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkTrapFocus]',\r\n                exportAs: 'cdkTrapFocus',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkTrapFocus.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: FocusTrapFactory },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\nCdkTrapFocus.propDecorators = {\r\n    enabled: [{ type: Input, args: ['cdkTrapFocus',] }],\r\n    autoCapture: [{ type: Input, args: ['cdkTrapFocusAutoCapture',] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\r\n    providedIn: 'root',\r\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\r\n    return null;\r\n}\r\n/**\r\n * Injection token that can be used to configure the default options for the LiveAnnouncer.\r\n * @type {?}\r\n */\r\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass LiveAnnouncer {\r\n    /**\r\n     * @param {?} elementToken\r\n     * @param {?} _ngZone\r\n     * @param {?} _document\r\n     * @param {?=} _defaultOptions\r\n     */\r\n    constructor(elementToken, _ngZone, _document, _defaultOptions) {\r\n        this._ngZone = _ngZone;\r\n        this._defaultOptions = _defaultOptions;\r\n        // We inject the live element and document as `any` because the constructor signature cannot\r\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\r\n        // a class decorator causes TypeScript to preserve the constructor signature types.\r\n        this._document = _document;\r\n        this._liveElement = elementToken || this._createLiveElement();\r\n    }\r\n    /**\r\n     * @param {?} message\r\n     * @param {...?} args\r\n     * @return {?}\r\n     */\r\n    announce(message, ...args) {\r\n        /** @type {?} */\r\n        const defaultOptions = this._defaultOptions;\r\n        /** @type {?} */\r\n        let politeness;\r\n        /** @type {?} */\r\n        let duration;\r\n        if (args.length === 1 && typeof args[0] === 'number') {\r\n            duration = args[0];\r\n        }\r\n        else {\r\n            [politeness, duration] = args;\r\n        }\r\n        this.clear();\r\n        clearTimeout(this._previousTimeout);\r\n        if (!politeness) {\r\n            politeness =\r\n                (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\r\n        }\r\n        if (duration == null && defaultOptions) {\r\n            duration = defaultOptions.duration;\r\n        }\r\n        // TODO: ensure changing the politeness works on all environments we support.\r\n        this._liveElement.setAttribute('aria-live', politeness);\r\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\r\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\r\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\r\n        //   second time without clearing and then using a non-zero delay.\r\n        // (using JAWS 17 at time of this writing).\r\n        return this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            return new Promise((/**\r\n             * @param {?} resolve\r\n             * @return {?}\r\n             */\r\n            resolve => {\r\n                clearTimeout(this._previousTimeout);\r\n                this._previousTimeout = setTimeout((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    this._liveElement.textContent = message;\r\n                    resolve();\r\n                    if (typeof duration === 'number') {\r\n                        this._previousTimeout = setTimeout((/**\r\n                         * @return {?}\r\n                         */\r\n                        () => this.clear()), duration);\r\n                    }\r\n                }), 100);\r\n            }));\r\n        }));\r\n    }\r\n    /**\r\n     * Clears the current text from the announcer element. Can be used to prevent\r\n     * screen readers from reading the text out again while the user is going\r\n     * through the page landmarks.\r\n     * @return {?}\r\n     */\r\n    clear() {\r\n        if (this._liveElement) {\r\n            this._liveElement.textContent = '';\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        clearTimeout(this._previousTimeout);\r\n        if (this._liveElement && this._liveElement.parentNode) {\r\n            this._liveElement.parentNode.removeChild(this._liveElement);\r\n            this._liveElement = (/** @type {?} */ (null));\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createLiveElement() {\r\n        /** @type {?} */\r\n        const elementClass = 'cdk-live-announcer-element';\r\n        /** @type {?} */\r\n        const previousElements = this._document.getElementsByClassName(elementClass);\r\n        /** @type {?} */\r\n        const liveEl = this._document.createElement('div');\r\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\r\n        for (let i = 0; i < previousElements.length; i++) {\r\n            (/** @type {?} */ (previousElements[i].parentNode)).removeChild(previousElements[i]);\r\n        }\r\n        liveEl.classList.add(elementClass);\r\n        liveEl.classList.add('cdk-visually-hidden');\r\n        liveEl.setAttribute('aria-atomic', 'true');\r\n        liveEl.setAttribute('aria-live', 'polite');\r\n        this._document.body.appendChild(liveEl);\r\n        return liveEl;\r\n    }\r\n}\r\nLiveAnnouncer.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nLiveAnnouncer.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS,] }] }\r\n];\r\n/** @nocollapse */ LiveAnnouncer.ngInjectableDef = ÉµÉµdefineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(ÉµÉµinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ÉµÉµinject(NgZone), ÉµÉµinject(DOCUMENT), ÉµÉµinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\r\n/**\r\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\r\n * with a wider range of browsers and screen readers.\r\n */\r\nclass CdkAriaLive {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _liveAnnouncer\r\n     * @param {?} _contentObserver\r\n     * @param {?} _ngZone\r\n     */\r\n    constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\r\n        this._elementRef = _elementRef;\r\n        this._liveAnnouncer = _liveAnnouncer;\r\n        this._contentObserver = _contentObserver;\r\n        this._ngZone = _ngZone;\r\n        this._politeness = 'off';\r\n    }\r\n    /**\r\n     * The aria-live politeness level to use when announcing messages.\r\n     * @return {?}\r\n     */\r\n    get politeness() { return this._politeness; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set politeness(value) {\r\n        this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\r\n        if (this._politeness === 'off') {\r\n            if (this._subscription) {\r\n                this._subscription.unsubscribe();\r\n                this._subscription = null;\r\n            }\r\n        }\r\n        else if (!this._subscription) {\r\n            this._subscription = this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                return this._contentObserver\r\n                    .observe(this._elementRef)\r\n                    .subscribe((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\r\n                    /** @type {?} */\r\n                    const elementText = this._elementRef.nativeElement.textContent;\r\n                    // The `MutationObserver` fires also for attribute\r\n                    // changes which we don't want to announce.\r\n                    if (elementText !== this._previousAnnouncedText) {\r\n                        this._liveAnnouncer.announce(elementText, this._politeness);\r\n                        this._previousAnnouncedText = elementText;\r\n                    }\r\n                }));\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._subscription) {\r\n            this._subscription.unsubscribe();\r\n        }\r\n    }\r\n}\r\nCdkAriaLive.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkAriaLive]',\r\n                exportAs: 'cdkAriaLive',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkAriaLive.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: LiveAnnouncer },\r\n    { type: ContentObserver },\r\n    { type: NgZone }\r\n];\r\nCdkAriaLive.propDecorators = {\r\n    politeness: [{ type: Input, args: ['cdkAriaLive',] }]\r\n};\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentAnnouncer\r\n * @param {?} liveElement\r\n * @param {?} _document\r\n * @param {?} ngZone\r\n * @return {?}\r\n */\r\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentAnnouncer, liveElement, _document, ngZone) {\r\n    return parentAnnouncer || new LiveAnnouncer(liveElement, ngZone, _document);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nconst LIVE_ANNOUNCER_PROVIDER = {\r\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\r\n    provide: LiveAnnouncer,\r\n    deps: [\r\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\r\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\r\n        DOCUMENT,\r\n        NgZone,\r\n    ],\r\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n// that a value of around 650ms seems appropriate.\r\n/** @type {?} */\r\nconst TOUCH_BUFFER_MS = 650;\r\n/**\r\n * Event listener options that enable capturing and also\r\n * mark the listener as passive if the browser supports it.\r\n * @type {?}\r\n */\r\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\r\n    passive: true,\r\n    capture: true\r\n});\r\n/**\r\n * Monitors mouse and keyboard events to determine the cause of focus events.\r\n */\r\nclass FocusMonitor {\r\n    /**\r\n     * @param {?} _ngZone\r\n     * @param {?} _platform\r\n     */\r\n    constructor(_ngZone, _platform) {\r\n        this._ngZone = _ngZone;\r\n        this._platform = _platform;\r\n        /**\r\n         * The focus origin that the next focus event is a result of.\r\n         */\r\n        this._origin = null;\r\n        /**\r\n         * Whether the window has just been focused.\r\n         */\r\n        this._windowFocused = false;\r\n        /**\r\n         * Map of elements being monitored to their info.\r\n         */\r\n        this._elementInfo = new Map();\r\n        /**\r\n         * The number of elements currently being monitored.\r\n         */\r\n        this._monitoredElementCount = 0;\r\n        /**\r\n         * Event listener for `keydown` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentKeydownListener = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // On keydown record the origin and clear any touch event that may be in progress.\r\n            this._lastTouchTarget = null;\r\n            this._setOriginForCurrentEventQueue('keyboard');\r\n        });\r\n        /**\r\n         * Event listener for `mousedown` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentMousedownListener = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // On mousedown record the origin only if there is not touch\r\n            // target, since a mousedown can happen as a result of a touch event.\r\n            if (!this._lastTouchTarget) {\r\n                this._setOriginForCurrentEventQueue('mouse');\r\n            }\r\n        });\r\n        /**\r\n         * Event listener for `touchstart` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentTouchstartListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        (event) => {\r\n            // When the touchstart event fires the focus event is not yet in the event queue. This means\r\n            // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\r\n            // see if a focus happens.\r\n            if (this._touchTimeoutId != null) {\r\n                clearTimeout(this._touchTimeoutId);\r\n            }\r\n            // Since this listener is bound on the `document` level, any events coming from the shadow DOM\r\n            // will have their `target` set to the shadow root. If available, use `composedPath` to\r\n            // figure out the event target.\r\n            this._lastTouchTarget = event.composedPath ? event.composedPath()[0] : event.target;\r\n            this._touchTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            () => this._lastTouchTarget = null), TOUCH_BUFFER_MS);\r\n        });\r\n        /**\r\n         * Event listener for `focus` events on the window.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._windowFocusListener = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // Make a note of when the window regains focus, so we can\r\n            // restore the origin info for the focused element.\r\n            this._windowFocused = true;\r\n            this._windowFocusTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            () => this._windowFocused = false));\r\n        });\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?=} checkChildren\r\n     * @return {?}\r\n     */\r\n    monitor(element, checkChildren = false) {\r\n        // Do nothing if we're not on the browser platform.\r\n        if (!this._platform.isBrowser) {\r\n            return of(null);\r\n        }\r\n        /** @type {?} */\r\n        const nativeElement = coerceElement(element);\r\n        // Check if we're already monitoring this element.\r\n        if (this._elementInfo.has(nativeElement)) {\r\n            /** @type {?} */\r\n            let cachedInfo = this._elementInfo.get(nativeElement);\r\n            (/** @type {?} */ (cachedInfo)).checkChildren = checkChildren;\r\n            return (/** @type {?} */ (cachedInfo)).subject.asObservable();\r\n        }\r\n        // Create monitored element info.\r\n        /** @type {?} */\r\n        let info = {\r\n            unlisten: (/**\r\n             * @return {?}\r\n             */\r\n            () => { }),\r\n            checkChildren: checkChildren,\r\n            subject: new Subject()\r\n        };\r\n        this._elementInfo.set(nativeElement, info);\r\n        this._incrementMonitoredElementCount();\r\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\r\n        /** @type {?} */\r\n        let focusListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        (event) => this._onFocus(event, nativeElement));\r\n        /** @type {?} */\r\n        let blurListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        (event) => this._onBlur(event, nativeElement));\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            nativeElement.addEventListener('focus', focusListener, true);\r\n            nativeElement.addEventListener('blur', blurListener, true);\r\n        }));\r\n        // Create an unlisten function for later.\r\n        info.unlisten = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            nativeElement.removeEventListener('focus', focusListener, true);\r\n            nativeElement.removeEventListener('blur', blurListener, true);\r\n        });\r\n        return info.subject.asObservable();\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    stopMonitoring(element) {\r\n        /** @type {?} */\r\n        const nativeElement = coerceElement(element);\r\n        /** @type {?} */\r\n        const elementInfo = this._elementInfo.get(nativeElement);\r\n        if (elementInfo) {\r\n            elementInfo.unlisten();\r\n            elementInfo.subject.complete();\r\n            this._setClasses(nativeElement);\r\n            this._elementInfo.delete(nativeElement);\r\n            this._decrementMonitoredElementCount();\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} origin\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    focusVia(element, origin, options) {\r\n        /** @type {?} */\r\n        const nativeElement = coerceElement(element);\r\n        this._setOriginForCurrentEventQueue(origin);\r\n        // `focus` isn't available on the server\r\n        if (typeof nativeElement.focus === 'function') {\r\n            // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\r\n            ((/** @type {?} */ (nativeElement))).focus(options);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._elementInfo.forEach((/**\r\n         * @param {?} _info\r\n         * @param {?} element\r\n         * @return {?}\r\n         */\r\n        (_info, element) => this.stopMonitoring(element)));\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} className\r\n     * @param {?} shouldSet\r\n     * @return {?}\r\n     */\r\n    _toggleClass(element, className, shouldSet) {\r\n        if (shouldSet) {\r\n            element.classList.add(className);\r\n        }\r\n        else {\r\n            element.classList.remove(className);\r\n        }\r\n    }\r\n    /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @private\r\n     * @param {?} element The element to update the classes on.\r\n     * @param {?=} origin The focus origin.\r\n     * @return {?}\r\n     */\r\n    _setClasses(element, origin) {\r\n        /** @type {?} */\r\n        const elementInfo = this._elementInfo.get(element);\r\n        if (elementInfo) {\r\n            this._toggleClass(element, 'cdk-focused', !!origin);\r\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\r\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\r\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\r\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\r\n        }\r\n    }\r\n    /**\r\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\n     * @private\r\n     * @param {?} origin The origin to set.\r\n     * @return {?}\r\n     */\r\n    _setOriginForCurrentEventQueue(origin) {\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._origin = origin;\r\n            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\r\n            // tick after the interaction event fired. To ensure the focus origin is always correct,\r\n            // the focus origin will be determined at the beginning of the next tick.\r\n            this._originTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            () => this._origin = null), 1);\r\n        }));\r\n    }\r\n    /**\r\n     * Checks whether the given focus event was caused by a touchstart event.\r\n     * @private\r\n     * @param {?} event The focus event to check.\r\n     * @return {?} Whether the event was caused by a touch.\r\n     */\r\n    _wasCausedByTouch(event) {\r\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\r\n        // Consider the following dom structure:\r\n        //\r\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\r\n        //   <div #child (click)=\"#parent.focus()\"></div>\r\n        // </div>\r\n        //\r\n        // If the user touches the #child element and the #parent is programmatically focused as a\r\n        // result, this code will still consider it to have been caused by the touch event and will\r\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\r\n        // relatively small edge-case that can be worked around by using\r\n        // focusVia(parentEl, 'program') to focus the parent element.\r\n        //\r\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\r\n        // for the first focus event after the touchstart, and then the first blur event after that\r\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\r\n        // touchstart.\r\n        /** @type {?} */\r\n        let focusTarget = event.target;\r\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\r\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\r\n    }\r\n    /**\r\n     * Handles focus events on a registered element.\r\n     * @private\r\n     * @param {?} event The focus event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    _onFocus(event, element) {\r\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n        // focus event affecting the monitored element. If we want to use the origin of the first event\r\n        // instead we should check for the cdk-focused class here and return if the element already has\r\n        // it. (This only matters for elements that have includesChildren = true).\r\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n        // focus event affecting the monitored element. If we want to use the origin of the first event\r\n        // instead we should check for the cdk-focused class here and return if the element already has\r\n        // it. (This only matters for elements that have includesChildren = true).\r\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\r\n        // monitored element itself.\r\n        /** @type {?} */\r\n        const elementInfo = this._elementInfo.get(element);\r\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\r\n            return;\r\n        }\r\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\r\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\r\n        //    the element from before the window blurred.\r\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\r\n        // 3) The element was programmatically focused, in which case we should mark the origin as\r\n        //    'program'.\r\n        /** @type {?} */\r\n        let origin = this._origin;\r\n        if (!origin) {\r\n            if (this._windowFocused && this._lastFocusOrigin) {\r\n                origin = this._lastFocusOrigin;\r\n            }\r\n            else if (this._wasCausedByTouch(event)) {\r\n                origin = 'touch';\r\n            }\r\n            else {\r\n                origin = 'program';\r\n            }\r\n        }\r\n        this._setClasses(element, origin);\r\n        this._emitOrigin(elementInfo.subject, origin);\r\n        this._lastFocusOrigin = origin;\r\n    }\r\n    /**\r\n     * Handles blur events on a registered element.\r\n     * @param {?} event The blur event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    _onBlur(event, element) {\r\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\r\n        // order to focus another child of the monitored element.\r\n        /** @type {?} */\r\n        const elementInfo = this._elementInfo.get(element);\r\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\r\n            element.contains(event.relatedTarget))) {\r\n            return;\r\n        }\r\n        this._setClasses(element);\r\n        this._emitOrigin(elementInfo.subject, null);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} subject\r\n     * @param {?} origin\r\n     * @return {?}\r\n     */\r\n    _emitOrigin(subject, origin) {\r\n        this._ngZone.run((/**\r\n         * @return {?}\r\n         */\r\n        () => subject.next(origin)));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _incrementMonitoredElementCount() {\r\n        // Register global listeners when first element is monitored.\r\n        if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {\r\n            // Note: we listen to events in the capture phase so we\r\n            // can detect them even if the user stops propagation.\r\n            this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                document.addEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\r\n                document.addEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\r\n                document.addEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\r\n                window.addEventListener('focus', this._windowFocusListener);\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _decrementMonitoredElementCount() {\r\n        // Unregister global listeners when last element is unmonitored.\r\n        if (!--this._monitoredElementCount) {\r\n            document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\r\n            document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\r\n            document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\r\n            window.removeEventListener('focus', this._windowFocusListener);\r\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\r\n            clearTimeout(this._windowFocusTimeoutId);\r\n            clearTimeout(this._touchTimeoutId);\r\n            clearTimeout(this._originTimeoutId);\r\n        }\r\n    }\r\n}\r\nFocusMonitor.decorators = [\r\n    { type: Injectable, args: [{ providedIn: 'root' },] },\r\n];\r\n/** @nocollapse */\r\nFocusMonitor.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Platform }\r\n];\r\n/** @nocollapse */ FocusMonitor.ngInjectableDef = ÉµÉµdefineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(ÉµÉµinject(NgZone), ÉµÉµinject(Platform)); }, token: FocusMonitor, providedIn: \"root\" });\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\r\nclass CdkMonitorFocus {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _focusMonitor\r\n     */\r\n    constructor(_elementRef, _focusMonitor) {\r\n        this._elementRef = _elementRef;\r\n        this._focusMonitor = _focusMonitor;\r\n        this.cdkFocusChange = new EventEmitter();\r\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\r\n            .subscribe((/**\r\n         * @param {?} origin\r\n         * @return {?}\r\n         */\r\n        origin => this.cdkFocusChange.emit(origin)));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n        this._monitorSubscription.unsubscribe();\r\n    }\r\n}\r\nCdkMonitorFocus.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nCdkMonitorFocus.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: FocusMonitor }\r\n];\r\nCdkMonitorFocus.propDecorators = {\r\n    cdkFocusChange: [{ type: Output }]\r\n};\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentDispatcher\r\n * @param {?} ngZone\r\n * @param {?} platform\r\n * @return {?}\r\n */\r\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\r\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nconst FOCUS_MONITOR_PROVIDER = {\r\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\r\n    provide: FocusMonitor,\r\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\r\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Screenreaders will often fire fake mousedown events when a focusable element\r\n * is activated using the keyboard. We can typically distinguish between these faked\r\n * mousedown events and real mousedown events using the \"buttons\" property. While\r\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\r\n * the left mouse button), faked mousedowns will usually set the property value to 0.\r\n * @param {?} event\r\n * @return {?}\r\n */\r\nfunction isFakeMousedownFromScreenReader(event) {\r\n    return event.buttons === 0;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass A11yModule {\r\n}\r\nA11yModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [CommonModule, PlatformModule, ObserversModule],\r\n                declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\r\n                exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { ARIA_DESCRIBER_PROVIDER_FACTORY, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, CdkTrapFocus, InteractivityChecker, LIVE_ANNOUNCER_PROVIDER_FACTORY, LiveAnnouncer, CdkAriaLive, LIVE_ANNOUNCER_PROVIDER, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_DEFAULT_OPTIONS, FOCUS_MONITOR_PROVIDER_FACTORY, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\r\n\r\n"]}