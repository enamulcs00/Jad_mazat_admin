{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm5/testing.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAoBA","file":"testing.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Creates a browser MouseEvent with the specified options.\r\n * \\@docs-private\r\n * @param {?} type\r\n * @param {?=} x\r\n * @param {?=} y\r\n * @param {?=} button\r\n * @return {?}\r\n */\r\nfunction createMouseEvent(type, x, y, button) {\r\n    if (x === void 0) { x = 0; }\r\n    if (y === void 0) { y = 0; }\r\n    if (button === void 0) { button = 0; }\r\n    /** @type {?} */\r\n    var event = document.createEvent('MouseEvent');\r\n    /** @type {?} */\r\n    var originalPreventDefault = event.preventDefault;\r\n    event.initMouseEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* detail */ x, /* screenX */ y, /* screenY */ x, /* clientX */ y, /* clientY */ false, /* ctrlKey */ false, /* altKey */ false, /* shiftKey */ false, /* metaKey */ button, /* button */ null /* relatedTarget */);\r\n    // `initMouseEvent` doesn't allow us to pass the `buttons` and\r\n    // defaults it to 0 which looks like a fake event.\r\n    Object.defineProperty(event, 'buttons', { get: (/**\r\n         * @return {?}\r\n         */\r\n        function () { return 1; }) });\r\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\r\n    event.preventDefault = (/**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return true; }) });\r\n        return originalPreventDefault.apply(this, arguments);\r\n    });\r\n    return event;\r\n}\r\n/**\r\n * Creates a browser TouchEvent with the specified pointer coordinates.\r\n * \\@docs-private\r\n * @param {?} type\r\n * @param {?=} pageX\r\n * @param {?=} pageY\r\n * @return {?}\r\n */\r\nfunction createTouchEvent(type, pageX, pageY) {\r\n    if (pageX === void 0) { pageX = 0; }\r\n    if (pageY === void 0) { pageY = 0; }\r\n    // In favor of creating events that work for most of the browsers, the event is created\r\n    // as a basic UI Event. The necessary details for the event will be set manually.\r\n    /** @type {?} */\r\n    var event = document.createEvent('UIEvent');\r\n    /** @type {?} */\r\n    var touchDetails = { pageX: pageX, pageY: pageY };\r\n    // TS3.6 removes the initUIEvent method and suggests porting to \"new UIEvent()\".\r\n    ((/** @type {?} */ (event))).initUIEvent(type, true, true, window, 0);\r\n    // Most of the browsers don't have a \"initTouchEvent\" method that can be used to define\r\n    // the touch details.\r\n    Object.defineProperties(event, {\r\n        touches: { value: [touchDetails] },\r\n        targetTouches: { value: [touchDetails] },\r\n        changedTouches: { value: [touchDetails] }\r\n    });\r\n    return event;\r\n}\r\n/**\r\n * Dispatches a keydown event from an element.\r\n * \\@docs-private\r\n * @param {?} type\r\n * @param {?=} keyCode\r\n * @param {?=} key\r\n * @param {?=} target\r\n * @param {?=} modifiers\r\n * @return {?}\r\n */\r\nfunction createKeyboardEvent(type, keyCode, key, target, modifiers) {\r\n    if (keyCode === void 0) { keyCode = 0; }\r\n    if (key === void 0) { key = ''; }\r\n    if (modifiers === void 0) { modifiers = {}; }\r\n    /** @type {?} */\r\n    var event = (/** @type {?} */ (document.createEvent('KeyboardEvent')));\r\n    /** @type {?} */\r\n    var originalPreventDefault = event.preventDefault;\r\n    // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.\r\n    if (event.initKeyEvent) {\r\n        event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);\r\n    }\r\n    else {\r\n        // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string\r\n        // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent\r\n        /** @type {?} */\r\n        var modifiersStr = (modifiers.control ? 'Control ' : '' + modifiers.alt ? 'Alt ' : '' +\r\n            modifiers.shift ? 'Shift ' : '' + modifiers.meta ? 'Meta' : '').trim();\r\n        event.initKeyboardEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* char */ key, /* key */ 0, /* location */ modifiersStr, /* modifiersList */ false /* repeat */);\r\n    }\r\n    // Webkit Browsers don't set the keyCode when calling the init function.\r\n    // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735\r\n    Object.defineProperties(event, {\r\n        keyCode: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return keyCode; }) },\r\n        key: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return key; }) },\r\n        target: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return target; }) },\r\n        ctrlKey: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return !!modifiers.control; }) },\r\n        altKey: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return !!modifiers.alt; }) },\r\n        shiftKey: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return !!modifiers.shift; }) },\r\n        metaKey: { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return !!modifiers.meta; }) }\r\n    });\r\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\r\n    event.preventDefault = (/**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\r\n             * @return {?}\r\n             */\r\n            function () { return true; }) });\r\n        return originalPreventDefault.apply(this, arguments);\r\n    });\r\n    return event;\r\n}\r\n/**\r\n * Creates a fake event object with any desired event type.\r\n * \\@docs-private\r\n * @param {?} type\r\n * @param {?=} canBubble\r\n * @param {?=} cancelable\r\n * @return {?}\r\n */\r\nfunction createFakeEvent(type, canBubble, cancelable) {\r\n    if (canBubble === void 0) { canBubble = false; }\r\n    if (cancelable === void 0) { cancelable = true; }\r\n    /** @type {?} */\r\n    var event = document.createEvent('Event');\r\n    event.initEvent(type, canBubble, cancelable);\r\n    return event;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Utility to dispatch any event on a Node.\r\n * \\@docs-private\r\n * @param {?} node\r\n * @param {?} event\r\n * @return {?}\r\n */\r\nfunction dispatchEvent(node, event) {\r\n    node.dispatchEvent(event);\r\n    return event;\r\n}\r\n/**\r\n * Shorthand to dispatch a fake event on a specified node.\r\n * \\@docs-private\r\n * @param {?} node\r\n * @param {?} type\r\n * @param {?=} canBubble\r\n * @return {?}\r\n */\r\nfunction dispatchFakeEvent(node, type, canBubble) {\r\n    return dispatchEvent(node, createFakeEvent(type, canBubble));\r\n}\r\n/**\r\n * Shorthand to dispatch a keyboard event with a specified key code.\r\n * \\@docs-private\r\n * @param {?} node\r\n * @param {?} type\r\n * @param {?=} keyCode\r\n * @param {?=} key\r\n * @param {?=} target\r\n * @param {?=} modifiers\r\n * @return {?}\r\n */\r\nfunction dispatchKeyboardEvent(node, type, keyCode, key, target, modifiers) {\r\n    return (/** @type {?} */ (dispatchEvent(node, createKeyboardEvent(type, keyCode, key, target, modifiers))));\r\n}\r\n/**\r\n * Shorthand to dispatch a mouse event on the specified coordinates.\r\n * \\@docs-private\r\n * @param {?} node\r\n * @param {?} type\r\n * @param {?=} x\r\n * @param {?=} y\r\n * @param {?=} event\r\n * @return {?}\r\n */\r\nfunction dispatchMouseEvent(node, type, x, y, event) {\r\n    if (x === void 0) { x = 0; }\r\n    if (y === void 0) { y = 0; }\r\n    if (event === void 0) { event = createMouseEvent(type, x, y); }\r\n    return (/** @type {?} */ (dispatchEvent(node, event)));\r\n}\r\n/**\r\n * Shorthand to dispatch a touch event on the specified coordinates.\r\n * \\@docs-private\r\n * @param {?} node\r\n * @param {?} type\r\n * @param {?=} x\r\n * @param {?=} y\r\n * @return {?}\r\n */\r\nfunction dispatchTouchEvent(node, type, x, y) {\r\n    if (x === void 0) { x = 0; }\r\n    if (y === void 0) { y = 0; }\r\n    return dispatchEvent(node, createTouchEvent(type, x, y));\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @param {?} element\r\n * @param {?} event\r\n * @return {?}\r\n */\r\nfunction triggerFocusChange(element, event) {\r\n    /** @type {?} */\r\n    var eventFired = false;\r\n    /** @type {?} */\r\n    var handler = (/**\r\n     * @return {?}\r\n     */\r\n    function () { return eventFired = true; });\r\n    element.addEventListener(event, handler);\r\n    element[event]();\r\n    element.removeEventListener(event, handler);\r\n    if (!eventFired) {\r\n        dispatchFakeEvent(element, event);\r\n    }\r\n}\r\n/**\r\n * Patches an elements focus and blur methods to emit events consistently and predictably.\r\n * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,\r\n * while others won't fire them at all if the browser window is not focused.\r\n * \\@docs-private\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction patchElementFocus(element) {\r\n    element.focus = (/**\r\n     * @return {?}\r\n     */\r\n    function () { return dispatchFakeEvent(element, 'focus'); });\r\n    element.blur = (/**\r\n     * @return {?}\r\n     */\r\n    function () { return dispatchFakeEvent(element, 'blur'); });\r\n}\r\n/**\r\n * \\@docs-private\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction triggerFocus(element) {\r\n    triggerFocusChange(element, 'focus');\r\n}\r\n/**\r\n * \\@docs-private\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction triggerBlur(element) {\r\n    triggerFocusChange(element, 'blur');\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Checks whether the given Element is a text input element.\r\n * \\@docs-private\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isTextInput(element) {\r\n    return element.nodeName.toLowerCase() === 'input' ||\r\n        element.nodeName.toLowerCase() === 'textarea';\r\n}\r\n/**\r\n * @param {?} element\r\n * @param {...?} modifiersAndKeys\r\n * @return {?}\r\n */\r\nfunction typeInElement(element) {\r\n    var modifiersAndKeys = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        modifiersAndKeys[_i - 1] = arguments[_i];\r\n    }\r\n    /** @type {?} */\r\n    var first = modifiersAndKeys[0];\r\n    /** @type {?} */\r\n    var modifiers;\r\n    /** @type {?} */\r\n    var rest;\r\n    if (typeof first !== 'string' && first.keyCode === undefined && first.key === undefined) {\r\n        modifiers = first;\r\n        rest = modifiersAndKeys.slice(1);\r\n    }\r\n    else {\r\n        modifiers = {};\r\n        rest = modifiersAndKeys;\r\n    }\r\n    /** @type {?} */\r\n    var keys = rest\r\n        .map((/**\r\n     * @param {?} k\r\n     * @return {?}\r\n     */\r\n    function (k) { return typeof k === 'string' ?\r\n        k.split('').map((/**\r\n         * @param {?} c\r\n         * @return {?}\r\n         */\r\n        function (c) { return ({ keyCode: c.toUpperCase().charCodeAt(0), key: c }); })) : [k]; }))\r\n        .reduce((/**\r\n     * @param {?} arr\r\n     * @param {?} k\r\n     * @return {?}\r\n     */\r\n    function (arr, k) { return arr.concat(k); }), []);\r\n    triggerFocus(element);\r\n    for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {\r\n        var key = keys_1[_a];\r\n        dispatchKeyboardEvent(element, 'keydown', key.keyCode, key.key, element, modifiers);\r\n        dispatchKeyboardEvent(element, 'keypress', key.keyCode, key.key, element, modifiers);\r\n        if (isTextInput(element) && key.key && key.key.length === 1) {\r\n            element.value += key.key;\r\n            dispatchFakeEvent(element, 'input');\r\n        }\r\n        dispatchKeyboardEvent(element, 'keyup', key.keyCode, key.key, element, modifiers);\r\n    }\r\n}\r\n/**\r\n * Clears the text in an input or textarea element.\r\n * \\@docs-private\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction clearElement(element) {\r\n    triggerFocus((/** @type {?} */ (element)));\r\n    element.value = '';\r\n    dispatchFakeEvent(element, 'input');\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { dispatchEvent, dispatchFakeEvent, dispatchKeyboardEvent, dispatchMouseEvent, dispatchTouchEvent, createMouseEvent, createTouchEvent, createKeyboardEvent, createFakeEvent, isTextInput, typeInElement, clearElement, patchElementFocus, triggerFocus, triggerBlur };\r\n\r\n"]}