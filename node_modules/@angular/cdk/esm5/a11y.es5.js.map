{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm5/a11y.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0cM,AAGA;;;;;;;;;;;;;6YAK+M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAi4B/M,AAGA;;;;;;;;;;yIAK2O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2pB3O,AAGA;;;;;;;;;;;;;;;gFAO6Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyF7Q,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;uFAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0KA,AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;+JAQyT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwEzT,AAMA;;;;;;;;;;;;;;;;;;;;;+CAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0hBA,AAGA;;;;;;;;;;;0lBAM6N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAkC7N,AAKA;;;;;;;;;;;;;;;;;yDAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgDD;;;;;;;;;;;;;;;gMAOC","file":"a11y.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { Inject, Injectable, Optional, SkipSelf, QueryList, Directive, ElementRef, Input, NgZone, isDevMode, InjectionToken, EventEmitter, Output, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { Subject, Subscription, of } from 'rxjs';\r\nimport { UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, TAB, A, Z, ZERO, NINE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { debounceTime, filter, map, tap, take } from 'rxjs/operators';\r\nimport { __extends } from 'tslib';\r\nimport { Platform, normalizePassiveListenerOptions, PlatformModule } from '@angular/cdk/platform';\r\nimport { coerceBooleanProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { ContentObserver, ObserversModule } from '@angular/cdk/observers';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * IDs are deliminated by an empty space, as per the spec.\r\n * @type {?}\r\n */\r\nvar ID_DELIMINATOR = ' ';\r\n/**\r\n * Adds the given ID to the specified ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @param {?} id\r\n * @return {?}\r\n */\r\nfunction addAriaReferencedId(el, attr, id) {\r\n    /** @type {?} */\r\n    var ids = getAriaReferenceIds(el, attr);\r\n    if (ids.some((/**\r\n     * @param {?} existingId\r\n     * @return {?}\r\n     */\r\n    function (existingId) { return existingId.trim() == id.trim(); }))) {\r\n        return;\r\n    }\r\n    ids.push(id.trim());\r\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\r\n}\r\n/**\r\n * Removes the given ID from the specified ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @param {?} id\r\n * @return {?}\r\n */\r\nfunction removeAriaReferencedId(el, attr, id) {\r\n    /** @type {?} */\r\n    var ids = getAriaReferenceIds(el, attr);\r\n    /** @type {?} */\r\n    var filteredIds = ids.filter((/**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\r\n    function (val) { return val != id.trim(); }));\r\n    if (filteredIds.length) {\r\n        el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\r\n    }\r\n    else {\r\n        el.removeAttribute(attr);\r\n    }\r\n}\r\n/**\r\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\r\n * Used for attributes such as aria-labelledby, aria-owns, etc.\r\n * @param {?} el\r\n * @param {?} attr\r\n * @return {?}\r\n */\r\nfunction getAriaReferenceIds(el, attr) {\r\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\r\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * ID used for the body container where all messages are appended.\r\n * @type {?}\r\n */\r\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\r\n/**\r\n * ID prefix used for each created message element.\r\n * @type {?}\r\n */\r\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\r\n/**\r\n * Attribute given to each host element that is described by a message element.\r\n * @type {?}\r\n */\r\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\r\n/**\r\n * Global incremental identifier for each registered message element.\r\n * @type {?}\r\n */\r\nvar nextId = 0;\r\n/**\r\n * Global map of all registered message elements that have been placed into the document.\r\n * @type {?}\r\n */\r\nvar messageRegistry = new Map();\r\n/**\r\n * Container for all registered messages.\r\n * @type {?}\r\n */\r\nvar messagesContainer = null;\r\n/**\r\n * Utility that creates visually hidden elements with a message content. Useful for elements that\r\n * want to use aria-describedby to further describe themselves without adding additional visual\r\n * content.\r\n */\r\nvar AriaDescriber = /** @class */ (function () {\r\n    function AriaDescriber(_document) {\r\n        this._document = _document;\r\n    }\r\n    /**\r\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\r\n     * the message. If the same message has already been registered, then it will reuse the created\r\n     * message element.\r\n     */\r\n    /**\r\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\r\n     * the message. If the same message has already been registered, then it will reuse the created\r\n     * message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype.describe = /**\r\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\r\n     * the message. If the same message has already been registered, then it will reuse the created\r\n     * message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (hostElement, message) {\r\n        if (!this._canBeDescribed(hostElement, message)) {\r\n            return;\r\n        }\r\n        if (typeof message !== 'string') {\r\n            // We need to ensure that the element has an ID.\r\n            this._setMessageId(message);\r\n            messageRegistry.set(message, { messageElement: message, referenceCount: 0 });\r\n        }\r\n        else if (!messageRegistry.has(message)) {\r\n            this._createMessageElement(message);\r\n        }\r\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\r\n            this._addMessageReference(hostElement, message);\r\n        }\r\n    };\r\n    /** Removes the host element's aria-describedby reference to the message element. */\r\n    /**\r\n     * Removes the host element's aria-describedby reference to the message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype.removeDescription = /**\r\n     * Removes the host element's aria-describedby reference to the message element.\r\n     * @param {?} hostElement\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (hostElement, message) {\r\n        if (!this._isElementNode(hostElement)) {\r\n            return;\r\n        }\r\n        if (this._isElementDescribedByMessage(hostElement, message)) {\r\n            this._removeMessageReference(hostElement, message);\r\n        }\r\n        // If the message is a string, it means that it's one that we created for the\r\n        // consumer so we can remove it safely, otherwise we should leave it in place.\r\n        if (typeof message === 'string') {\r\n            /** @type {?} */\r\n            var registeredMessage = messageRegistry.get(message);\r\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\r\n                this._deleteMessageElement(message);\r\n            }\r\n        }\r\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\r\n            this._deleteMessagesContainer();\r\n        }\r\n    };\r\n    /** Unregisters all created message elements and removes the message container. */\r\n    /**\r\n     * Unregisters all created message elements and removes the message container.\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype.ngOnDestroy = /**\r\n     * Unregisters all created message elements and removes the message container.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\r\n        for (var i = 0; i < describedElements.length; i++) {\r\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\r\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n        }\r\n        if (messagesContainer) {\r\n            this._deleteMessagesContainer();\r\n        }\r\n        messageRegistry.clear();\r\n    };\r\n    /**\r\n     * Creates a new element in the visually hidden message container element with the message\r\n     * as its content and adds it to the message registry.\r\n     */\r\n    /**\r\n     * Creates a new element in the visually hidden message container element with the message\r\n     * as its content and adds it to the message registry.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._createMessageElement = /**\r\n     * Creates a new element in the visually hidden message container element with the message\r\n     * as its content and adds it to the message registry.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (message) {\r\n        /** @type {?} */\r\n        var messageElement = this._document.createElement('div');\r\n        this._setMessageId(messageElement);\r\n        messageElement.textContent = message;\r\n        this._createMessagesContainer();\r\n        (/** @type {?} */ (messagesContainer)).appendChild(messageElement);\r\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\r\n    };\r\n    /** Assigns a unique ID to an element, if it doesn't have one already. */\r\n    /**\r\n     * Assigns a unique ID to an element, if it doesn't have one already.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._setMessageId = /**\r\n     * Assigns a unique ID to an element, if it doesn't have one already.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        if (!element.id) {\r\n            element.id = CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++;\r\n        }\r\n    };\r\n    /** Deletes the message element from the global messages container. */\r\n    /**\r\n     * Deletes the message element from the global messages container.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._deleteMessageElement = /**\r\n     * Deletes the message element from the global messages container.\r\n     * @private\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (message) {\r\n        /** @type {?} */\r\n        var registeredMessage = messageRegistry.get(message);\r\n        /** @type {?} */\r\n        var messageElement = registeredMessage && registeredMessage.messageElement;\r\n        if (messagesContainer && messageElement) {\r\n            messagesContainer.removeChild(messageElement);\r\n        }\r\n        messageRegistry.delete(message);\r\n    };\r\n    /** Creates the global container for all aria-describedby messages. */\r\n    /**\r\n     * Creates the global container for all aria-describedby messages.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._createMessagesContainer = /**\r\n     * Creates the global container for all aria-describedby messages.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!messagesContainer) {\r\n            /** @type {?} */\r\n            var preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\r\n            // When going from the server to the client, we may end up in a situation where there's\r\n            // already a container on the page, but we don't have a reference to it. Clear the\r\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\r\n            // container, should be slightly faster.\r\n            if (preExistingContainer) {\r\n                (/** @type {?} */ (preExistingContainer.parentNode)).removeChild(preExistingContainer);\r\n            }\r\n            messagesContainer = this._document.createElement('div');\r\n            messagesContainer.id = MESSAGES_CONTAINER_ID;\r\n            messagesContainer.setAttribute('aria-hidden', 'true');\r\n            messagesContainer.style.display = 'none';\r\n            this._document.body.appendChild(messagesContainer);\r\n        }\r\n    };\r\n    /** Deletes the global messages container. */\r\n    /**\r\n     * Deletes the global messages container.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._deleteMessagesContainer = /**\r\n     * Deletes the global messages container.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (messagesContainer && messagesContainer.parentNode) {\r\n            messagesContainer.parentNode.removeChild(messagesContainer);\r\n            messagesContainer = null;\r\n        }\r\n    };\r\n    /** Removes all cdk-describedby messages that are hosted through the element. */\r\n    /**\r\n     * Removes all cdk-describedby messages that are hosted through the element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\r\n     * Removes all cdk-describedby messages that are hosted through the element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\r\n        /** @type {?} */\r\n        var originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\r\n            .filter((/**\r\n         * @param {?} id\r\n         * @return {?}\r\n         */\r\n        function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; }));\r\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\r\n    };\r\n    /**\r\n     * Adds a message reference to the element using aria-describedby and increments the registered\r\n     * message's reference count.\r\n     */\r\n    /**\r\n     * Adds a message reference to the element using aria-describedby and increments the registered\r\n     * message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._addMessageReference = /**\r\n     * Adds a message reference to the element using aria-describedby and increments the registered\r\n     * message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (element, message) {\r\n        /** @type {?} */\r\n        var registeredMessage = (/** @type {?} */ (messageRegistry.get(message)));\r\n        // Add the aria-describedby reference and set the\r\n        // describedby_host attribute to mark the element.\r\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\r\n        registeredMessage.referenceCount++;\r\n    };\r\n    /**\r\n     * Removes a message reference from the element using aria-describedby\r\n     * and decrements the registered message's reference count.\r\n     */\r\n    /**\r\n     * Removes a message reference from the element using aria-describedby\r\n     * and decrements the registered message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._removeMessageReference = /**\r\n     * Removes a message reference from the element using aria-describedby\r\n     * and decrements the registered message's reference count.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (element, message) {\r\n        /** @type {?} */\r\n        var registeredMessage = (/** @type {?} */ (messageRegistry.get(message)));\r\n        registeredMessage.referenceCount--;\r\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n    };\r\n    /** Returns true if the element has been described by the provided message ID. */\r\n    /**\r\n     * Returns true if the element has been described by the provided message ID.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\r\n     * Returns true if the element has been described by the provided message ID.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (element, message) {\r\n        /** @type {?} */\r\n        var referenceIds = getAriaReferenceIds(element, 'aria-describedby');\r\n        /** @type {?} */\r\n        var registeredMessage = messageRegistry.get(message);\r\n        /** @type {?} */\r\n        var messageId = registeredMessage && registeredMessage.messageElement.id;\r\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\r\n    };\r\n    /** Determines whether a message can be described on a particular element. */\r\n    /**\r\n     * Determines whether a message can be described on a particular element.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._canBeDescribed = /**\r\n     * Determines whether a message can be described on a particular element.\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} message\r\n     * @return {?}\r\n     */\r\n    function (element, message) {\r\n        if (!this._isElementNode(element)) {\r\n            return false;\r\n        }\r\n        if (message && typeof message === 'object') {\r\n            // We'd have to make some assumptions about the description element's text, if the consumer\r\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\r\n            // that it can be used as a description.\r\n            return true;\r\n        }\r\n        /** @type {?} */\r\n        var trimmedMessage = message == null ? '' : (\"\" + message).trim();\r\n        /** @type {?} */\r\n        var ariaLabel = element.getAttribute('aria-label');\r\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\r\n        // element, because screen readers will end up reading out the same text twice in a row.\r\n        return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\r\n    };\r\n    /** Checks whether a node is an Element node. */\r\n    /**\r\n     * Checks whether a node is an Element node.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    AriaDescriber.prototype._isElementNode = /**\r\n     * Checks whether a node is an Element node.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        return element.nodeType === this._document.ELEMENT_NODE;\r\n    };\r\n    AriaDescriber.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    AriaDescriber.ctorParameters = function () { return [\r\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n    ]; };\r\n    /** @nocollapse */ AriaDescriber.ngInjectableDef = ɵɵdefineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(ɵɵinject(DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\r\n    return AriaDescriber;\r\n}());\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentDispatcher\r\n * @param {?} _document\r\n * @return {?}\r\n */\r\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\r\n    return parentDispatcher || new AriaDescriber(_document);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nvar ARIA_DESCRIBER_PROVIDER = {\r\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\r\n    provide: AriaDescriber,\r\n    deps: [\r\n        [new Optional(), new SkipSelf(), AriaDescriber],\r\n        (/** @type {?} */ (DOCUMENT))\r\n    ],\r\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * This class manages keyboard events for selectable lists. If you pass it a query list\r\n * of items, it will set the active item correctly when arrow events occur.\r\n * @template T\r\n */\r\nvar  /**\r\n * This class manages keyboard events for selectable lists. If you pass it a query list\r\n * of items, it will set the active item correctly when arrow events occur.\r\n * @template T\r\n */\r\nListKeyManager = /** @class */ (function () {\r\n    function ListKeyManager(_items) {\r\n        var _this = this;\r\n        this._items = _items;\r\n        this._activeItemIndex = -1;\r\n        this._activeItem = null;\r\n        this._wrap = false;\r\n        this._letterKeyStream = new Subject();\r\n        this._typeaheadSubscription = Subscription.EMPTY;\r\n        this._vertical = true;\r\n        this._allowedModifierKeys = [];\r\n        /**\r\n         * Predicate function that can be used to check whether an item should be skipped\r\n         * by the key manager. By default, disabled items are skipped.\r\n         */\r\n        this._skipPredicateFn = (/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        function (item) { return item.disabled; });\r\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\r\n        this._pressedLetters = [];\r\n        /**\r\n         * Stream that emits any time the TAB key is pressed, so components can react\r\n         * when focus is shifted off of the list.\r\n         */\r\n        this.tabOut = new Subject();\r\n        /**\r\n         * Stream that emits whenever the active item of the list manager changes.\r\n         */\r\n        this.change = new Subject();\r\n        // We allow for the items to be an array because, in some cases, the consumer may\r\n        // not have access to a QueryList of the items they want to manage (e.g. when the\r\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\r\n        if (_items instanceof QueryList) {\r\n            _items.changes.subscribe((/**\r\n             * @param {?} newItems\r\n             * @return {?}\r\n             */\r\n            function (newItems) {\r\n                if (_this._activeItem) {\r\n                    /** @type {?} */\r\n                    var itemArray = newItems.toArray();\r\n                    /** @type {?} */\r\n                    var newIndex = itemArray.indexOf(_this._activeItem);\r\n                    if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\r\n                        _this._activeItemIndex = newIndex;\r\n                    }\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Sets the predicate function that determines which items should be skipped by the\r\n     * list key manager.\r\n     * @param predicate Function that determines whether the given item should be skipped.\r\n     */\r\n    /**\r\n     * Sets the predicate function that determines which items should be skipped by the\r\n     * list key manager.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} predicate Function that determines whether the given item should be skipped.\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.skipPredicate = /**\r\n     * Sets the predicate function that determines which items should be skipped by the\r\n     * list key manager.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} predicate Function that determines whether the given item should be skipped.\r\n     * @return {THIS}\r\n     */\r\n    function (predicate) {\r\n        (/** @type {?} */ (this))._skipPredicateFn = predicate;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * Configures wrapping mode, which determines whether the active item will wrap to\r\n     * the other end of list when there are no more items in the given direction.\r\n     * @param shouldWrap Whether the list should wrap when reaching the end.\r\n     */\r\n    /**\r\n     * Configures wrapping mode, which determines whether the active item will wrap to\r\n     * the other end of list when there are no more items in the given direction.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.withWrap = /**\r\n     * Configures wrapping mode, which determines whether the active item will wrap to\r\n     * the other end of list when there are no more items in the given direction.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.\r\n     * @return {THIS}\r\n     */\r\n    function (shouldWrap) {\r\n        if (shouldWrap === void 0) { shouldWrap = true; }\r\n        (/** @type {?} */ (this))._wrap = shouldWrap;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * Configures whether the key manager should be able to move the selection vertically.\r\n     * @param enabled Whether vertical selection should be enabled.\r\n     */\r\n    /**\r\n     * Configures whether the key manager should be able to move the selection vertically.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} enabled Whether vertical selection should be enabled.\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.withVerticalOrientation = /**\r\n     * Configures whether the key manager should be able to move the selection vertically.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} enabled Whether vertical selection should be enabled.\r\n     * @return {THIS}\r\n     */\r\n    function (enabled) {\r\n        if (enabled === void 0) { enabled = true; }\r\n        (/** @type {?} */ (this))._vertical = enabled;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * Configures the key manager to move the selection horizontally.\r\n     * Passing in `null` will disable horizontal movement.\r\n     * @param direction Direction in which the selection can be moved.\r\n     */\r\n    /**\r\n     * Configures the key manager to move the selection horizontally.\r\n     * Passing in `null` will disable horizontal movement.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} direction Direction in which the selection can be moved.\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.withHorizontalOrientation = /**\r\n     * Configures the key manager to move the selection horizontally.\r\n     * Passing in `null` will disable horizontal movement.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} direction Direction in which the selection can be moved.\r\n     * @return {THIS}\r\n     */\r\n    function (direction) {\r\n        (/** @type {?} */ (this))._horizontal = direction;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\r\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\r\n     */\r\n    /**\r\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\r\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} keys\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.withAllowedModifierKeys = /**\r\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\r\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} keys\r\n     * @return {THIS}\r\n     */\r\n    function (keys) {\r\n        (/** @type {?} */ (this))._allowedModifierKeys = keys;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * Turns on typeahead mode which allows users to set the active item by typing.\r\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\r\n     */\r\n    /**\r\n     * Turns on typeahead mode which allows users to set the active item by typing.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\r\n     * @return {THIS}\r\n     */\r\n    ListKeyManager.prototype.withTypeAhead = /**\r\n     * Turns on typeahead mode which allows users to set the active item by typing.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\r\n     * @return {THIS}\r\n     */\r\n    function (debounceInterval) {\r\n        var _this = this;\r\n        if (debounceInterval === void 0) { debounceInterval = 200; }\r\n        if ((/** @type {?} */ (this))._items.length && (/** @type {?} */ (this))._items.some((/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        function (item) { return typeof item.getLabel !== 'function'; }))) {\r\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\r\n        }\r\n        (/** @type {?} */ (this))._typeaheadSubscription.unsubscribe();\r\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\r\n        // and convert those letters back into a string. Afterwards find the first item that starts\r\n        // with that string and select it.\r\n        (/** @type {?} */ (this))._typeaheadSubscription = (/** @type {?} */ (this))._letterKeyStream.pipe(tap((/**\r\n         * @param {?} keyCode\r\n         * @return {?}\r\n         */\r\n        function (keyCode) { return (/** @type {?} */ (_this))._pressedLetters.push(keyCode); })), debounceTime(debounceInterval), filter((/**\r\n         * @return {?}\r\n         */\r\n        function () { return (/** @type {?} */ (_this))._pressedLetters.length > 0; })), map((/**\r\n         * @return {?}\r\n         */\r\n        function () { return (/** @type {?} */ (_this))._pressedLetters.join(''); }))).subscribe((/**\r\n         * @param {?} inputString\r\n         * @return {?}\r\n         */\r\n        function (inputString) {\r\n            /** @type {?} */\r\n            var items = (/** @type {?} */ (_this))._getItemsArray();\r\n            // Start at 1 because we want to start searching at the item immediately\r\n            // following the current active item.\r\n            for (var i = 1; i < items.length + 1; i++) {\r\n                /** @type {?} */\r\n                var index = ((/** @type {?} */ (_this))._activeItemIndex + i) % items.length;\r\n                /** @type {?} */\r\n                var item = items[index];\r\n                if (!(/** @type {?} */ (_this))._skipPredicateFn(item) &&\r\n                    (/** @type {?} */ (item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\r\n                    (/** @type {?} */ (_this)).setActiveItem(index);\r\n                    break;\r\n                }\r\n            }\r\n            (/** @type {?} */ (_this))._pressedLetters = [];\r\n        }));\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.setActiveItem = /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    function (item) {\r\n        /** @type {?} */\r\n        var previousIndex = this._activeItemIndex;\r\n        this.updateActiveItem(item);\r\n        if (this._activeItemIndex !== previousIndex) {\r\n            this.change.next(this._activeItemIndex);\r\n        }\r\n    };\r\n    /**\r\n     * Sets the active item depending on the key event passed in.\r\n     * @param event Keyboard event to be used for determining which element should be active.\r\n     */\r\n    /**\r\n     * Sets the active item depending on the key event passed in.\r\n     * @param {?} event Keyboard event to be used for determining which element should be active.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.onKeydown = /**\r\n     * Sets the active item depending on the key event passed in.\r\n     * @param {?} event Keyboard event to be used for determining which element should be active.\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        var _this = this;\r\n        /** @type {?} */\r\n        var keyCode = event.keyCode;\r\n        /** @type {?} */\r\n        var modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\r\n        /** @type {?} */\r\n        var isModifierAllowed = modifiers.every((/**\r\n         * @param {?} modifier\r\n         * @return {?}\r\n         */\r\n        function (modifier) {\r\n            return !event[modifier] || _this._allowedModifierKeys.indexOf(modifier) > -1;\r\n        }));\r\n        switch (keyCode) {\r\n            case TAB:\r\n                this.tabOut.next();\r\n                return;\r\n            case DOWN_ARROW:\r\n                if (this._vertical && isModifierAllowed) {\r\n                    this.setNextItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case UP_ARROW:\r\n                if (this._vertical && isModifierAllowed) {\r\n                    this.setPreviousItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case RIGHT_ARROW:\r\n                if (this._horizontal && isModifierAllowed) {\r\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            case LEFT_ARROW:\r\n                if (this._horizontal && isModifierAllowed) {\r\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\r\n                    break;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            default:\r\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\r\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\r\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\r\n                    if (event.key && event.key.length === 1) {\r\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\r\n                    }\r\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\r\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\r\n                    }\r\n                }\r\n                // Note that we return here, in order to avoid preventing\r\n                // the default action of non-navigational keys.\r\n                return;\r\n        }\r\n        this._pressedLetters = [];\r\n        event.preventDefault();\r\n    };\r\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\r\n        /** Index of the currently active item. */\r\n        get: /**\r\n         * Index of the currently active item.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._activeItemIndex;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\r\n        /** The active item. */\r\n        get: /**\r\n         * The active item.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._activeItem;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Sets the active item to the first enabled item in the list. */\r\n    /**\r\n     * Sets the active item to the first enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.setFirstItemActive = /**\r\n     * Sets the active item to the first enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._setActiveItemByIndex(0, 1);\r\n    };\r\n    /** Sets the active item to the last enabled item in the list. */\r\n    /**\r\n     * Sets the active item to the last enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.setLastItemActive = /**\r\n     * Sets the active item to the last enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._setActiveItemByIndex(this._items.length - 1, -1);\r\n    };\r\n    /** Sets the active item to the next enabled item in the list. */\r\n    /**\r\n     * Sets the active item to the next enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.setNextItemActive = /**\r\n     * Sets the active item to the next enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\r\n    };\r\n    /** Sets the active item to a previous enabled item in the list. */\r\n    /**\r\n     * Sets the active item to a previous enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.setPreviousItemActive = /**\r\n     * Sets the active item to a previous enabled item in the list.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\r\n            : this._setActiveItemByDelta(-1);\r\n    };\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.updateActiveItem = /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    function (item) {\r\n        /** @type {?} */\r\n        var itemArray = this._getItemsArray();\r\n        /** @type {?} */\r\n        var index = typeof item === 'number' ? item : itemArray.indexOf(item);\r\n        /** @type {?} */\r\n        var activeItem = itemArray[index];\r\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\r\n        this._activeItem = activeItem == null ? null : activeItem;\r\n        this._activeItemIndex = index;\r\n    };\r\n    /**\r\n     * Allows setting of the activeItemIndex without any other effects.\r\n     * @param index The new activeItemIndex.\r\n     * @deprecated Use `updateActiveItem` instead.\r\n     * @breaking-change 8.0.0\r\n     */\r\n    /**\r\n     * Allows setting of the activeItemIndex without any other effects.\r\n     * @deprecated Use `updateActiveItem` instead.\r\n     * \\@breaking-change 8.0.0\r\n     * @param {?} index The new activeItemIndex.\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype.updateActiveItemIndex = /**\r\n     * Allows setting of the activeItemIndex without any other effects.\r\n     * @deprecated Use `updateActiveItem` instead.\r\n     * \\@breaking-change 8.0.0\r\n     * @param {?} index The new activeItemIndex.\r\n     * @return {?}\r\n     */\r\n    function (index) {\r\n        this.updateActiveItem(index);\r\n    };\r\n    /**\r\n     * This method sets the active item, given a list of items and the delta between the\r\n     * currently active item and the new active item. It will calculate differently\r\n     * depending on whether wrap mode is turned on.\r\n     */\r\n    /**\r\n     * This method sets the active item, given a list of items and the delta between the\r\n     * currently active item and the new active item. It will calculate differently\r\n     * depending on whether wrap mode is turned on.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype._setActiveItemByDelta = /**\r\n     * This method sets the active item, given a list of items and the delta between the\r\n     * currently active item and the new active item. It will calculate differently\r\n     * depending on whether wrap mode is turned on.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    function (delta) {\r\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\r\n    };\r\n    /**\r\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\r\n     * down the list until it finds an item that is not disabled, and it will wrap if it\r\n     * encounters either end of the list.\r\n     */\r\n    /**\r\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\r\n     * down the list until it finds an item that is not disabled, and it will wrap if it\r\n     * encounters either end of the list.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype._setActiveInWrapMode = /**\r\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\r\n     * down the list until it finds an item that is not disabled, and it will wrap if it\r\n     * encounters either end of the list.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    function (delta) {\r\n        /** @type {?} */\r\n        var items = this._getItemsArray();\r\n        for (var i = 1; i <= items.length; i++) {\r\n            /** @type {?} */\r\n            var index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\r\n            /** @type {?} */\r\n            var item = items[index];\r\n            if (!this._skipPredicateFn(item)) {\r\n                this.setActiveItem(index);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets the active item properly given the default mode. In other words, it will\r\n     * continue to move down the list until it finds an item that is not disabled. If\r\n     * it encounters either end of the list, it will stop and not wrap.\r\n     */\r\n    /**\r\n     * Sets the active item properly given the default mode. In other words, it will\r\n     * continue to move down the list until it finds an item that is not disabled. If\r\n     * it encounters either end of the list, it will stop and not wrap.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\r\n     * Sets the active item properly given the default mode. In other words, it will\r\n     * continue to move down the list until it finds an item that is not disabled. If\r\n     * it encounters either end of the list, it will stop and not wrap.\r\n     * @private\r\n     * @param {?} delta\r\n     * @return {?}\r\n     */\r\n    function (delta) {\r\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\r\n    };\r\n    /**\r\n     * Sets the active item to the first enabled item starting at the index specified. If the\r\n     * item is disabled, it will move in the fallbackDelta direction until it either\r\n     * finds an enabled item or encounters the end of the list.\r\n     */\r\n    /**\r\n     * Sets the active item to the first enabled item starting at the index specified. If the\r\n     * item is disabled, it will move in the fallbackDelta direction until it either\r\n     * finds an enabled item or encounters the end of the list.\r\n     * @private\r\n     * @param {?} index\r\n     * @param {?} fallbackDelta\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype._setActiveItemByIndex = /**\r\n     * Sets the active item to the first enabled item starting at the index specified. If the\r\n     * item is disabled, it will move in the fallbackDelta direction until it either\r\n     * finds an enabled item or encounters the end of the list.\r\n     * @private\r\n     * @param {?} index\r\n     * @param {?} fallbackDelta\r\n     * @return {?}\r\n     */\r\n    function (index, fallbackDelta) {\r\n        /** @type {?} */\r\n        var items = this._getItemsArray();\r\n        if (!items[index]) {\r\n            return;\r\n        }\r\n        while (this._skipPredicateFn(items[index])) {\r\n            index += fallbackDelta;\r\n            if (!items[index]) {\r\n                return;\r\n            }\r\n        }\r\n        this.setActiveItem(index);\r\n    };\r\n    /** Returns the items as an array. */\r\n    /**\r\n     * Returns the items as an array.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    ListKeyManager.prototype._getItemsArray = /**\r\n     * Returns the items as an array.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\r\n    };\r\n    return ListKeyManager;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n */\r\nvar  /**\r\n * @template T\r\n */\r\nActiveDescendantKeyManager = /** @class */ (function (_super) {\r\n    __extends(ActiveDescendantKeyManager, _super);\r\n    function ActiveDescendantKeyManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    function (index) {\r\n        if (this.activeItem) {\r\n            this.activeItem.setInactiveStyles();\r\n        }\r\n        _super.prototype.setActiveItem.call(this, index);\r\n        if (this.activeItem) {\r\n            this.activeItem.setActiveStyles();\r\n        }\r\n    };\r\n    return ActiveDescendantKeyManager;\r\n}(ListKeyManager));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n */\r\nvar  /**\r\n * @template T\r\n */\r\nFocusKeyManager = /** @class */ (function (_super) {\r\n    __extends(FocusKeyManager, _super);\r\n    function FocusKeyManager() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._origin = 'program';\r\n        return _this;\r\n    }\r\n    /**\r\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\r\n     * @param origin Focus origin to be used when focusing items.\r\n     */\r\n    /**\r\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} origin Focus origin to be used when focusing items.\r\n     * @return {THIS}\r\n     */\r\n    FocusKeyManager.prototype.setFocusOrigin = /**\r\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\r\n     * @template THIS\r\n     * @this {THIS}\r\n     * @param {?} origin Focus origin to be used when focusing items.\r\n     * @return {THIS}\r\n     */\r\n    function (origin) {\r\n        (/** @type {?} */ (this))._origin = origin;\r\n        return (/** @type {?} */ (this));\r\n    };\r\n    /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    FocusKeyManager.prototype.setActiveItem = /**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    function (item) {\r\n        _super.prototype.setActiveItem.call(this, item);\r\n        if (this.activeItem) {\r\n            this.activeItem.focus(this._origin);\r\n        }\r\n    };\r\n    return FocusKeyManager;\r\n}(ListKeyManager));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\r\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\r\n// supported.\r\n/**\r\n * Utility for checking the interactivity of an element, such as whether is is focusable or\r\n * tabbable.\r\n */\r\nvar InteractivityChecker = /** @class */ (function () {\r\n    function InteractivityChecker(_platform) {\r\n        this._platform = _platform;\r\n    }\r\n    /**\r\n     * Gets whether an element is disabled.\r\n     *\r\n     * @param element Element to be checked.\r\n     * @returns Whether the element is disabled.\r\n     */\r\n    /**\r\n     * Gets whether an element is disabled.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is disabled.\r\n     */\r\n    InteractivityChecker.prototype.isDisabled = /**\r\n     * Gets whether an element is disabled.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is disabled.\r\n     */\r\n    function (element) {\r\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\r\n        // a form control inside of a disabled form, but should capture the most common cases.\r\n        return element.hasAttribute('disabled');\r\n    };\r\n    /**\r\n     * Gets whether an element is visible for the purposes of interactivity.\r\n     *\r\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\r\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\r\n     *\r\n     * @returns Whether the element is visible.\r\n     */\r\n    /**\r\n     * Gets whether an element is visible for the purposes of interactivity.\r\n     *\r\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\r\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\r\n     *\r\n     * @param {?} element\r\n     * @return {?} Whether the element is visible.\r\n     */\r\n    InteractivityChecker.prototype.isVisible = /**\r\n     * Gets whether an element is visible for the purposes of interactivity.\r\n     *\r\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\r\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\r\n     *\r\n     * @param {?} element\r\n     * @return {?} Whether the element is visible.\r\n     */\r\n    function (element) {\r\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\r\n    };\r\n    /**\r\n     * Gets whether an element can be reached via Tab key.\r\n     * Assumes that the element has already been checked with isFocusable.\r\n     *\r\n     * @param element Element to be checked.\r\n     * @returns Whether the element is tabbable.\r\n     */\r\n    /**\r\n     * Gets whether an element can be reached via Tab key.\r\n     * Assumes that the element has already been checked with isFocusable.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is tabbable.\r\n     */\r\n    InteractivityChecker.prototype.isTabbable = /**\r\n     * Gets whether an element can be reached via Tab key.\r\n     * Assumes that the element has already been checked with isFocusable.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is tabbable.\r\n     */\r\n    function (element) {\r\n        // Nothing is tabbable on the server 😎\r\n        if (!this._platform.isBrowser) {\r\n            return false;\r\n        }\r\n        /** @type {?} */\r\n        var frameElement = getFrameElement(getWindow(element));\r\n        if (frameElement) {\r\n            /** @type {?} */\r\n            var frameType = frameElement && frameElement.nodeName.toLowerCase();\r\n            // Frame elements inherit their tabindex onto all child elements.\r\n            if (getTabIndexValue(frameElement) === -1) {\r\n                return false;\r\n            }\r\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\r\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\r\n                return false;\r\n            }\r\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\r\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\r\n                return false;\r\n            }\r\n        }\r\n        /** @type {?} */\r\n        var nodeName = element.nodeName.toLowerCase();\r\n        /** @type {?} */\r\n        var tabIndexValue = getTabIndexValue(element);\r\n        if (element.hasAttribute('contenteditable')) {\r\n            return tabIndexValue !== -1;\r\n        }\r\n        if (nodeName === 'iframe') {\r\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\r\n            // investigate the content of the frames.\r\n            return false;\r\n        }\r\n        if (nodeName === 'audio') {\r\n            if (!element.hasAttribute('controls')) {\r\n                // By default an <audio> element without the controls enabled is not tabbable.\r\n                return false;\r\n            }\r\n            else if (this._platform.BLINK) {\r\n                // In Blink <audio controls> elements are always tabbable.\r\n                return true;\r\n            }\r\n        }\r\n        if (nodeName === 'video') {\r\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\r\n                // In Trident a <video> element without the controls enabled is not tabbable.\r\n                return false;\r\n            }\r\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\r\n                // In Chrome and Firefox <video controls> elements are always tabbable.\r\n                return true;\r\n            }\r\n        }\r\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\r\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\r\n            return false;\r\n        }\r\n        // In iOS the browser only considers some specific elements as tabbable.\r\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\r\n            return false;\r\n        }\r\n        return element.tabIndex >= 0;\r\n    };\r\n    /**\r\n     * Gets whether an element can be focused by the user.\r\n     *\r\n     * @param element Element to be checked.\r\n     * @returns Whether the element is focusable.\r\n     */\r\n    /**\r\n     * Gets whether an element can be focused by the user.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is focusable.\r\n     */\r\n    InteractivityChecker.prototype.isFocusable = /**\r\n     * Gets whether an element can be focused by the user.\r\n     *\r\n     * @param {?} element Element to be checked.\r\n     * @return {?} Whether the element is focusable.\r\n     */\r\n    function (element) {\r\n        // Perform checks in order of left to most expensive.\r\n        // Again, naive approach that does not capture many edge cases and browser quirks.\r\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\r\n    };\r\n    InteractivityChecker.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    InteractivityChecker.ctorParameters = function () { return [\r\n        { type: Platform }\r\n    ]; };\r\n    /** @nocollapse */ InteractivityChecker.ngInjectableDef = ɵɵdefineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(ɵɵinject(Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\r\n    return InteractivityChecker;\r\n}());\r\n/**\r\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\r\n * the frameElement property is being accessed from a different host address, this property\r\n * should be accessed carefully.\r\n * @param {?} window\r\n * @return {?}\r\n */\r\nfunction getFrameElement(window) {\r\n    try {\r\n        return (/** @type {?} */ (window.frameElement));\r\n    }\r\n    catch (_a) {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Checks whether the specified element has any geometry / rectangles.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction hasGeometry(element) {\r\n    // Use logic from jQuery to check for an invisible element.\r\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\r\n    return !!(element.offsetWidth || element.offsetHeight ||\r\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\r\n}\r\n/**\r\n * Gets whether an element's\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isNativeFormElement(element) {\r\n    /** @type {?} */\r\n    var nodeName = element.nodeName.toLowerCase();\r\n    return nodeName === 'input' ||\r\n        nodeName === 'select' ||\r\n        nodeName === 'button' ||\r\n        nodeName === 'textarea';\r\n}\r\n/**\r\n * Gets whether an element is an `<input type=\"hidden\">`.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isHiddenInput(element) {\r\n    return isInputElement(element) && element.type == 'hidden';\r\n}\r\n/**\r\n * Gets whether an element is an anchor that has an href attribute.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isAnchorWithHref(element) {\r\n    return isAnchorElement(element) && element.hasAttribute('href');\r\n}\r\n/**\r\n * Gets whether an element is an input element.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isInputElement(element) {\r\n    return element.nodeName.toLowerCase() == 'input';\r\n}\r\n/**\r\n * Gets whether an element is an anchor element.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isAnchorElement(element) {\r\n    return element.nodeName.toLowerCase() == 'a';\r\n}\r\n/**\r\n * Gets whether an element has a valid tabindex.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction hasValidTabIndex(element) {\r\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\r\n        return false;\r\n    }\r\n    /** @type {?} */\r\n    var tabIndex = element.getAttribute('tabindex');\r\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\r\n    if (tabIndex == '-32768') {\r\n        return false;\r\n    }\r\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\r\n}\r\n/**\r\n * Returns the parsed tabindex from the element attributes instead of returning the\r\n * evaluated tabindex from the browsers defaults.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction getTabIndexValue(element) {\r\n    if (!hasValidTabIndex(element)) {\r\n        return null;\r\n    }\r\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\r\n    /** @type {?} */\r\n    var tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\r\n    return isNaN(tabIndex) ? -1 : tabIndex;\r\n}\r\n/**\r\n * Checks whether the specified element is potentially tabbable on iOS\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isPotentiallyTabbableIOS(element) {\r\n    /** @type {?} */\r\n    var nodeName = element.nodeName.toLowerCase();\r\n    /** @type {?} */\r\n    var inputType = nodeName === 'input' && ((/** @type {?} */ (element))).type;\r\n    return inputType === 'text'\r\n        || inputType === 'password'\r\n        || nodeName === 'select'\r\n        || nodeName === 'textarea';\r\n}\r\n/**\r\n * Gets whether an element is potentially focusable without taking current visible/disabled state\r\n * into account.\r\n * @param {?} element\r\n * @return {?}\r\n */\r\nfunction isPotentiallyFocusable(element) {\r\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\r\n    if (isHiddenInput(element)) {\r\n        return false;\r\n    }\r\n    return isNativeFormElement(element) ||\r\n        isAnchorWithHref(element) ||\r\n        element.hasAttribute('contenteditable') ||\r\n        hasValidTabIndex(element);\r\n}\r\n/**\r\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\r\n * @param {?} node\r\n * @return {?}\r\n */\r\nfunction getWindow(node) {\r\n    // ownerDocument is null if `node` itself *is* a document.\r\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Class that allows for trapping focus within a DOM element.\r\n *\r\n * This class currently uses a relatively simple approach to focus trapping.\r\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\r\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\r\n */\r\nvar  /**\r\n * Class that allows for trapping focus within a DOM element.\r\n *\r\n * This class currently uses a relatively simple approach to focus trapping.\r\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\r\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\r\n */\r\nFocusTrap = /** @class */ (function () {\r\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\r\n        var _this = this;\r\n        if (deferAnchors === void 0) { deferAnchors = false; }\r\n        this._element = _element;\r\n        this._checker = _checker;\r\n        this._ngZone = _ngZone;\r\n        this._document = _document;\r\n        this._hasAttached = false;\r\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\r\n        this.startAnchorListener = (/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this.focusLastTabbableElement(); });\r\n        this.endAnchorListener = (/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this.focusFirstTabbableElement(); });\r\n        this._enabled = true;\r\n        if (!deferAnchors) {\r\n            this.attachAnchors();\r\n        }\r\n    }\r\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\r\n        /** Whether the focus trap is active. */\r\n        get: /**\r\n         * Whether the focus trap is active.\r\n         * @return {?}\r\n         */\r\n        function () { return this._enabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._enabled = value;\r\n            if (this._startAnchor && this._endAnchor) {\r\n                this._toggleAnchorTabIndex(value, this._startAnchor);\r\n                this._toggleAnchorTabIndex(value, this._endAnchor);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Destroys the focus trap by cleaning up the anchors. */\r\n    /**\r\n     * Destroys the focus trap by cleaning up the anchors.\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype.destroy = /**\r\n     * Destroys the focus trap by cleaning up the anchors.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var startAnchor = this._startAnchor;\r\n        /** @type {?} */\r\n        var endAnchor = this._endAnchor;\r\n        if (startAnchor) {\r\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\r\n            if (startAnchor.parentNode) {\r\n                startAnchor.parentNode.removeChild(startAnchor);\r\n            }\r\n        }\r\n        if (endAnchor) {\r\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\r\n            if (endAnchor.parentNode) {\r\n                endAnchor.parentNode.removeChild(endAnchor);\r\n            }\r\n        }\r\n        this._startAnchor = this._endAnchor = null;\r\n    };\r\n    /**\r\n     * Inserts the anchors into the DOM. This is usually done automatically\r\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\r\n     * @returns Whether the focus trap managed to attach successfuly. This may not be the case\r\n     * if the target element isn't currently in the DOM.\r\n     */\r\n    /**\r\n     * Inserts the anchors into the DOM. This is usually done automatically\r\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\r\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\r\n     * if the target element isn't currently in the DOM.\r\n     */\r\n    FocusTrap.prototype.attachAnchors = /**\r\n     * Inserts the anchors into the DOM. This is usually done automatically\r\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\r\n     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case\r\n     * if the target element isn't currently in the DOM.\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // If we're not on the browser, there can be no focus to trap.\r\n        if (this._hasAttached) {\r\n            return true;\r\n        }\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (!_this._startAnchor) {\r\n                _this._startAnchor = _this._createAnchor();\r\n                (/** @type {?} */ (_this._startAnchor)).addEventListener('focus', _this.startAnchorListener);\r\n            }\r\n            if (!_this._endAnchor) {\r\n                _this._endAnchor = _this._createAnchor();\r\n                (/** @type {?} */ (_this._endAnchor)).addEventListener('focus', _this.endAnchorListener);\r\n            }\r\n        }));\r\n        if (this._element.parentNode) {\r\n            this._element.parentNode.insertBefore((/** @type {?} */ (this._startAnchor)), this._element);\r\n            this._element.parentNode.insertBefore((/** @type {?} */ (this._endAnchor)), this._element.nextSibling);\r\n            this._hasAttached = true;\r\n        }\r\n        return this._hasAttached;\r\n    };\r\n    /**\r\n     * Waits for the zone to stabilize, then either focuses the first element that the\r\n     * user specified, or the first tabbable element.\r\n     * @returns Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Waits for the zone to stabilize, then either focuses the first element that the\r\n     * user specified, or the first tabbable element.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\r\n     * Waits for the zone to stabilize, then either focuses the first element that the\r\n     * user specified, or the first tabbable element.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        function (resolve) {\r\n            _this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            function () { return resolve(_this.focusInitialElement()); }));\r\n        }));\r\n    };\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the first tabbable element within the focus trap region.\r\n     * @returns Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the first tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the first tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        function (resolve) {\r\n            _this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            function () { return resolve(_this.focusFirstTabbableElement()); }));\r\n        }));\r\n    };\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the last tabbable element within the focus trap region.\r\n     * @returns Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the last tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\r\n     * Waits for the zone to stabilize, then focuses\r\n     * the last tabbable element within the focus trap region.\r\n     * @return {?} Returns a promise that resolves with a boolean, depending\r\n     * on whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        function (resolve) {\r\n            _this._executeOnStable((/**\r\n             * @return {?}\r\n             */\r\n            function () { return resolve(_this.focusLastTabbableElement()); }));\r\n        }));\r\n    };\r\n    /**\r\n     * Get the specified boundary element of the trapped region.\r\n     * @param bound The boundary to get (start or end of trapped region).\r\n     * @returns The boundary element.\r\n     */\r\n    /**\r\n     * Get the specified boundary element of the trapped region.\r\n     * @private\r\n     * @param {?} bound The boundary to get (start or end of trapped region).\r\n     * @return {?} The boundary element.\r\n     */\r\n    FocusTrap.prototype._getRegionBoundary = /**\r\n     * Get the specified boundary element of the trapped region.\r\n     * @private\r\n     * @param {?} bound The boundary to get (start or end of trapped region).\r\n     * @return {?} The boundary element.\r\n     */\r\n    function (bound) {\r\n        // Contains the deprecated version of selector, for temporary backwards comparability.\r\n        /** @type {?} */\r\n        var markers = (/** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\r\n            (\"[cdkFocusRegion\" + bound + \"], \") +\r\n            (\"[cdk-focus-\" + bound + \"]\"))));\r\n        for (var i = 0; i < markers.length; i++) {\r\n            // @breaking-change 8.0.0\r\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\r\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"', \" +\r\n                    (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated \") +\r\n                    \"attribute will be removed in 8.0.0.\", markers[i]);\r\n            }\r\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\r\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"', \" +\r\n                    (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated attribute \") +\r\n                    \"will be removed in 8.0.0.\", markers[i]);\r\n            }\r\n        }\r\n        if (bound == 'start') {\r\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\r\n        }\r\n        return markers.length ?\r\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\r\n    };\r\n    /**\r\n     * Focuses the element that should be focused when the focus trap is initialized.\r\n     * @returns Whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Focuses the element that should be focused when the focus trap is initialized.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusInitialElement = /**\r\n     * Focuses the element that should be focused when the focus trap is initialized.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        // Contains the deprecated version of selector, for temporary backwards comparability.\r\n        /** @type {?} */\r\n        var redirectToElement = (/** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\r\n            \"[cdkFocusInitial]\")));\r\n        if (redirectToElement) {\r\n            // @breaking-change 8.0.0\r\n            if (redirectToElement.hasAttribute(\"cdk-focus-initial\")) {\r\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', \" +\r\n                    \"use 'cdkFocusInitial' instead. The deprecated attribute \" +\r\n                    \"will be removed in 8.0.0\", redirectToElement);\r\n            }\r\n            // Warn the consumer if the element they've pointed to\r\n            // isn't focusable, when not in production mode.\r\n            if (isDevMode() && !this._checker.isFocusable(redirectToElement)) {\r\n                console.warn(\"Element matching '[cdkFocusInitial]' is not focusable.\", redirectToElement);\r\n            }\r\n            redirectToElement.focus();\r\n            return true;\r\n        }\r\n        return this.focusFirstTabbableElement();\r\n    };\r\n    /**\r\n     * Focuses the first tabbable element within the focus trap region.\r\n     * @returns Whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Focuses the first tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusFirstTabbableElement = /**\r\n     * Focuses the first tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var redirectToElement = this._getRegionBoundary('start');\r\n        if (redirectToElement) {\r\n            redirectToElement.focus();\r\n        }\r\n        return !!redirectToElement;\r\n    };\r\n    /**\r\n     * Focuses the last tabbable element within the focus trap region.\r\n     * @returns Whether focus was moved successfuly.\r\n     */\r\n    /**\r\n     * Focuses the last tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    FocusTrap.prototype.focusLastTabbableElement = /**\r\n     * Focuses the last tabbable element within the focus trap region.\r\n     * @return {?} Whether focus was moved successfuly.\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var redirectToElement = this._getRegionBoundary('end');\r\n        if (redirectToElement) {\r\n            redirectToElement.focus();\r\n        }\r\n        return !!redirectToElement;\r\n    };\r\n    /**\r\n     * Checks whether the focus trap has successfuly been attached.\r\n     */\r\n    /**\r\n     * Checks whether the focus trap has successfuly been attached.\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype.hasAttached = /**\r\n     * Checks whether the focus trap has successfuly been attached.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._hasAttached;\r\n    };\r\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\r\n    /**\r\n     * Get the first tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype._getFirstTabbableElement = /**\r\n     * Get the first tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    function (root) {\r\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n            return root;\r\n        }\r\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\r\n        // back to `childNodes` which includes text nodes, comments etc.\r\n        /** @type {?} */\r\n        var children = root.children || root.childNodes;\r\n        for (var i = 0; i < children.length; i++) {\r\n            /** @type {?} */\r\n            var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\r\n                this._getFirstTabbableElement((/** @type {?} */ (children[i]))) :\r\n                null;\r\n            if (tabbableChild) {\r\n                return tabbableChild;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\r\n    /**\r\n     * Get the last tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype._getLastTabbableElement = /**\r\n     * Get the last tabbable element from a DOM subtree (inclusive).\r\n     * @private\r\n     * @param {?} root\r\n     * @return {?}\r\n     */\r\n    function (root) {\r\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n            return root;\r\n        }\r\n        // Iterate in reverse DOM order.\r\n        /** @type {?} */\r\n        var children = root.children || root.childNodes;\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            /** @type {?} */\r\n            var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\r\n                this._getLastTabbableElement((/** @type {?} */ (children[i]))) :\r\n                null;\r\n            if (tabbableChild) {\r\n                return tabbableChild;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /** Creates an anchor element. */\r\n    /**\r\n     * Creates an anchor element.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype._createAnchor = /**\r\n     * Creates an anchor element.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var anchor = this._document.createElement('div');\r\n        this._toggleAnchorTabIndex(this._enabled, anchor);\r\n        anchor.classList.add('cdk-visually-hidden');\r\n        anchor.classList.add('cdk-focus-trap-anchor');\r\n        anchor.setAttribute('aria-hidden', 'true');\r\n        return anchor;\r\n    };\r\n    /**\r\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\r\n     * @param isEnabled Whether the focus trap is enabled.\r\n     * @param anchor Anchor on which to toggle the tabindex.\r\n     */\r\n    /**\r\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\r\n     * @private\r\n     * @param {?} isEnabled Whether the focus trap is enabled.\r\n     * @param {?} anchor Anchor on which to toggle the tabindex.\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype._toggleAnchorTabIndex = /**\r\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\r\n     * @private\r\n     * @param {?} isEnabled Whether the focus trap is enabled.\r\n     * @param {?} anchor Anchor on which to toggle the tabindex.\r\n     * @return {?}\r\n     */\r\n    function (isEnabled, anchor) {\r\n        // Remove the tabindex completely, rather than setting it to -1, because if the\r\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\r\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\r\n    };\r\n    /** Executes a function when the zone is stable. */\r\n    /**\r\n     * Executes a function when the zone is stable.\r\n     * @private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    FocusTrap.prototype._executeOnStable = /**\r\n     * Executes a function when the zone is stable.\r\n     * @private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        if (this._ngZone.isStable) {\r\n            fn();\r\n        }\r\n        else {\r\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\r\n        }\r\n    };\r\n    return FocusTrap;\r\n}());\r\n/**\r\n * Factory that allows easy instantiation of focus traps.\r\n */\r\nvar FocusTrapFactory = /** @class */ (function () {\r\n    function FocusTrapFactory(_checker, _ngZone, _document) {\r\n        this._checker = _checker;\r\n        this._ngZone = _ngZone;\r\n        this._document = _document;\r\n    }\r\n    /**\r\n     * Creates a focus-trapped region around the given element.\r\n     * @param element The element around which focus will be trapped.\r\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\r\n     *     manually by the user.\r\n     * @returns The created focus trap instance.\r\n     */\r\n    /**\r\n     * Creates a focus-trapped region around the given element.\r\n     * @param {?} element The element around which focus will be trapped.\r\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\r\n     *     manually by the user.\r\n     * @return {?} The created focus trap instance.\r\n     */\r\n    FocusTrapFactory.prototype.create = /**\r\n     * Creates a focus-trapped region around the given element.\r\n     * @param {?} element The element around which focus will be trapped.\r\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\r\n     *     manually by the user.\r\n     * @return {?} The created focus trap instance.\r\n     */\r\n    function (element, deferCaptureElements) {\r\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\r\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\r\n    };\r\n    FocusTrapFactory.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    FocusTrapFactory.ctorParameters = function () { return [\r\n        { type: InteractivityChecker },\r\n        { type: NgZone },\r\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n    ]; };\r\n    /** @nocollapse */ FocusTrapFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\r\n    return FocusTrapFactory;\r\n}());\r\n/**\r\n * Directive for trapping focus within a region.\r\n */\r\nvar CdkTrapFocus = /** @class */ (function () {\r\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\r\n        this._elementRef = _elementRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        /**\r\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\r\n         */\r\n        this._previouslyFocusedElement = null;\r\n        this._document = _document;\r\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n    }\r\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\r\n        /** Whether the focus trap is active. */\r\n        get: /**\r\n         * Whether the focus trap is active.\r\n         * @return {?}\r\n         */\r\n        function () { return this.focusTrap.enabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\r\n        /**\r\n         * Whether the directive should automatially move focus into the trapped region upon\r\n         * initialization and return focus to the previous activeElement upon destruction.\r\n         */\r\n        get: /**\r\n         * Whether the directive should automatially move focus into the trapped region upon\r\n         * initialization and return focus to the previous activeElement upon destruction.\r\n         * @return {?}\r\n         */\r\n        function () { return this._autoCapture; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkTrapFocus.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.focusTrap.destroy();\r\n        // If we stored a previously focused element when using autoCapture, return focus to that\r\n        // element now that the trapped region is being destroyed.\r\n        if (this._previouslyFocusedElement) {\r\n            this._previouslyFocusedElement.focus();\r\n            this._previouslyFocusedElement = null;\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.focusTrap.attachAnchors();\r\n        if (this.autoCapture) {\r\n            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));\r\n            this.focusTrap.focusInitialElementWhenReady();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkTrapFocus.prototype.ngDoCheck = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this.focusTrap.hasAttached()) {\r\n            this.focusTrap.attachAnchors();\r\n        }\r\n    };\r\n    CdkTrapFocus.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[cdkTrapFocus]',\r\n                    exportAs: 'cdkTrapFocus',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    CdkTrapFocus.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: FocusTrapFactory },\r\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n    ]; };\r\n    CdkTrapFocus.propDecorators = {\r\n        enabled: [{ type: Input, args: ['cdkTrapFocus',] }],\r\n        autoCapture: [{ type: Input, args: ['cdkTrapFocusAutoCapture',] }]\r\n    };\r\n    return CdkTrapFocus;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\r\n    providedIn: 'root',\r\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\r\n    return null;\r\n}\r\n/**\r\n * Injection token that can be used to configure the default options for the LiveAnnouncer.\r\n * @type {?}\r\n */\r\nvar LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar LiveAnnouncer = /** @class */ (function () {\r\n    function LiveAnnouncer(elementToken, _ngZone, _document, _defaultOptions) {\r\n        this._ngZone = _ngZone;\r\n        this._defaultOptions = _defaultOptions;\r\n        // We inject the live element and document as `any` because the constructor signature cannot\r\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\r\n        // a class decorator causes TypeScript to preserve the constructor signature types.\r\n        this._document = _document;\r\n        this._liveElement = elementToken || this._createLiveElement();\r\n    }\r\n    /**\r\n     * @param {?} message\r\n     * @param {...?} args\r\n     * @return {?}\r\n     */\r\n    LiveAnnouncer.prototype.announce = /**\r\n     * @param {?} message\r\n     * @param {...?} args\r\n     * @return {?}\r\n     */\r\n    function (message) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        /** @type {?} */\r\n        var defaultOptions = this._defaultOptions;\r\n        /** @type {?} */\r\n        var politeness;\r\n        /** @type {?} */\r\n        var duration;\r\n        if (args.length === 1 && typeof args[0] === 'number') {\r\n            duration = args[0];\r\n        }\r\n        else {\r\n            politeness = args[0], duration = args[1];\r\n        }\r\n        this.clear();\r\n        clearTimeout(this._previousTimeout);\r\n        if (!politeness) {\r\n            politeness =\r\n                (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\r\n        }\r\n        if (duration == null && defaultOptions) {\r\n            duration = defaultOptions.duration;\r\n        }\r\n        // TODO: ensure changing the politeness works on all environments we support.\r\n        this._liveElement.setAttribute('aria-live', politeness);\r\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\r\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\r\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\r\n        //   second time without clearing and then using a non-zero delay.\r\n        // (using JAWS 17 at time of this writing).\r\n        return this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return new Promise((/**\r\n             * @param {?} resolve\r\n             * @return {?}\r\n             */\r\n            function (resolve) {\r\n                clearTimeout(_this._previousTimeout);\r\n                _this._previousTimeout = setTimeout((/**\r\n                 * @return {?}\r\n                 */\r\n                function () {\r\n                    _this._liveElement.textContent = message;\r\n                    resolve();\r\n                    if (typeof duration === 'number') {\r\n                        _this._previousTimeout = setTimeout((/**\r\n                         * @return {?}\r\n                         */\r\n                        function () { return _this.clear(); }), duration);\r\n                    }\r\n                }), 100);\r\n            }));\r\n        }));\r\n    };\r\n    /**\r\n     * Clears the current text from the announcer element. Can be used to prevent\r\n     * screen readers from reading the text out again while the user is going\r\n     * through the page landmarks.\r\n     */\r\n    /**\r\n     * Clears the current text from the announcer element. Can be used to prevent\r\n     * screen readers from reading the text out again while the user is going\r\n     * through the page landmarks.\r\n     * @return {?}\r\n     */\r\n    LiveAnnouncer.prototype.clear = /**\r\n     * Clears the current text from the announcer element. Can be used to prevent\r\n     * screen readers from reading the text out again while the user is going\r\n     * through the page landmarks.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._liveElement) {\r\n            this._liveElement.textContent = '';\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    LiveAnnouncer.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        clearTimeout(this._previousTimeout);\r\n        if (this._liveElement && this._liveElement.parentNode) {\r\n            this._liveElement.parentNode.removeChild(this._liveElement);\r\n            this._liveElement = (/** @type {?} */ (null));\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    LiveAnnouncer.prototype._createLiveElement = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var elementClass = 'cdk-live-announcer-element';\r\n        /** @type {?} */\r\n        var previousElements = this._document.getElementsByClassName(elementClass);\r\n        /** @type {?} */\r\n        var liveEl = this._document.createElement('div');\r\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\r\n        for (var i = 0; i < previousElements.length; i++) {\r\n            (/** @type {?} */ (previousElements[i].parentNode)).removeChild(previousElements[i]);\r\n        }\r\n        liveEl.classList.add(elementClass);\r\n        liveEl.classList.add('cdk-visually-hidden');\r\n        liveEl.setAttribute('aria-atomic', 'true');\r\n        liveEl.setAttribute('aria-live', 'polite');\r\n        this._document.body.appendChild(liveEl);\r\n        return liveEl;\r\n    };\r\n    LiveAnnouncer.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    LiveAnnouncer.ctorParameters = function () { return [\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\r\n        { type: NgZone },\r\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS,] }] }\r\n    ]; };\r\n    /** @nocollapse */ LiveAnnouncer.ngInjectableDef = ɵɵdefineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\r\n    return LiveAnnouncer;\r\n}());\r\n/**\r\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\r\n * with a wider range of browsers and screen readers.\r\n */\r\nvar CdkAriaLive = /** @class */ (function () {\r\n    function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\r\n        this._elementRef = _elementRef;\r\n        this._liveAnnouncer = _liveAnnouncer;\r\n        this._contentObserver = _contentObserver;\r\n        this._ngZone = _ngZone;\r\n        this._politeness = 'off';\r\n    }\r\n    Object.defineProperty(CdkAriaLive.prototype, \"politeness\", {\r\n        /** The aria-live politeness level to use when announcing messages. */\r\n        get: /**\r\n         * The aria-live politeness level to use when announcing messages.\r\n         * @return {?}\r\n         */\r\n        function () { return this._politeness; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            var _this = this;\r\n            this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\r\n            if (this._politeness === 'off') {\r\n                if (this._subscription) {\r\n                    this._subscription.unsubscribe();\r\n                    this._subscription = null;\r\n                }\r\n            }\r\n            else if (!this._subscription) {\r\n                this._subscription = this._ngZone.runOutsideAngular((/**\r\n                 * @return {?}\r\n                 */\r\n                function () {\r\n                    return _this._contentObserver\r\n                        .observe(_this._elementRef)\r\n                        .subscribe((/**\r\n                     * @return {?}\r\n                     */\r\n                    function () {\r\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\r\n                        /** @type {?} */\r\n                        var elementText = _this._elementRef.nativeElement.textContent;\r\n                        // The `MutationObserver` fires also for attribute\r\n                        // changes which we don't want to announce.\r\n                        if (elementText !== _this._previousAnnouncedText) {\r\n                            _this._liveAnnouncer.announce(elementText, _this._politeness);\r\n                            _this._previousAnnouncedText = elementText;\r\n                        }\r\n                    }));\r\n                }));\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkAriaLive.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._subscription) {\r\n            this._subscription.unsubscribe();\r\n        }\r\n    };\r\n    CdkAriaLive.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[cdkAriaLive]',\r\n                    exportAs: 'cdkAriaLive',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    CdkAriaLive.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: LiveAnnouncer },\r\n        { type: ContentObserver },\r\n        { type: NgZone }\r\n    ]; };\r\n    CdkAriaLive.propDecorators = {\r\n        politeness: [{ type: Input, args: ['cdkAriaLive',] }]\r\n    };\r\n    return CdkAriaLive;\r\n}());\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentAnnouncer\r\n * @param {?} liveElement\r\n * @param {?} _document\r\n * @param {?} ngZone\r\n * @return {?}\r\n */\r\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentAnnouncer, liveElement, _document, ngZone) {\r\n    return parentAnnouncer || new LiveAnnouncer(liveElement, ngZone, _document);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nvar LIVE_ANNOUNCER_PROVIDER = {\r\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\r\n    provide: LiveAnnouncer,\r\n    deps: [\r\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\r\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\r\n        DOCUMENT,\r\n        NgZone,\r\n    ],\r\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n// that a value of around 650ms seems appropriate.\r\n/** @type {?} */\r\nvar TOUCH_BUFFER_MS = 650;\r\n/**\r\n * Event listener options that enable capturing and also\r\n * mark the listener as passive if the browser supports it.\r\n * @type {?}\r\n */\r\nvar captureEventListenerOptions = normalizePassiveListenerOptions({\r\n    passive: true,\r\n    capture: true\r\n});\r\n/**\r\n * Monitors mouse and keyboard events to determine the cause of focus events.\r\n */\r\nvar FocusMonitor = /** @class */ (function () {\r\n    function FocusMonitor(_ngZone, _platform) {\r\n        var _this = this;\r\n        this._ngZone = _ngZone;\r\n        this._platform = _platform;\r\n        /**\r\n         * The focus origin that the next focus event is a result of.\r\n         */\r\n        this._origin = null;\r\n        /**\r\n         * Whether the window has just been focused.\r\n         */\r\n        this._windowFocused = false;\r\n        /**\r\n         * Map of elements being monitored to their info.\r\n         */\r\n        this._elementInfo = new Map();\r\n        /**\r\n         * The number of elements currently being monitored.\r\n         */\r\n        this._monitoredElementCount = 0;\r\n        /**\r\n         * Event listener for `keydown` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentKeydownListener = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // On keydown record the origin and clear any touch event that may be in progress.\r\n            _this._lastTouchTarget = null;\r\n            _this._setOriginForCurrentEventQueue('keyboard');\r\n        });\r\n        /**\r\n         * Event listener for `mousedown` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentMousedownListener = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // On mousedown record the origin only if there is not touch\r\n            // target, since a mousedown can happen as a result of a touch event.\r\n            if (!_this._lastTouchTarget) {\r\n                _this._setOriginForCurrentEventQueue('mouse');\r\n            }\r\n        });\r\n        /**\r\n         * Event listener for `touchstart` events on the document.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._documentTouchstartListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            // When the touchstart event fires the focus event is not yet in the event queue. This means\r\n            // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\r\n            // see if a focus happens.\r\n            if (_this._touchTimeoutId != null) {\r\n                clearTimeout(_this._touchTimeoutId);\r\n            }\r\n            // Since this listener is bound on the `document` level, any events coming from the shadow DOM\r\n            // will have their `target` set to the shadow root. If available, use `composedPath` to\r\n            // figure out the event target.\r\n            _this._lastTouchTarget = event.composedPath ? event.composedPath()[0] : event.target;\r\n            _this._touchTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._lastTouchTarget = null; }), TOUCH_BUFFER_MS);\r\n        });\r\n        /**\r\n         * Event listener for `focus` events on the window.\r\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n         */\r\n        this._windowFocusListener = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // Make a note of when the window regains focus, so we can\r\n            // restore the origin info for the focused element.\r\n            _this._windowFocused = true;\r\n            _this._windowFocusTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._windowFocused = false; }));\r\n        });\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?=} checkChildren\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype.monitor = /**\r\n     * @param {?} element\r\n     * @param {?=} checkChildren\r\n     * @return {?}\r\n     */\r\n    function (element, checkChildren) {\r\n        var _this = this;\r\n        if (checkChildren === void 0) { checkChildren = false; }\r\n        // Do nothing if we're not on the browser platform.\r\n        if (!this._platform.isBrowser) {\r\n            return of(null);\r\n        }\r\n        /** @type {?} */\r\n        var nativeElement = coerceElement(element);\r\n        // Check if we're already monitoring this element.\r\n        if (this._elementInfo.has(nativeElement)) {\r\n            /** @type {?} */\r\n            var cachedInfo = this._elementInfo.get(nativeElement);\r\n            (/** @type {?} */ (cachedInfo)).checkChildren = checkChildren;\r\n            return (/** @type {?} */ (cachedInfo)).subject.asObservable();\r\n        }\r\n        // Create monitored element info.\r\n        /** @type {?} */\r\n        var info = {\r\n            unlisten: (/**\r\n             * @return {?}\r\n             */\r\n            function () { }),\r\n            checkChildren: checkChildren,\r\n            subject: new Subject()\r\n        };\r\n        this._elementInfo.set(nativeElement, info);\r\n        this._incrementMonitoredElementCount();\r\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\r\n        /** @type {?} */\r\n        var focusListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) { return _this._onFocus(event, nativeElement); });\r\n        /** @type {?} */\r\n        var blurListener = (/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) { return _this._onBlur(event, nativeElement); });\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            nativeElement.addEventListener('focus', focusListener, true);\r\n            nativeElement.addEventListener('blur', blurListener, true);\r\n        }));\r\n        // Create an unlisten function for later.\r\n        info.unlisten = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            nativeElement.removeEventListener('focus', focusListener, true);\r\n            nativeElement.removeEventListener('blur', blurListener, true);\r\n        });\r\n        return info.subject.asObservable();\r\n    };\r\n    /**\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype.stopMonitoring = /**\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        /** @type {?} */\r\n        var nativeElement = coerceElement(element);\r\n        /** @type {?} */\r\n        var elementInfo = this._elementInfo.get(nativeElement);\r\n        if (elementInfo) {\r\n            elementInfo.unlisten();\r\n            elementInfo.subject.complete();\r\n            this._setClasses(nativeElement);\r\n            this._elementInfo.delete(nativeElement);\r\n            this._decrementMonitoredElementCount();\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} origin\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype.focusVia = /**\r\n     * @param {?} element\r\n     * @param {?} origin\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    function (element, origin, options) {\r\n        /** @type {?} */\r\n        var nativeElement = coerceElement(element);\r\n        this._setOriginForCurrentEventQueue(origin);\r\n        // `focus` isn't available on the server\r\n        if (typeof nativeElement.focus === 'function') {\r\n            // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\r\n            ((/** @type {?} */ (nativeElement))).focus(options);\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._elementInfo.forEach((/**\r\n         * @param {?} _info\r\n         * @param {?} element\r\n         * @return {?}\r\n         */\r\n        function (_info, element) { return _this.stopMonitoring(element); }));\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} className\r\n     * @param {?} shouldSet\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._toggleClass = /**\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} className\r\n     * @param {?} shouldSet\r\n     * @return {?}\r\n     */\r\n    function (element, className, shouldSet) {\r\n        if (shouldSet) {\r\n            element.classList.add(className);\r\n        }\r\n        else {\r\n            element.classList.remove(className);\r\n        }\r\n    };\r\n    /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @param element The element to update the classes on.\r\n     * @param origin The focus origin.\r\n     */\r\n    /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @private\r\n     * @param {?} element The element to update the classes on.\r\n     * @param {?=} origin The focus origin.\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._setClasses = /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @private\r\n     * @param {?} element The element to update the classes on.\r\n     * @param {?=} origin The focus origin.\r\n     * @return {?}\r\n     */\r\n    function (element, origin) {\r\n        /** @type {?} */\r\n        var elementInfo = this._elementInfo.get(element);\r\n        if (elementInfo) {\r\n            this._toggleClass(element, 'cdk-focused', !!origin);\r\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\r\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\r\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\r\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\r\n        }\r\n    };\r\n    /**\r\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\n     * @param origin The origin to set.\r\n     */\r\n    /**\r\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\n     * @private\r\n     * @param {?} origin The origin to set.\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\r\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\n     * @private\r\n     * @param {?} origin The origin to set.\r\n     * @return {?}\r\n     */\r\n    function (origin) {\r\n        var _this = this;\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._origin = origin;\r\n            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\r\n            // tick after the interaction event fired. To ensure the focus origin is always correct,\r\n            // the focus origin will be determined at the beginning of the next tick.\r\n            _this._originTimeoutId = setTimeout((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._origin = null; }), 1);\r\n        }));\r\n    };\r\n    /**\r\n     * Checks whether the given focus event was caused by a touchstart event.\r\n     * @param event The focus event to check.\r\n     * @returns Whether the event was caused by a touch.\r\n     */\r\n    /**\r\n     * Checks whether the given focus event was caused by a touchstart event.\r\n     * @private\r\n     * @param {?} event The focus event to check.\r\n     * @return {?} Whether the event was caused by a touch.\r\n     */\r\n    FocusMonitor.prototype._wasCausedByTouch = /**\r\n     * Checks whether the given focus event was caused by a touchstart event.\r\n     * @private\r\n     * @param {?} event The focus event to check.\r\n     * @return {?} Whether the event was caused by a touch.\r\n     */\r\n    function (event) {\r\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\r\n        // Consider the following dom structure:\r\n        //\r\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\r\n        //   <div #child (click)=\"#parent.focus()\"></div>\r\n        // </div>\r\n        //\r\n        // If the user touches the #child element and the #parent is programmatically focused as a\r\n        // result, this code will still consider it to have been caused by the touch event and will\r\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\r\n        // relatively small edge-case that can be worked around by using\r\n        // focusVia(parentEl, 'program') to focus the parent element.\r\n        //\r\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\r\n        // for the first focus event after the touchstart, and then the first blur event after that\r\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\r\n        // touchstart.\r\n        /** @type {?} */\r\n        var focusTarget = event.target;\r\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\r\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\r\n    };\r\n    /**\r\n     * Handles focus events on a registered element.\r\n     * @param event The focus event.\r\n     * @param element The monitored element.\r\n     */\r\n    /**\r\n     * Handles focus events on a registered element.\r\n     * @private\r\n     * @param {?} event The focus event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._onFocus = /**\r\n     * Handles focus events on a registered element.\r\n     * @private\r\n     * @param {?} event The focus event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    function (event, element) {\r\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n        // focus event affecting the monitored element. If we want to use the origin of the first event\r\n        // instead we should check for the cdk-focused class here and return if the element already has\r\n        // it. (This only matters for elements that have includesChildren = true).\r\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n        // focus event affecting the monitored element. If we want to use the origin of the first event\r\n        // instead we should check for the cdk-focused class here and return if the element already has\r\n        // it. (This only matters for elements that have includesChildren = true).\r\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\r\n        // monitored element itself.\r\n        /** @type {?} */\r\n        var elementInfo = this._elementInfo.get(element);\r\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\r\n            return;\r\n        }\r\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\r\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\r\n        //    the element from before the window blurred.\r\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\r\n        // 3) The element was programmatically focused, in which case we should mark the origin as\r\n        //    'program'.\r\n        /** @type {?} */\r\n        var origin = this._origin;\r\n        if (!origin) {\r\n            if (this._windowFocused && this._lastFocusOrigin) {\r\n                origin = this._lastFocusOrigin;\r\n            }\r\n            else if (this._wasCausedByTouch(event)) {\r\n                origin = 'touch';\r\n            }\r\n            else {\r\n                origin = 'program';\r\n            }\r\n        }\r\n        this._setClasses(element, origin);\r\n        this._emitOrigin(elementInfo.subject, origin);\r\n        this._lastFocusOrigin = origin;\r\n    };\r\n    /**\r\n     * Handles blur events on a registered element.\r\n     * @param event The blur event.\r\n     * @param element The monitored element.\r\n     */\r\n    /**\r\n     * Handles blur events on a registered element.\r\n     * @param {?} event The blur event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._onBlur = /**\r\n     * Handles blur events on a registered element.\r\n     * @param {?} event The blur event.\r\n     * @param {?} element The monitored element.\r\n     * @return {?}\r\n     */\r\n    function (event, element) {\r\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\r\n        // order to focus another child of the monitored element.\r\n        /** @type {?} */\r\n        var elementInfo = this._elementInfo.get(element);\r\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\r\n            element.contains(event.relatedTarget))) {\r\n            return;\r\n        }\r\n        this._setClasses(element);\r\n        this._emitOrigin(elementInfo.subject, null);\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {?} subject\r\n     * @param {?} origin\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._emitOrigin = /**\r\n     * @private\r\n     * @param {?} subject\r\n     * @param {?} origin\r\n     * @return {?}\r\n     */\r\n    function (subject, origin) {\r\n        this._ngZone.run((/**\r\n         * @return {?}\r\n         */\r\n        function () { return subject.next(origin); }));\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // Register global listeners when first element is monitored.\r\n        if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {\r\n            // Note: we listen to events in the capture phase so we\r\n            // can detect them even if the user stops propagation.\r\n            this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                document.addEventListener('keydown', _this._documentKeydownListener, captureEventListenerOptions);\r\n                document.addEventListener('mousedown', _this._documentMousedownListener, captureEventListenerOptions);\r\n                document.addEventListener('touchstart', _this._documentTouchstartListener, captureEventListenerOptions);\r\n                window.addEventListener('focus', _this._windowFocusListener);\r\n            }));\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // Unregister global listeners when last element is unmonitored.\r\n        if (!--this._monitoredElementCount) {\r\n            document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\r\n            document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\r\n            document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\r\n            window.removeEventListener('focus', this._windowFocusListener);\r\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\r\n            clearTimeout(this._windowFocusTimeoutId);\r\n            clearTimeout(this._touchTimeoutId);\r\n            clearTimeout(this._originTimeoutId);\r\n        }\r\n    };\r\n    FocusMonitor.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    FocusMonitor.ctorParameters = function () { return [\r\n        { type: NgZone },\r\n        { type: Platform }\r\n    ]; };\r\n    /** @nocollapse */ FocusMonitor.ngInjectableDef = ɵɵdefineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(ɵɵinject(NgZone), ɵɵinject(Platform)); }, token: FocusMonitor, providedIn: \"root\" });\r\n    return FocusMonitor;\r\n}());\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\r\nvar CdkMonitorFocus = /** @class */ (function () {\r\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\r\n        var _this = this;\r\n        this._elementRef = _elementRef;\r\n        this._focusMonitor = _focusMonitor;\r\n        this.cdkFocusChange = new EventEmitter();\r\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\r\n            .subscribe((/**\r\n         * @param {?} origin\r\n         * @return {?}\r\n         */\r\n        function (origin) { return _this.cdkFocusChange.emit(origin); }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n        this._monitorSubscription.unsubscribe();\r\n    };\r\n    CdkMonitorFocus.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    CdkMonitorFocus.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: FocusMonitor }\r\n    ]; };\r\n    CdkMonitorFocus.propDecorators = {\r\n        cdkFocusChange: [{ type: Output }]\r\n    };\r\n    return CdkMonitorFocus;\r\n}());\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @param {?} parentDispatcher\r\n * @param {?} ngZone\r\n * @param {?} platform\r\n * @return {?}\r\n */\r\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\r\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\r\n}\r\n/**\r\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\r\n * @type {?}\r\n */\r\nvar FOCUS_MONITOR_PROVIDER = {\r\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\r\n    provide: FocusMonitor,\r\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\r\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Screenreaders will often fire fake mousedown events when a focusable element\r\n * is activated using the keyboard. We can typically distinguish between these faked\r\n * mousedown events and real mousedown events using the \"buttons\" property. While\r\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\r\n * the left mouse button), faked mousedowns will usually set the property value to 0.\r\n * @param {?} event\r\n * @return {?}\r\n */\r\nfunction isFakeMousedownFromScreenReader(event) {\r\n    return event.buttons === 0;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar A11yModule = /** @class */ (function () {\r\n    function A11yModule() {\r\n    }\r\n    A11yModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [CommonModule, PlatformModule, ObserversModule],\r\n                    declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\r\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\r\n                },] },\r\n    ];\r\n    return A11yModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { ARIA_DESCRIBER_PROVIDER_FACTORY, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, CdkTrapFocus, InteractivityChecker, LIVE_ANNOUNCER_PROVIDER_FACTORY, LiveAnnouncer, CdkAriaLive, LIVE_ANNOUNCER_PROVIDER, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_DEFAULT_OPTIONS, FOCUS_MONITOR_PROVIDER_FACTORY, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\r\n\r\n"]}