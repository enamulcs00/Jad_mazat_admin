{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm5/platform.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA4EK,AAGC;;;;;;;;;;;;;;;uJAKiM;;;;;;;;;;KAUlM;;;;;;gJAGC","file":"platform.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Inject, Injectable, Optional, PLATFORM_ID, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { isPlatformBrowser } from '@angular/common';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// Whether the current platform supports the V8 Break Iterator. The V8 check\r\n// is necessary to detect all Blink based browsers.\r\n/** @type {?} */\r\nvar hasV8BreakIterator;\r\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\r\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\r\n// the consumer is providing a polyfilled `Map`. See:\r\n// https://github.com/Microsoft/ChakraCore/issues/3189\r\n// https://github.com/angular/components/issues/15687\r\ntry {\r\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && ((/** @type {?} */ (Intl))).v8BreakIterator);\r\n}\r\ncatch (_a) {\r\n    hasV8BreakIterator = false;\r\n}\r\n/**\r\n * Service to detect the current platform by comparing the userAgent strings and\r\n * checking browser-specific global properties.\r\n */\r\nvar Platform = /** @class */ (function () {\r\n    /**\r\n     * @breaking-change 8.0.0 remove optional decorator\r\n     */\r\n    function Platform(_platformId) {\r\n        this._platformId = _platformId;\r\n        /**\r\n         * Whether the Angular application is being rendered in the browser.\r\n         * We want to use the Angular platform check because if the Document is shimmed\r\n         * without the navigator, the following checks will fail. This is preferred because\r\n         * sometimes the Document may be shimmed without the user's knowledge or intention\r\n         */\r\n        this.isBrowser = this._platformId ?\r\n            isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\r\n        /**\r\n         * Whether the current browser is Microsoft Edge.\r\n         */\r\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\r\n        /**\r\n         * Whether the current rendering engine is Microsoft Trident.\r\n         */\r\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\r\n        /**\r\n         * Whether the current rendering engine is Blink.\r\n         */\r\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\r\n        this.BLINK = this.isBrowser && (!!(((/** @type {?} */ (window))).chrome || hasV8BreakIterator) &&\r\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\r\n        /**\r\n         * Whether the current rendering engine is WebKit.\r\n         */\r\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\r\n        // ensure that Webkit runs standalone and is not used as another engine's base.\r\n        this.WEBKIT = this.isBrowser &&\r\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\r\n        /**\r\n         * Whether the current platform is Apple iOS.\r\n         */\r\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\r\n            !('MSStream' in window);\r\n        /**\r\n         * Whether the current browser is Firefox.\r\n         */\r\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\r\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\r\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\r\n        // instead of having an unstable check for Gecko.\r\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\r\n        /**\r\n         * Whether the current platform is Android.\r\n         */\r\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\r\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\r\n        /**\r\n         * Whether the current browser is Safari.\r\n         */\r\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\r\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\r\n        // Safari browser should also use Webkit as its layout engine.\r\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\r\n    }\r\n    Platform.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    Platform.ctorParameters = function () { return [\r\n        { type: Object, decorators: [{ type: Optional }, { type: Inject, args: [PLATFORM_ID,] }] }\r\n    ]; };\r\n    /** @nocollapse */ Platform.ngInjectableDef = ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(ɵɵinject(PLATFORM_ID, 8)); }, token: Platform, providedIn: \"root\" });\r\n    return Platform;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar PlatformModule = /** @class */ (function () {\r\n    function PlatformModule() {\r\n    }\r\n    PlatformModule.decorators = [\r\n        { type: NgModule, args: [{},] },\r\n    ];\r\n    return PlatformModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Cached result Set of input types support by the current browser.\r\n * @type {?}\r\n */\r\nvar supportedInputTypes;\r\n/**\r\n * Types of `<input>` that *might* be supported.\r\n * @type {?}\r\n */\r\nvar candidateInputTypes = [\r\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\r\n    // first changing it to something else:\r\n    // The specified value \"\" does not conform to the required format.\r\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\r\n    'color',\r\n    'button',\r\n    'checkbox',\r\n    'date',\r\n    'datetime-local',\r\n    'email',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'month',\r\n    'number',\r\n    'password',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'search',\r\n    'submit',\r\n    'tel',\r\n    'text',\r\n    'time',\r\n    'url',\r\n    'week',\r\n];\r\n/**\r\n * @return {?} The input types supported by this browser.\r\n */\r\nfunction getSupportedInputTypes() {\r\n    // Result is cached.\r\n    if (supportedInputTypes) {\r\n        return supportedInputTypes;\r\n    }\r\n    // We can't check if an input type is not supported until we're on the browser, so say that\r\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\r\n    // just a helper function and can't inject it.\r\n    if (typeof document !== 'object' || !document) {\r\n        supportedInputTypes = new Set(candidateInputTypes);\r\n        return supportedInputTypes;\r\n    }\r\n    /** @type {?} */\r\n    var featureTestInput = document.createElement('input');\r\n    supportedInputTypes = new Set(candidateInputTypes.filter((/**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        featureTestInput.setAttribute('type', value);\r\n        return featureTestInput.type === value;\r\n    })));\r\n    return supportedInputTypes;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Cached result of whether the user's browser supports passive event listeners.\r\n * @type {?}\r\n */\r\nvar supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n * @return {?}\r\n */\r\nfunction supportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', (/** @type {?} */ (null)), Object.defineProperty({}, 'passive', {\r\n                get: (/**\r\n                 * @return {?}\r\n                 */\r\n                function () { return supportsPassiveEvents = true; })\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param {?} options Object to be normalized.\r\n * @return {?}\r\n */\r\nfunction normalizePassiveListenerOptions(options) {\r\n    return supportsPassiveEventListeners() ? options : !!options.capture;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/** @enum {number} */\r\nvar RtlScrollAxisType = {\r\n    /**\r\n     * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\r\n     * all the way right.\r\n     */\r\n    NORMAL: 0,\r\n    /**\r\n     * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\r\n     * all the way right.\r\n     */\r\n    NEGATED: 1,\r\n    /**\r\n     * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\r\n     * all the way right.\r\n     */\r\n    INVERTED: 2,\r\n};\r\nRtlScrollAxisType[RtlScrollAxisType.NORMAL] = 'NORMAL';\r\nRtlScrollAxisType[RtlScrollAxisType.NEGATED] = 'NEGATED';\r\nRtlScrollAxisType[RtlScrollAxisType.INVERTED] = 'INVERTED';\r\n/**\r\n * Cached result of the way the browser handles the horizontal scroll axis in RTL mode.\r\n * @type {?}\r\n */\r\nvar rtlScrollAxisType;\r\n/**\r\n * Check whether the browser supports scroll behaviors.\r\n * @return {?}\r\n */\r\nfunction supportsScrollBehavior() {\r\n    return !!(typeof document == 'object' && 'scrollBehavior' in (/** @type {?} */ (document.documentElement)).style);\r\n}\r\n/**\r\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\r\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\r\n * @return {?}\r\n */\r\nfunction getRtlScrollAxisType() {\r\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\r\n    if (typeof document !== 'object' || !document) {\r\n        return RtlScrollAxisType.NORMAL;\r\n    }\r\n    if (!rtlScrollAxisType) {\r\n        // Create a 1px wide scrolling container and a 2px wide content element.\r\n        /** @type {?} */\r\n        var scrollContainer = document.createElement('div');\r\n        /** @type {?} */\r\n        var containerStyle = scrollContainer.style;\r\n        scrollContainer.dir = 'rtl';\r\n        containerStyle.height = '1px';\r\n        containerStyle.width = '1px';\r\n        containerStyle.overflow = 'auto';\r\n        containerStyle.visibility = 'hidden';\r\n        containerStyle.pointerEvents = 'none';\r\n        containerStyle.position = 'absolute';\r\n        /** @type {?} */\r\n        var content = document.createElement('div');\r\n        /** @type {?} */\r\n        var contentStyle = content.style;\r\n        contentStyle.width = '2px';\r\n        contentStyle.height = '1px';\r\n        scrollContainer.appendChild(content);\r\n        document.body.appendChild(scrollContainer);\r\n        rtlScrollAxisType = RtlScrollAxisType.NORMAL;\r\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\r\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\r\n        // dealing with one of the other two types of browsers.\r\n        if (scrollContainer.scrollLeft === 0) {\r\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\r\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\r\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\r\n            // return 0 when we read it again.\r\n            scrollContainer.scrollLeft = 1;\r\n            rtlScrollAxisType =\r\n                scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;\r\n        }\r\n        (/** @type {?} */ (scrollContainer.parentNode)).removeChild(scrollContainer);\r\n    }\r\n    return rtlScrollAxisType;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/** @type {?} */\r\nvar shadowDomIsSupported;\r\n/**\r\n * Checks whether the user's browser support Shadow DOM.\r\n * @return {?}\r\n */\r\nfunction _supportsShadowDom() {\r\n    if (shadowDomIsSupported == null) {\r\n        /** @type {?} */\r\n        var head = typeof document !== 'undefined' ? document.head : null;\r\n        shadowDomIsSupported = !!(head && (((/** @type {?} */ (head))).createShadowRoot || head.attachShadow));\r\n    }\r\n    return shadowDomIsSupported;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { Platform, PlatformModule, getSupportedInputTypes, supportsPassiveEventListeners, normalizePassiveListenerOptions, supportsScrollBehavior, getRtlScrollAxisType, RtlScrollAxisType, _supportsShadowDom };\r\n\r\n"]}