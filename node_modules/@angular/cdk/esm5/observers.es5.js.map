{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/cdk/esm5/observers.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;MAaM,AAGA;;;;;;oDACqO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAqJrO,AAGA;;;;;;;;;;8NAKsO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoHtO,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;uGAWA;;;;;KAKD;;;;;;;;;;;yLAOC","file":"observers.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { coerceBooleanProperty, coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\r\n * \\@docs-private\r\n */\r\nvar MutationObserverFactory = /** @class */ (function () {\r\n    function MutationObserverFactory() {\r\n    }\r\n    /**\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    MutationObserverFactory.prototype.create = /**\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    function (callback) {\r\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\r\n    };\r\n    MutationObserverFactory.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */ MutationObserverFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\r\n    return MutationObserverFactory;\r\n}());\r\n/**\r\n * An injectable service that allows watching elements for changes to their content.\r\n */\r\nvar ContentObserver = /** @class */ (function () {\r\n    function ContentObserver(_mutationObserverFactory) {\r\n        this._mutationObserverFactory = _mutationObserverFactory;\r\n        /**\r\n         * Keeps track of the existing MutationObservers so they can be reused.\r\n         */\r\n        this._observedElements = new Map();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ContentObserver.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._observedElements.forEach((/**\r\n         * @param {?} _\r\n         * @param {?} element\r\n         * @return {?}\r\n         */\r\n        function (_, element) { return _this._cleanupObserver(element); }));\r\n    };\r\n    /**\r\n     * @param {?} elementOrRef\r\n     * @return {?}\r\n     */\r\n    ContentObserver.prototype.observe = /**\r\n     * @param {?} elementOrRef\r\n     * @return {?}\r\n     */\r\n    function (elementOrRef) {\r\n        var _this = this;\r\n        /** @type {?} */\r\n        var element = coerceElement(elementOrRef);\r\n        return new Observable((/**\r\n         * @param {?} observer\r\n         * @return {?}\r\n         */\r\n        function (observer) {\r\n            /** @type {?} */\r\n            var stream = _this._observeElement(element);\r\n            /** @type {?} */\r\n            var subscription = stream.subscribe(observer);\r\n            return (/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                subscription.unsubscribe();\r\n                _this._unobserveElement(element);\r\n            });\r\n        }));\r\n    };\r\n    /**\r\n     * Observes the given element by using the existing MutationObserver if available, or creating a\r\n     * new one if not.\r\n     */\r\n    /**\r\n     * Observes the given element by using the existing MutationObserver if available, or creating a\r\n     * new one if not.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    ContentObserver.prototype._observeElement = /**\r\n     * Observes the given element by using the existing MutationObserver if available, or creating a\r\n     * new one if not.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        if (!this._observedElements.has(element)) {\r\n            /** @type {?} */\r\n            var stream_1 = new Subject();\r\n            /** @type {?} */\r\n            var observer = this._mutationObserverFactory.create((/**\r\n             * @param {?} mutations\r\n             * @return {?}\r\n             */\r\n            function (mutations) { return stream_1.next(mutations); }));\r\n            if (observer) {\r\n                observer.observe(element, {\r\n                    characterData: true,\r\n                    childList: true,\r\n                    subtree: true\r\n                });\r\n            }\r\n            this._observedElements.set(element, { observer: observer, stream: stream_1, count: 1 });\r\n        }\r\n        else {\r\n            (/** @type {?} */ (this._observedElements.get(element))).count++;\r\n        }\r\n        return (/** @type {?} */ (this._observedElements.get(element))).stream;\r\n    };\r\n    /**\r\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\r\n     * observing this element.\r\n     */\r\n    /**\r\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\r\n     * observing this element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    ContentObserver.prototype._unobserveElement = /**\r\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\r\n     * observing this element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        if (this._observedElements.has(element)) {\r\n            (/** @type {?} */ (this._observedElements.get(element))).count--;\r\n            if (!(/** @type {?} */ (this._observedElements.get(element))).count) {\r\n                this._cleanupObserver(element);\r\n            }\r\n        }\r\n    };\r\n    /** Clean up the underlying MutationObserver for the specified element. */\r\n    /**\r\n     * Clean up the underlying MutationObserver for the specified element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    ContentObserver.prototype._cleanupObserver = /**\r\n     * Clean up the underlying MutationObserver for the specified element.\r\n     * @private\r\n     * @param {?} element\r\n     * @return {?}\r\n     */\r\n    function (element) {\r\n        if (this._observedElements.has(element)) {\r\n            var _a = (/** @type {?} */ (this._observedElements.get(element))), observer = _a.observer, stream = _a.stream;\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n            stream.complete();\r\n            this._observedElements.delete(element);\r\n        }\r\n    };\r\n    ContentObserver.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */\r\n    ContentObserver.ctorParameters = function () { return [\r\n        { type: MutationObserverFactory }\r\n    ]; };\r\n    /** @nocollapse */ ContentObserver.ngInjectableDef = ɵɵdefineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(ɵɵinject(MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\r\n    return ContentObserver;\r\n}());\r\n/**\r\n * Directive that triggers a callback whenever the content of\r\n * its associated element has changed.\r\n */\r\nvar CdkObserveContent = /** @class */ (function () {\r\n    function CdkObserveContent(_contentObserver, _elementRef, _ngZone) {\r\n        this._contentObserver = _contentObserver;\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        /**\r\n         * Event emitted for each change in the element's content.\r\n         */\r\n        this.event = new EventEmitter();\r\n        this._disabled = false;\r\n        this._currentSubscription = null;\r\n    }\r\n    Object.defineProperty(CdkObserveContent.prototype, \"disabled\", {\r\n        /**\r\n         * Whether observing content is disabled. This option can be used\r\n         * to disconnect the underlying MutationObserver until it is needed.\r\n         */\r\n        get: /**\r\n         * Whether observing content is disabled. This option can be used\r\n         * to disconnect the underlying MutationObserver until it is needed.\r\n         * @return {?}\r\n         */\r\n        function () { return this._disabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._disabled = coerceBooleanProperty(value);\r\n            this._disabled ? this._unsubscribe() : this._subscribe();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CdkObserveContent.prototype, \"debounce\", {\r\n        /** Debounce interval for emitting the changes. */\r\n        get: /**\r\n         * Debounce interval for emitting the changes.\r\n         * @return {?}\r\n         */\r\n        function () { return this._debounce; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._debounce = coerceNumberProperty(value);\r\n            this._subscribe();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkObserveContent.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this._currentSubscription && !this.disabled) {\r\n            this._subscribe();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    CdkObserveContent.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._unsubscribe();\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    CdkObserveContent.prototype._subscribe = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._unsubscribe();\r\n        /** @type {?} */\r\n        var stream = this._contentObserver.observe(this._elementRef);\r\n        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\r\n        // Consider brining it back inside the zone next time we're making breaking changes.\r\n        // Bringing it back inside can cause things like infinite change detection loops and changed\r\n        // after checked errors if people's code isn't handling it properly.\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._currentSubscription =\r\n                (_this.debounce ? stream.pipe(debounceTime(_this.debounce)) : stream).subscribe(_this.event);\r\n        }));\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    CdkObserveContent.prototype._unsubscribe = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._currentSubscription) {\r\n            this._currentSubscription.unsubscribe();\r\n        }\r\n    };\r\n    CdkObserveContent.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[cdkObserveContent]',\r\n                    exportAs: 'cdkObserveContent',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    CdkObserveContent.ctorParameters = function () { return [\r\n        { type: ContentObserver },\r\n        { type: ElementRef },\r\n        { type: NgZone }\r\n    ]; };\r\n    CdkObserveContent.propDecorators = {\r\n        event: [{ type: Output, args: ['cdkObserveContent',] }],\r\n        disabled: [{ type: Input, args: ['cdkObserveContentDisabled',] }],\r\n        debounce: [{ type: Input }]\r\n    };\r\n    return CdkObserveContent;\r\n}());\r\nvar ObserversModule = /** @class */ (function () {\r\n    function ObserversModule() {\r\n    }\r\n    ObserversModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    exports: [CdkObserveContent],\r\n                    declarations: [CdkObserveContent],\r\n                    providers: [MutationObserverFactory]\r\n                },] },\r\n    ];\r\n    return ObserversModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MutationObserverFactory, ContentObserver, CdkObserveContent, ObserversModule };\r\n\r\n"]}