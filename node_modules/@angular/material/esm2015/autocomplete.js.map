{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm2015/autocomplete.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4KC,aAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCD,4FAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqyBD,aAuBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD,2BAcC","file":"autocomplete.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, InjectionToken, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, Directive, forwardRef, Host, NgZone, Optional, ViewContainerRef, NgModule } from '@angular/core';\r\nimport { MAT_OPTION_PARENT_COMPONENT, MatOptgroup, MatOption, mixinDisableRipple, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionSelectionChange, MatOptionModule, MatCommonModule } from '@angular/material/core';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@angular/cdk/keycodes';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { _supportsShadowDom } from '@angular/cdk/platform';\r\nimport { TemplatePortal } from '@angular/cdk/portal';\r\nimport { ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { MatFormField } from '@angular/material/form-field';\r\nimport { defer, fromEvent, merge, of, Subject, Subscription } from 'rxjs';\r\nimport { delay, filter, map, switchMap, take, tap } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\r\n * the component definition.\r\n * @type {?}\r\n */\r\nlet _uniqueAutocompleteIdCounter = 0;\r\n/**\r\n * Event object that is emitted when an autocomplete option is selected.\r\n */\r\nclass MatAutocompleteSelectedEvent {\r\n    /**\r\n     * @param {?} source\r\n     * @param {?} option\r\n     */\r\n    constructor(source, option) {\r\n        this.source = source;\r\n        this.option = option;\r\n    }\r\n}\r\n// Boilerplate for applying mixins to MatAutocomplete.\r\n/**\r\n * \\@docs-private\r\n */\r\nclass MatAutocompleteBase {\r\n}\r\n/** @type {?} */\r\nconst _MatAutocompleteMixinBase = mixinDisableRipple(MatAutocompleteBase);\r\n/**\r\n * Injection token to be used to override the default options for `mat-autocomplete`.\r\n * @type {?}\r\n */\r\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\r\n    return { autoActiveFirstOption: false };\r\n}\r\nclass MatAutocomplete extends _MatAutocompleteMixinBase {\r\n    /**\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} _elementRef\r\n     * @param {?} defaults\r\n     */\r\n    constructor(_changeDetectorRef, _elementRef, defaults) {\r\n        super();\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._elementRef = _elementRef;\r\n        /**\r\n         * Whether the autocomplete panel should be visible, depending on option length.\r\n         */\r\n        this.showPanel = false;\r\n        this._isOpen = false;\r\n        /**\r\n         * Function that maps an option's control value to its display value in the trigger.\r\n         */\r\n        this.displayWith = null;\r\n        /**\r\n         * Event that is emitted whenever an option from the list is selected.\r\n         */\r\n        this.optionSelected = new EventEmitter();\r\n        /**\r\n         * Event that is emitted when the autocomplete panel is opened.\r\n         */\r\n        this.opened = new EventEmitter();\r\n        /**\r\n         * Event that is emitted when the autocomplete panel is closed.\r\n         */\r\n        this.closed = new EventEmitter();\r\n        this._classList = {};\r\n        /**\r\n         * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\r\n         */\r\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\r\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\r\n    }\r\n    /**\r\n     * Whether the autocomplete panel is open.\r\n     * @return {?}\r\n     */\r\n    get isOpen() { return this._isOpen && this.showPanel; }\r\n    /**\r\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\r\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\r\n     * @return {?}\r\n     */\r\n    get autoActiveFirstOption() { return this._autoActiveFirstOption; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set autoActiveFirstOption(value) {\r\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\r\n     * inside the overlay container to allow for easy styling.\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set classList(value) {\r\n        if (value && value.length) {\r\n            this._classList = value.split(' ').reduce((/**\r\n             * @param {?} classList\r\n             * @param {?} className\r\n             * @return {?}\r\n             */\r\n            (classList, className) => {\r\n                classList[className.trim()] = true;\r\n                return classList;\r\n            }), (/** @type {?} */ ({})));\r\n        }\r\n        else {\r\n            this._classList = {};\r\n        }\r\n        this._setVisibilityClasses(this._classList);\r\n        this._elementRef.nativeElement.className = '';\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\r\n        // Set the initial visibility state.\r\n        this._setVisibility();\r\n    }\r\n    /**\r\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\r\n     * above or below the fold, as they are not actually being focused when active.\r\n     * @param {?} scrollTop\r\n     * @return {?}\r\n     */\r\n    _setScrollTop(scrollTop) {\r\n        if (this.panel) {\r\n            this.panel.nativeElement.scrollTop = scrollTop;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the panel's scrollTop.\r\n     * @return {?}\r\n     */\r\n    _getScrollTop() {\r\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\r\n    }\r\n    /**\r\n     * Panel should hide itself when the option list is empty.\r\n     * @return {?}\r\n     */\r\n    _setVisibility() {\r\n        this.showPanel = !!this.options.length;\r\n        this._setVisibilityClasses(this._classList);\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /**\r\n     * Emits the `select` event.\r\n     * @param {?} option\r\n     * @return {?}\r\n     */\r\n    _emitSelectEvent(option) {\r\n        /** @type {?} */\r\n        const event = new MatAutocompleteSelectedEvent(this, option);\r\n        this.optionSelected.emit(event);\r\n    }\r\n    /**\r\n     * Sets the autocomplete visibility classes on a classlist based on the panel is visible.\r\n     * @private\r\n     * @param {?} classList\r\n     * @return {?}\r\n     */\r\n    _setVisibilityClasses(classList) {\r\n        classList['mat-autocomplete-visible'] = this.showPanel;\r\n        classList['mat-autocomplete-hidden'] = !this.showPanel;\r\n    }\r\n}\r\nMatAutocomplete.decorators = [\r\n    { type: Component, args: [{selector: 'mat-autocomplete',\r\n                template: \"<ng-template><div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel><ng-content></ng-content></div></ng-template>\",\r\n                styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                exportAs: 'matAutocomplete',\r\n                inputs: ['disableRipple'],\r\n                host: {\r\n                    'class': 'mat-autocomplete'\r\n                },\r\n                providers: [\r\n                    { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatAutocomplete.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\r\n];\r\nMatAutocomplete.propDecorators = {\r\n    template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],\r\n    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],\r\n    options: [{ type: ContentChildren, args: [MatOption, { descendants: true },] }],\r\n    optionGroups: [{ type: ContentChildren, args: [MatOptgroup,] }],\r\n    displayWith: [{ type: Input }],\r\n    autoActiveFirstOption: [{ type: Input }],\r\n    panelWidth: [{ type: Input }],\r\n    optionSelected: [{ type: Output }],\r\n    opened: [{ type: Output }],\r\n    closed: [{ type: Output }],\r\n    classList: [{ type: Input, args: ['class',] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Directive applied to an element to make it usable\r\n * as a connection point for an autocomplete panel.\r\n */\r\nclass MatAutocompleteOrigin {\r\n    /**\r\n     * @param {?} elementRef\r\n     */\r\n    constructor(elementRef) {\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nMatAutocompleteOrigin.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[matAutocompleteOrigin]',\r\n                exportAs: 'matAutocompleteOrigin',\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatAutocompleteOrigin.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * The height of each autocomplete option.\r\n * @type {?}\r\n */\r\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\r\n/**\r\n * The total height of the autocomplete panel.\r\n * @type {?}\r\n */\r\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\r\n/**\r\n * Injection token that determines the scroll handling while the autocomplete panel is open.\r\n * @type {?}\r\n */\r\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return (/**\r\n     * @return {?}\r\n     */\r\n    () => overlay.scrollStrategies.reposition());\r\n}\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/**\r\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef((/**\r\n     * @return {?}\r\n     */\r\n    () => MatAutocompleteTrigger)),\r\n    multi: true\r\n};\r\n/**\r\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction getMatAutocompleteMissingPanelError() {\r\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\r\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\r\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\r\n}\r\nclass MatAutocompleteTrigger {\r\n    /**\r\n     * @param {?} _element\r\n     * @param {?} _overlay\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} _zone\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} scrollStrategy\r\n     * @param {?} _dir\r\n     * @param {?} _formField\r\n     * @param {?} _document\r\n     * @param {?=} _viewportRuler\r\n     */\r\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {\r\n        this._element = _element;\r\n        this._overlay = _overlay;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._zone = _zone;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dir = _dir;\r\n        this._formField = _formField;\r\n        this._document = _document;\r\n        this._viewportRuler = _viewportRuler;\r\n        this._componentDestroyed = false;\r\n        this._autocompleteDisabled = false;\r\n        /**\r\n         * Whether or not the label state is being overridden.\r\n         */\r\n        this._manuallyFloatingLabel = false;\r\n        /**\r\n         * Subscription to viewport size changes.\r\n         */\r\n        this._viewportSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\r\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\r\n         * comes back.\r\n         */\r\n        this._canOpenOnNextFocus = true;\r\n        /**\r\n         * Stream of keyboard events that can close the panel.\r\n         */\r\n        this._closeKeyEventStream = new Subject();\r\n        /**\r\n         * Event handler for when the window is blurred. Needs to be an\r\n         * arrow function in order to preserve the context.\r\n         */\r\n        this._windowBlurHandler = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\r\n            // refocused when they come back. In this case we want to skip the first focus event, if the\r\n            // pane was closed, in order to avoid reopening it unintentionally.\r\n            this._canOpenOnNextFocus =\r\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\r\n        });\r\n        /**\r\n         * `View -> model callback called when value changes`\r\n         */\r\n        this._onChange = (/**\r\n         * @return {?}\r\n         */\r\n        () => { });\r\n        /**\r\n         * `View -> model callback called when autocomplete has been touched`\r\n         */\r\n        this._onTouched = (/**\r\n         * @return {?}\r\n         */\r\n        () => { });\r\n        /**\r\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\r\n         * will render the panel underneath the trigger if there is enough space for it to fit in\r\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\r\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\r\n         * whether it fits completely in the viewport.\r\n         */\r\n        this.position = 'auto';\r\n        /**\r\n         * `autocomplete` attribute to be set on the input element.\r\n         * \\@docs-private\r\n         */\r\n        this.autocompleteAttribute = 'off';\r\n        this._overlayAttached = false;\r\n        /**\r\n         * Stream of autocomplete option selections.\r\n         */\r\n        this.optionSelections = (/** @type {?} */ (defer((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            if (this.autocomplete && this.autocomplete.options) {\r\n                return merge(...this.autocomplete.options.map((/**\r\n                 * @param {?} option\r\n                 * @return {?}\r\n                 */\r\n                option => option.onSelectionChange)));\r\n            }\r\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\r\n            // Return a stream that we'll replace with the real one once everything is in place.\r\n            return this._zone.onStable\r\n                .asObservable()\r\n                .pipe(take(1), switchMap((/**\r\n             * @return {?}\r\n             */\r\n            () => this.optionSelections)));\r\n        }))));\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    /**\r\n     * Whether the autocomplete is disabled. When disabled, the element will\r\n     * act as a regular input and the user won't be able to open the panel.\r\n     * @return {?}\r\n     */\r\n    get autocompleteDisabled() { return this._autocompleteDisabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set autocompleteDisabled(value) {\r\n        this._autocompleteDisabled = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterViewInit() {\r\n        if (typeof window !== 'undefined') {\r\n            this._zone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                window.addEventListener('blur', this._windowBlurHandler);\r\n            }));\r\n            if (_supportsShadowDom()) {\r\n                /** @type {?} */\r\n                const element = this._element.nativeElement;\r\n                /** @type {?} */\r\n                const rootNode = element.getRootNode ? element.getRootNode() : null;\r\n                // We need to take the `ShadowRoot` off of `window`, because the built-in types are\r\n                // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\r\n                this._isInsideShadowRoot = rootNode instanceof ((/** @type {?} */ (window))).ShadowRoot;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    ngOnChanges(changes) {\r\n        if (changes['position'] && this._positionStrategy) {\r\n            this._setStrategyPositions(this._positionStrategy);\r\n            if (this.panelOpen) {\r\n                (/** @type {?} */ (this._overlayRef)).updatePosition();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (typeof window !== 'undefined') {\r\n            window.removeEventListener('blur', this._windowBlurHandler);\r\n        }\r\n        this._viewportSubscription.unsubscribe();\r\n        this._componentDestroyed = true;\r\n        this._destroyPanel();\r\n        this._closeKeyEventStream.complete();\r\n    }\r\n    /**\r\n     * Whether or not the autocomplete panel is open.\r\n     * @return {?}\r\n     */\r\n    get panelOpen() {\r\n        return this._overlayAttached && this.autocomplete.showPanel;\r\n    }\r\n    /**\r\n     * Opens the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    openPanel() {\r\n        this._attachOverlay();\r\n        this._floatLabel();\r\n    }\r\n    /**\r\n     * Closes the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    closePanel() {\r\n        this._resetLabel();\r\n        if (!this._overlayAttached) {\r\n            return;\r\n        }\r\n        if (this.panelOpen) {\r\n            // Only emit if the panel was visible.\r\n            this.autocomplete.closed.emit();\r\n        }\r\n        this.autocomplete._isOpen = this._overlayAttached = false;\r\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\r\n            this._overlayRef.detach();\r\n            this._closingActionsSubscription.unsubscribe();\r\n        }\r\n        // Note that in some cases this can end up being called after the component is destroyed.\r\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\r\n        if (!this._componentDestroyed) {\r\n            // We need to trigger change detection manually, because\r\n            // `fromEvent` doesn't seem to do it at the proper time.\r\n            // This ensures that the label is reset when the\r\n            // user clicks outside.\r\n            this._changeDetectorRef.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     * @return {?}\r\n     */\r\n    updatePosition() {\r\n        if (this._overlayAttached) {\r\n            (/** @type {?} */ (this._overlayRef)).updatePosition();\r\n        }\r\n    }\r\n    /**\r\n     * A stream of actions that should close the autocomplete panel, including\r\n     * when an option is selected, on blur, and when TAB is pressed.\r\n     * @return {?}\r\n     */\r\n    get panelClosingActions() {\r\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter((/**\r\n         * @return {?}\r\n         */\r\n        () => this._overlayAttached))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\r\n            this._overlayRef.detachments().pipe(filter((/**\r\n             * @return {?}\r\n             */\r\n            () => this._overlayAttached))) :\r\n            of()).pipe(\r\n        // Normalize the output so we return a consistent type.\r\n        map((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => event instanceof MatOptionSelectionChange ? event : null)));\r\n    }\r\n    /**\r\n     * The currently active option, coerced to MatOption type.\r\n     * @return {?}\r\n     */\r\n    get activeOption() {\r\n        if (this.autocomplete && this.autocomplete._keyManager) {\r\n            return this.autocomplete._keyManager.activeItem;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Stream of clicks outside of the autocomplete panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getOutsideClickStream() {\r\n        return merge((/** @type {?} */ (fromEvent(this._document, 'click'))), (/** @type {?} */ (fromEvent(this._document, 'touchend'))))\r\n            .pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => {\r\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\r\n            // fall back to check the first element in the path of the click event.\r\n            /** @type {?} */\r\n            const clickTarget = (/** @type {?} */ ((this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\r\n                event.target)));\r\n            /** @type {?} */\r\n            const formField = this._formField ? this._formField._elementRef.nativeElement : null;\r\n            return this._overlayAttached && clickTarget !== this._element.nativeElement &&\r\n                (!formField || !formField.contains(clickTarget)) &&\r\n                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));\r\n        })));\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    writeValue(value) {\r\n        Promise.resolve(null).then((/**\r\n         * @return {?}\r\n         */\r\n        () => this._setTriggerValue(value)));\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    registerOnChange(fn) {\r\n        this._onChange = fn;\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    registerOnTouched(fn) {\r\n        this._onTouched = fn;\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    setDisabledState(isDisabled) {\r\n        this._element.nativeElement.disabled = isDisabled;\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\r\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\r\n        // the input value to the one that it had on focus, however it won't dispatch any events\r\n        // which means that the model value will be out of sync with the view.\r\n        if (keyCode === ESCAPE) {\r\n            event.preventDefault();\r\n        }\r\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\r\n            this.activeOption._selectViaInteraction();\r\n            this._resetActiveItem();\r\n            event.preventDefault();\r\n        }\r\n        else if (this.autocomplete) {\r\n            /** @type {?} */\r\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\r\n            /** @type {?} */\r\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\r\n            if (this.panelOpen || keyCode === TAB) {\r\n                this.autocomplete._keyManager.onKeydown(event);\r\n            }\r\n            else if (isArrowKey && this._canOpen()) {\r\n                this.openPanel();\r\n            }\r\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\r\n                this._scrollToOption();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleInput(event) {\r\n        /** @type {?} */\r\n        let target = (/** @type {?} */ (event.target));\r\n        /** @type {?} */\r\n        let value = target.value;\r\n        // Based on `NumberValueAccessor` from forms.\r\n        if (target.type === 'number') {\r\n            value = value == '' ? null : parseFloat(value);\r\n        }\r\n        // If the input has a placeholder, IE will fire the `input` event on page load,\r\n        // focus and blur, in addition to when the user actually changed the value. To\r\n        // filter out all of the extra events, we save the value on focus and between\r\n        // `input` events, and we check whether it changed.\r\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\r\n        if (this._previousValue !== value) {\r\n            this._previousValue = value;\r\n            this._onChange(value);\r\n            if (this._canOpen() && this._document.activeElement === event.target) {\r\n                this.openPanel();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    _handleFocus() {\r\n        if (!this._canOpenOnNextFocus) {\r\n            this._canOpenOnNextFocus = true;\r\n        }\r\n        else if (this._canOpen()) {\r\n            this._previousValue = this._element.nativeElement.value;\r\n            this._attachOverlay();\r\n            this._floatLabel(true);\r\n        }\r\n    }\r\n    /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @private\r\n     * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\r\n     * @return {?}\r\n     */\r\n    _floatLabel(shouldAnimate = false) {\r\n        if (this._formField && this._formField.floatLabel === 'auto') {\r\n            if (shouldAnimate) {\r\n                this._formField._animateAndLockLabel();\r\n            }\r\n            else {\r\n                this._formField.floatLabel = 'always';\r\n            }\r\n            this._manuallyFloatingLabel = true;\r\n        }\r\n    }\r\n    /**\r\n     * If the label has been manually elevated, return it to its normal state.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _resetLabel() {\r\n        if (this._manuallyFloatingLabel) {\r\n            this._formField.floatLabel = 'auto';\r\n            this._manuallyFloatingLabel = false;\r\n        }\r\n    }\r\n    /**\r\n     * Given that we are not actually focusing active options, we must manually adjust scroll\r\n     * to reveal options below the fold. First, we find the offset of the option from the top\r\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n     * the panel height + the option height, so the active option will be just visible at the\r\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n     * not adjusted.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _scrollToOption() {\r\n        /** @type {?} */\r\n        const index = this.autocomplete._keyManager.activeItemIndex || 0;\r\n        /** @type {?} */\r\n        const labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\r\n        if (index === 0 && labelCount === 1) {\r\n            // If we've got one group label before the option and we're at the top option,\r\n            // scroll the list to the top. This is better UX than scrolling the list to the\r\n            // top of the option, because it allows the user to read the top group's label.\r\n            this.autocomplete._setScrollTop(0);\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            const newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\r\n            this.autocomplete._setScrollTop(newScrollPosition);\r\n        }\r\n    }\r\n    /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _subscribeToClosingActions() {\r\n        /** @type {?} */\r\n        const firstStable = this._zone.onStable.asObservable().pipe(take(1));\r\n        /** @type {?} */\r\n        const optionChanges = this.autocomplete.options.changes.pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this._positionStrategy.reapplyLastPosition())), \r\n        // Defer emitting to the stream until the next tick, because changing\r\n        // bindings in here will cause \"changed after checked\" errors.\r\n        delay(0));\r\n        // When the zone is stable initially, and when the option list changes...\r\n        return merge(firstStable, optionChanges)\r\n            .pipe(\r\n        // create a new stream of panelClosingActions, replacing any previous streams\r\n        // that were created, and flatten it so our stream only emits closing events...\r\n        switchMap((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            /** @type {?} */\r\n            const wasOpen = this.panelOpen;\r\n            this._resetActiveItem();\r\n            this.autocomplete._setVisibility();\r\n            if (this.panelOpen) {\r\n                (/** @type {?} */ (this._overlayRef)).updatePosition();\r\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened`\r\n                // event, because we may not have emitted it when the panel was attached. This\r\n                // can happen if the users opens the panel and there are no options, but the\r\n                // options come in slightly later or as a result of the value changing.\r\n                if (wasOpen !== this.panelOpen) {\r\n                    this.autocomplete.opened.emit();\r\n                }\r\n            }\r\n            return this.panelClosingActions;\r\n        })), \r\n        // when the first closing event occurs...\r\n        take(1))\r\n            // set the value, close the panel, and complete.\r\n            .subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => this._setValueAndClose(event)));\r\n    }\r\n    /**\r\n     * Destroys the autocomplete suggestion panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _destroyPanel() {\r\n        if (this._overlayRef) {\r\n            this.closePanel();\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    _setTriggerValue(value) {\r\n        /** @type {?} */\r\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\r\n            this.autocomplete.displayWith(value) :\r\n            value;\r\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\r\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\r\n        /** @type {?} */\r\n        const inputValue = toDisplay != null ? toDisplay : '';\r\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\r\n        // through change detection.\r\n        if (this._formField) {\r\n            this._formField._control.value = inputValue;\r\n        }\r\n        else {\r\n            this._element.nativeElement.value = inputValue;\r\n        }\r\n        this._previousValue = inputValue;\r\n    }\r\n    /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _setValueAndClose(event) {\r\n        if (event && event.source) {\r\n            this._clearPreviousSelectedOption(event.source);\r\n            this._setTriggerValue(event.source.value);\r\n            this._onChange(event.source.value);\r\n            this._element.nativeElement.focus();\r\n            this.autocomplete._emitSelectEvent(event.source);\r\n        }\r\n        this.closePanel();\r\n    }\r\n    /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     * @private\r\n     * @param {?} skip\r\n     * @return {?}\r\n     */\r\n    _clearPreviousSelectedOption(skip) {\r\n        this.autocomplete.options.forEach((/**\r\n         * @param {?} option\r\n         * @return {?}\r\n         */\r\n        option => {\r\n            if (option != skip && option.selected) {\r\n                option.deselect();\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _attachOverlay() {\r\n        if (!this.autocomplete) {\r\n            throw getMatAutocompleteMissingPanelError();\r\n        }\r\n        /** @type {?} */\r\n        let overlayRef = this._overlayRef;\r\n        if (!overlayRef) {\r\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\r\n            overlayRef = this._overlay.create(this._getOverlayConfig());\r\n            this._overlayRef = overlayRef;\r\n            // Use the `keydownEvents` in order to take advantage of\r\n            // the overlay event targeting provided by the CDK overlay.\r\n            overlayRef.keydownEvents().subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            event => {\r\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\r\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\r\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\r\n                    this._resetActiveItem();\r\n                    this._closeKeyEventStream.next();\r\n                    // We need to stop propagation, otherwise the event will eventually\r\n                    // reach the input itself and cause the overlay to be reopened.\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                }\r\n            }));\r\n            if (this._viewportRuler) {\r\n                this._viewportSubscription = this._viewportRuler.change().subscribe((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    if (this.panelOpen && overlayRef) {\r\n                        overlayRef.updateSize({ width: this._getPanelWidth() });\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        else {\r\n            // Update the trigger, panel width and direction, in case anything has changed.\r\n            this._positionStrategy.setOrigin(this._getConnectedElement());\r\n            overlayRef.updateSize({ width: this._getPanelWidth() });\r\n        }\r\n        if (overlayRef && !overlayRef.hasAttached()) {\r\n            overlayRef.attach(this._portal);\r\n            this._closingActionsSubscription = this._subscribeToClosingActions();\r\n        }\r\n        /** @type {?} */\r\n        const wasOpen = this.panelOpen;\r\n        this.autocomplete._setVisibility();\r\n        this.autocomplete._isOpen = this._overlayAttached = true;\r\n        // We need to do an extra `panelOpen` check in here, because the\r\n        // autocomplete won't be shown if there are no options.\r\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\r\n            this.autocomplete.opened.emit();\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getOverlayConfig() {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._getOverlayPosition(),\r\n            scrollStrategy: this._scrollStrategy(),\r\n            width: this._getPanelWidth(),\r\n            direction: this._dir\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getOverlayPosition() {\r\n        /** @type {?} */\r\n        const strategy = this._overlay.position()\r\n            .flexibleConnectedTo(this._getConnectedElement())\r\n            .withFlexibleDimensions(false)\r\n            .withPush(false);\r\n        this._setStrategyPositions(strategy);\r\n        this._positionStrategy = strategy;\r\n        return strategy;\r\n    }\r\n    /**\r\n     * Sets the positions on a position strategy based on the directive's input state.\r\n     * @private\r\n     * @param {?} positionStrategy\r\n     * @return {?}\r\n     */\r\n    _setStrategyPositions(positionStrategy) {\r\n        /** @type {?} */\r\n        const belowPosition = {\r\n            originX: 'start',\r\n            originY: 'bottom',\r\n            overlayX: 'start',\r\n            overlayY: 'top'\r\n        };\r\n        /** @type {?} */\r\n        const abovePosition = {\r\n            originX: 'start',\r\n            originY: 'top',\r\n            overlayX: 'start',\r\n            overlayY: 'bottom',\r\n            // The overlay edge connected to the trigger should have squared corners, while\r\n            // the opposite end has rounded corners. We apply a CSS class to swap the\r\n            // border-radius based on the overlay position.\r\n            panelClass: 'mat-autocomplete-panel-above'\r\n        };\r\n        /** @type {?} */\r\n        let positions;\r\n        if (this.position === 'above') {\r\n            positions = [abovePosition];\r\n        }\r\n        else if (this.position === 'below') {\r\n            positions = [belowPosition];\r\n        }\r\n        else {\r\n            positions = [belowPosition, abovePosition];\r\n        }\r\n        positionStrategy.withPositions(positions);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getConnectedElement() {\r\n        if (this.connectedTo) {\r\n            return this.connectedTo.elementRef;\r\n        }\r\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getPanelWidth() {\r\n        return this.autocomplete.panelWidth || this._getHostWidth();\r\n    }\r\n    /**\r\n     * Returns the width of the input element, so the panel width can match it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getHostWidth() {\r\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\r\n    }\r\n    /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _resetActiveItem() {\r\n        this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\r\n    }\r\n    /**\r\n     * Determines whether the panel can be opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _canOpen() {\r\n        /** @type {?} */\r\n        const element = this._element.nativeElement;\r\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\r\n    }\r\n}\r\nMatAutocompleteTrigger.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: `input[matAutocomplete], textarea[matAutocomplete]`,\r\n                host: {\r\n                    'class': 'mat-autocomplete-trigger',\r\n                    '[attr.autocomplete]': 'autocompleteAttribute',\r\n                    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\r\n                    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\r\n                    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\r\n                    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\r\n                    '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\r\n                    '[attr.aria-haspopup]': '!autocompleteDisabled',\r\n                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\r\n                    // a little earlier. This avoids issues where IE delays the focusing of the input.\r\n                    '(focusin)': '_handleFocus()',\r\n                    '(blur)': '_onTouched()',\r\n                    '(input)': '_handleInput($event)',\r\n                    '(keydown)': '_handleKeydown($event)',\r\n                },\r\n                exportAs: 'matAutocompleteTrigger',\r\n                providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatAutocompleteTrigger.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Overlay },\r\n    { type: ViewContainerRef },\r\n    { type: NgZone },\r\n    { type: ChangeDetectorRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: MatFormField, decorators: [{ type: Optional }, { type: Host }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n    { type: ViewportRuler }\r\n];\r\nMatAutocompleteTrigger.propDecorators = {\r\n    autocomplete: [{ type: Input, args: ['matAutocomplete',] }],\r\n    position: [{ type: Input, args: ['matAutocompletePosition',] }],\r\n    connectedTo: [{ type: Input, args: ['matAutocompleteConnectedTo',] }],\r\n    autocompleteAttribute: [{ type: Input, args: ['autocomplete',] }],\r\n    autocompleteDisabled: [{ type: Input, args: ['matAutocompleteDisabled',] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass MatAutocompleteModule {\r\n}\r\nMatAutocompleteModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [MatOptionModule, OverlayModule, MatCommonModule, CommonModule],\r\n                exports: [\r\n                    MatAutocomplete,\r\n                    MatOptionModule,\r\n                    MatAutocompleteTrigger,\r\n                    MatAutocompleteOrigin,\r\n                    MatCommonModule\r\n                ],\r\n                declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\r\n                providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin };\r\n\r\n"]}