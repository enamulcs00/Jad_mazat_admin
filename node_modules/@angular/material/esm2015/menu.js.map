{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm2015/menu.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmIC,iSAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkND,2BAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAucD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkDA,0CAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqmBD,aAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,iQAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAED,oCAcC","file":"menu.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { trigger, state, style, animate, transition, query, group } from '@angular/animations';\r\nimport { DomPortalOutlet, TemplatePortal } from '@angular/cdk/portal';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { ApplicationRef, ChangeDetectorRef, ComponentFactoryResolver, Directive, Inject, Injector, TemplateRef, ViewContainerRef, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, Input, HostListener, ContentChild, ContentChildren, EventEmitter, NgZone, Output, QueryList, ViewChild, Self, NgModule } from '@angular/core';\r\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\r\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\r\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW, HOME, END, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Animations used by the mat-menu component.\r\n * Animation duration and timing values are based on:\r\n * https://material.io/guidelines/components/menus.html#menus-usage\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst matMenuAnimations = {\r\n    /**\r\n     * This animation controls the menu panel's entry and exit from the page.\r\n     *\r\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\r\n     *\r\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\r\n     * delay to display the ripple.\r\n     */\r\n    transformMenu: trigger('transformMenu', [\r\n        state('void', style({\r\n            opacity: 0,\r\n            transform: 'scale(0.8)'\r\n        })),\r\n        transition('void => enter', group([\r\n            query('.mat-menu-content, .mat-mdc-menu-content', animate('100ms linear', style({\r\n                opacity: 1\r\n            }))),\r\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\r\n        ])),\r\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\r\n    ]),\r\n    /**\r\n     * This animation fades in the background color and content of the menu panel\r\n     * after its containing element is scaled in.\r\n     */\r\n    fadeInItems: trigger('fadeInItems', [\r\n        // TODO(crisbeto): this is inside the `transformMenu`\r\n        // now. Remove next time we do breaking changes.\r\n        state('showing', style({ opacity: 1 })),\r\n        transition('void => *', [\r\n            style({ opacity: 0 }),\r\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\r\n        ])\r\n    ])\r\n};\r\n/**\r\n * @deprecated\r\n * \\@breaking-change 8.0.0\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst fadeInItems = matMenuAnimations.fadeInItems;\r\n/**\r\n * @deprecated\r\n * \\@breaking-change 8.0.0\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst transformMenu = matMenuAnimations.transformMenu;\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Menu content that will be rendered lazily once the menu is opened.\r\n */\r\nclass MatMenuContent {\r\n    /**\r\n     * @param {?} _template\r\n     * @param {?} _componentFactoryResolver\r\n     * @param {?} _appRef\r\n     * @param {?} _injector\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} _document\r\n     * @param {?=} _changeDetectorRef\r\n     */\r\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {\r\n        this._template = _template;\r\n        this._componentFactoryResolver = _componentFactoryResolver;\r\n        this._appRef = _appRef;\r\n        this._injector = _injector;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._document = _document;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        /**\r\n         * Emits when the menu content has been attached.\r\n         */\r\n        this._attached = new Subject();\r\n    }\r\n    /**\r\n     * Attaches the content with a particular context.\r\n     * \\@docs-private\r\n     * @param {?=} context\r\n     * @return {?}\r\n     */\r\n    attach(context = {}) {\r\n        if (!this._portal) {\r\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\r\n        }\r\n        this.detach();\r\n        if (!this._outlet) {\r\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\r\n        }\r\n        /** @type {?} */\r\n        const element = this._template.elementRef.nativeElement;\r\n        // Because we support opening the same menu from different triggers (which in turn have their\r\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\r\n        // risk it staying attached to a pane that's no longer in the DOM.\r\n        (/** @type {?} */ (element.parentNode)).insertBefore(this._outlet.outletElement, element);\r\n        // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\r\n        // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\r\n        // by Angular. This causes the `@ContentChildren` for menu items within the menu to\r\n        // not be updated by Angular. By explicitly marking for check here, we tell Angular that\r\n        // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\r\n        // @breaking-change 9.0.0 Make change detector ref required\r\n        if (this._changeDetectorRef) {\r\n            this._changeDetectorRef.markForCheck();\r\n        }\r\n        this._portal.attach(this._outlet, context);\r\n        this._attached.next();\r\n    }\r\n    /**\r\n     * Detaches the content.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    detach() {\r\n        if (this._portal.isAttached) {\r\n            this._portal.detach();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._outlet) {\r\n            this._outlet.dispose();\r\n        }\r\n    }\r\n}\r\nMatMenuContent.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'ng-template[matMenuContent]'\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuContent.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: ComponentFactoryResolver },\r\n    { type: ApplicationRef },\r\n    { type: Injector },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: ChangeDetectorRef }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuMissingError() {\r\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\r\n\r\n    Example:\r\n      <mat-menu #menu=\"matMenu\"></mat-menu>\r\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's x-position value isn't valid.\r\n * In other words, it doesn't match 'before' or 'after'.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuInvalidPositionX() {\r\n    throw Error(`xPosition value must be either 'before' or after'.\r\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's y-position value isn't valid.\r\n * In other words, it doesn't match 'above' or 'below'.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuInvalidPositionY() {\r\n    throw Error(`yPosition value must be either 'above' or below'.\r\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Injection token used to provide the parent menu to menu-specific components.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// Boilerplate for applying mixins to MatMenuItem.\r\n/**\r\n * \\@docs-private\r\n */\r\nclass MatMenuItemBase {\r\n}\r\n/** @type {?} */\r\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\r\n/**\r\n * This directive is intended to be used inside an mat-menu tag.\r\n * It exists mostly to set the role attribute.\r\n */\r\nclass MatMenuItem extends _MatMenuItemMixinBase {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?=} document\r\n     * @param {?=} _focusMonitor\r\n     * @param {?=} _parentMenu\r\n     */\r\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\r\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\r\n        super();\r\n        this._elementRef = _elementRef;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._parentMenu = _parentMenu;\r\n        /**\r\n         * ARIA role for the menu item.\r\n         */\r\n        this.role = 'menuitem';\r\n        /**\r\n         * Stream that emits when the menu item is hovered.\r\n         */\r\n        this._hovered = new Subject();\r\n        /**\r\n         * Whether the menu item is highlighted.\r\n         */\r\n        this._highlighted = false;\r\n        /**\r\n         * Whether the menu item acts as a trigger for a sub-menu.\r\n         */\r\n        this._triggersSubmenu = false;\r\n        if (_focusMonitor) {\r\n            // Start monitoring the element so it gets the appropriate focused classes. We want\r\n            // to show the focus style for menu items only when the focus was not caused by a\r\n            // mouse or touch interaction.\r\n            _focusMonitor.monitor(this._elementRef, false);\r\n        }\r\n        if (_parentMenu && _parentMenu.addItem) {\r\n            _parentMenu.addItem(this);\r\n        }\r\n        this._document = document;\r\n    }\r\n    /**\r\n     * Focuses the menu item.\r\n     * @param {?=} origin\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    focus(origin = 'program', options) {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\r\n        }\r\n        else {\r\n            this._getHostElement().focus(options);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.stopMonitoring(this._elementRef);\r\n        }\r\n        if (this._parentMenu && this._parentMenu.removeItem) {\r\n            this._parentMenu.removeItem(this);\r\n        }\r\n        this._hovered.complete();\r\n    }\r\n    /**\r\n     * Used to set the `tabindex`.\r\n     * @return {?}\r\n     */\r\n    _getTabIndex() {\r\n        return this.disabled ? '-1' : '0';\r\n    }\r\n    /**\r\n     * Returns the host DOM element.\r\n     * @return {?}\r\n     */\r\n    _getHostElement() {\r\n        return this._elementRef.nativeElement;\r\n    }\r\n    /**\r\n     * Prevents the default element actions if it is disabled.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _checkDisabled(event) {\r\n        if (this.disabled) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n    }\r\n    /**\r\n     * Emits to the hover stream.\r\n     * @return {?}\r\n     */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _handleMouseEnter() {\r\n        this._hovered.next(this);\r\n    }\r\n    /**\r\n     * Gets the label to be used when determining whether the option should be focused.\r\n     * @return {?}\r\n     */\r\n    getLabel() {\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        const textNodeType = this._document ? this._document.TEXT_NODE : 3;\r\n        /** @type {?} */\r\n        let output = '';\r\n        if (element.childNodes) {\r\n            /** @type {?} */\r\n            const length = element.childNodes.length;\r\n            // Go through all the top-level text nodes and extract their text.\r\n            // We skip anything that's not a text node to prevent the text from\r\n            // being thrown off by something like an icon.\r\n            for (let i = 0; i < length; i++) {\r\n                if (element.childNodes[i].nodeType === textNodeType) {\r\n                    output += element.childNodes[i].textContent;\r\n                }\r\n            }\r\n        }\r\n        return output.trim();\r\n    }\r\n}\r\nMatMenuItem.decorators = [\r\n    { type: Component, args: [{selector: '[mat-menu-item]',\r\n                exportAs: 'matMenuItem',\r\n                inputs: ['disabled', 'disableRipple'],\r\n                host: {\r\n                    '[attr.role]': 'role',\r\n                    'class': 'mat-menu-item',\r\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\r\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\r\n                    '[attr.tabindex]': '_getTabIndex()',\r\n                    '[attr.aria-disabled]': 'disabled.toString()',\r\n                    '[attr.disabled]': 'disabled || null',\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\",\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuItem.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: FocusMonitor },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\r\n];\r\nMatMenuItem.propDecorators = {\r\n    role: [{ type: Input }],\r\n    _checkDisabled: [{ type: HostListener, args: ['click', ['$event'],] }],\r\n    _handleMouseEnter: [{ type: HostListener, args: ['mouseenter',] }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Injection token to be used to override the default options for `mat-menu`.\r\n * @type {?}\r\n */\r\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\r\n    return {\r\n        overlapTrigger: false,\r\n        xPosition: 'after',\r\n        yPosition: 'below',\r\n        backdropClass: 'cdk-overlay-transparent-backdrop',\r\n    };\r\n}\r\n/**\r\n * Start elevation for the menu panel.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst MAT_MENU_BASE_ELEVATION = 4;\r\n/**\r\n * Base class with all of the `MatMenu` functionality.\r\n */\r\n// tslint:disable-next-line:class-name\r\nclass _MatMenuBase {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _ngZone\r\n     * @param {?} _defaultOptions\r\n     */\r\n    constructor(_elementRef, _ngZone, _defaultOptions) {\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._xPosition = this._defaultOptions.xPosition;\r\n        this._yPosition = this._defaultOptions.yPosition;\r\n        /**\r\n         * Only the direct descendant menu items.\r\n         */\r\n        this._directDescendantItems = new QueryList();\r\n        /**\r\n         * Subscription to tab events on the menu panel\r\n         */\r\n        this._tabSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Config object to be passed into the menu's ngClass\r\n         */\r\n        this._classList = {};\r\n        /**\r\n         * Current state of the panel animation.\r\n         */\r\n        this._panelAnimationState = 'void';\r\n        /**\r\n         * Emits whenever an animation on the menu completes.\r\n         */\r\n        this._animationDone = new Subject();\r\n        /**\r\n         * Class to be added to the backdrop element.\r\n         */\r\n        this.backdropClass = this._defaultOptions.backdropClass;\r\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\r\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\r\n        /**\r\n         * Event emitted when the menu is closed.\r\n         */\r\n        this.closed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the menu is closed.\r\n         * @deprecated Switch to `closed` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        this.close = this.closed;\r\n    }\r\n    /**\r\n     * Position of the menu in the X axis.\r\n     * @return {?}\r\n     */\r\n    get xPosition() { return this._xPosition; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set xPosition(value) {\r\n        if (value !== 'before' && value !== 'after') {\r\n            throwMatMenuInvalidPositionX();\r\n        }\r\n        this._xPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * Position of the menu in the Y axis.\r\n     * @return {?}\r\n     */\r\n    get yPosition() { return this._yPosition; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set yPosition(value) {\r\n        if (value !== 'above' && value !== 'below') {\r\n            throwMatMenuInvalidPositionY();\r\n        }\r\n        this._yPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * Whether the menu should overlap its trigger.\r\n     * @return {?}\r\n     */\r\n    get overlapTrigger() { return this._overlapTrigger; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set overlapTrigger(value) {\r\n        this._overlapTrigger = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Whether the menu has a backdrop.\r\n     * @return {?}\r\n     */\r\n    get hasBackdrop() { return this._hasBackdrop; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set hasBackdrop(value) {\r\n        this._hasBackdrop = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @param {?} classes list of class names\r\n     * @return {?}\r\n     */\r\n    set panelClass(classes) {\r\n        /** @type {?} */\r\n        const previousPanelClass = this._previousPanelClass;\r\n        if (previousPanelClass && previousPanelClass.length) {\r\n            previousPanelClass.split(' ').forEach((/**\r\n             * @param {?} className\r\n             * @return {?}\r\n             */\r\n            (className) => {\r\n                this._classList[className] = false;\r\n            }));\r\n        }\r\n        this._previousPanelClass = classes;\r\n        if (classes && classes.length) {\r\n            classes.split(' ').forEach((/**\r\n             * @param {?} className\r\n             * @return {?}\r\n             */\r\n            (className) => {\r\n                this._classList[className] = true;\r\n            }));\r\n            this._elementRef.nativeElement.className = '';\r\n        }\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @deprecated Use `panelClass` instead.\r\n     * \\@breaking-change 8.0.0\r\n     * @return {?}\r\n     */\r\n    get classList() { return this.panelClass; }\r\n    /**\r\n     * @param {?} classes\r\n     * @return {?}\r\n     */\r\n    set classList(classes) { this.panelClass = classes; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this._updateDirectDescendants();\r\n        this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead();\r\n        this._tabSubscription = this._keyManager.tabOut.subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => this.closed.emit('tab')));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._directDescendantItems.destroy();\r\n        this._tabSubscription.unsubscribe();\r\n        this.closed.complete();\r\n    }\r\n    /**\r\n     * Stream that emits whenever the hovered menu item changes.\r\n     * @return {?}\r\n     */\r\n    _hovered() {\r\n        // Coerce the `changes` property because Angular types it as `Observable<any>`\r\n        /** @type {?} */\r\n        const itemChanges = (/** @type {?} */ (this._directDescendantItems.changes));\r\n        return itemChanges.pipe(startWith(this._directDescendantItems), switchMap((/**\r\n         * @param {?} items\r\n         * @return {?}\r\n         */\r\n        items => merge(...items.map((/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        (item) => item._hovered))))));\r\n    }\r\n    /*\r\n       * Registers a menu item with the menu.\r\n       * @docs-private\r\n       * @deprecated No longer being used. To be removed.\r\n       * @breaking-change 9.0.0\r\n       */\r\n    /**\r\n     * @param {?} _item\r\n     * @return {?}\r\n     */\r\n    addItem(_item) { }\r\n    /**\r\n     * Removes an item from the menu.\r\n     * \\@docs-private\r\n     * @deprecated No longer being used. To be removed.\r\n     * \\@breaking-change 9.0.0\r\n     * @param {?} _item\r\n     * @return {?}\r\n     */\r\n    removeItem(_item) { }\r\n    /**\r\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        /** @type {?} */\r\n        const manager = this._keyManager;\r\n        switch (keyCode) {\r\n            case ESCAPE:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case LEFT_ARROW:\r\n                if (this.parentMenu && this.direction === 'ltr') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case RIGHT_ARROW:\r\n                if (this.parentMenu && this.direction === 'rtl') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case HOME:\r\n            case END:\r\n                if (!hasModifierKey(event)) {\r\n                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\r\n                    event.preventDefault();\r\n                }\r\n                break;\r\n            default:\r\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\r\n                    manager.setFocusOrigin('keyboard');\r\n                }\r\n                manager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * Focus the first item in the menu.\r\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\r\n     * @return {?}\r\n     */\r\n    focusFirstItem(origin = 'program') {\r\n        /** @type {?} */\r\n        const manager = this._keyManager;\r\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\r\n        if (this.lazyContent) {\r\n            this._ngZone.onStable.asObservable()\r\n                .pipe(take(1))\r\n                .subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => manager.setFocusOrigin(origin).setFirstItemActive()));\r\n        }\r\n        else {\r\n            manager.setFocusOrigin(origin).setFirstItemActive();\r\n        }\r\n        // If there's no active item at this point, it means that all the items are disabled.\r\n        // Move focus to the menu panel so keyboard events like Escape still work. Also this will\r\n        // give _some_ feedback to screen readers.\r\n        if (!manager.activeItem && this._directDescendantItems.length) {\r\n            /** @type {?} */\r\n            let element = this._directDescendantItems.first._getHostElement().parentElement;\r\n            // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't\r\n            // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either\r\n            // because the panel is inside an `ng-template`. We work around it by starting from one of\r\n            // the items and walking up the DOM.\r\n            while (element) {\r\n                if (element.getAttribute('role') === 'menu') {\r\n                    element.focus();\r\n                    break;\r\n                }\r\n                else {\r\n                    element = element.parentElement;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\r\n     * the user to start from the first option when pressing the down arrow.\r\n     * @return {?}\r\n     */\r\n    resetActiveItem() {\r\n        this._keyManager.setActiveItem(-1);\r\n    }\r\n    /**\r\n     * Sets the menu panel elevation.\r\n     * @param {?} depth Number of parent menus that come before the menu.\r\n     * @return {?}\r\n     */\r\n    setElevation(depth) {\r\n        // The elevation starts at the base and increases by one for each level.\r\n        /** @type {?} */\r\n        const newElevation = `mat-elevation-z${MAT_MENU_BASE_ELEVATION + depth}`;\r\n        /** @type {?} */\r\n        const customElevation = Object.keys(this._classList).find((/**\r\n         * @param {?} c\r\n         * @return {?}\r\n         */\r\n        c => c.startsWith('mat-elevation-z')));\r\n        if (!customElevation || customElevation === this._previousElevation) {\r\n            if (this._previousElevation) {\r\n                this._classList[this._previousElevation] = false;\r\n            }\r\n            this._classList[newElevation] = true;\r\n            this._previousElevation = newElevation;\r\n        }\r\n    }\r\n    /**\r\n     * Adds classes to the menu panel based on its position. Can be used by\r\n     * consumers to add specific styling based on the position.\r\n     * \\@docs-private\r\n     * @param {?=} posX Position of the menu along the x axis.\r\n     * @param {?=} posY Position of the menu along the y axis.\r\n     * @return {?}\r\n     */\r\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\r\n        /** @type {?} */\r\n        const classes = this._classList;\r\n        classes['mat-menu-before'] = posX === 'before';\r\n        classes['mat-menu-after'] = posX === 'after';\r\n        classes['mat-menu-above'] = posY === 'above';\r\n        classes['mat-menu-below'] = posY === 'below';\r\n    }\r\n    /**\r\n     * Starts the enter animation.\r\n     * @return {?}\r\n     */\r\n    _startAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\r\n        this._panelAnimationState = 'enter';\r\n    }\r\n    /**\r\n     * Resets the panel animation to its initial state.\r\n     * @return {?}\r\n     */\r\n    _resetAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _startAnimation.\r\n        this._panelAnimationState = 'void';\r\n    }\r\n    /**\r\n     * Callback that is invoked when the panel animation completes.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onAnimationDone(event) {\r\n        this._animationDone.next(event);\r\n        this._isAnimating = false;\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onAnimationStart(event) {\r\n        this._isAnimating = true;\r\n        // Scroll the content element to the top as soon as the animation starts. This is necessary,\r\n        // because we move focus to the first item while it's still being animated, which can throw\r\n        // the browser off when it determines the scroll position. Alternatively we can move focus\r\n        // when the animation is done, however moving focus asynchronously will interrupt screen\r\n        // readers which are in the process of reading out the menu already. We take the `element`\r\n        // from the `event` since we can't use a `ViewChild` to access the pane.\r\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\r\n            event.element.scrollTop = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\r\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\r\n     * items that are part of child menus, and using a custom way of registering items is unreliable\r\n     * when it comes to maintaining the item order.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateDirectDescendants() {\r\n        this._allItems.changes\r\n            .pipe(startWith(this._allItems))\r\n            .subscribe((/**\r\n         * @param {?} items\r\n         * @return {?}\r\n         */\r\n        (items) => {\r\n            this._directDescendantItems.reset(items.filter((/**\r\n             * @param {?} item\r\n             * @return {?}\r\n             */\r\n            item => item._parentMenu === this)));\r\n            this._directDescendantItems.notifyOnChanges();\r\n        }));\r\n    }\r\n}\r\n/** @nocollapse */\r\n_MatMenuBase.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\r\n];\r\n_MatMenuBase.propDecorators = {\r\n    _allItems: [{ type: ContentChildren, args: [MatMenuItem, { descendants: true },] }],\r\n    backdropClass: [{ type: Input }],\r\n    xPosition: [{ type: Input }],\r\n    yPosition: [{ type: Input }],\r\n    templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],\r\n    items: [{ type: ContentChildren, args: [MatMenuItem,] }],\r\n    lazyContent: [{ type: ContentChild, args: [MatMenuContent, { static: false },] }],\r\n    overlapTrigger: [{ type: Input }],\r\n    hasBackdrop: [{ type: Input }],\r\n    panelClass: [{ type: Input, args: ['class',] }],\r\n    classList: [{ type: Input }],\r\n    closed: [{ type: Output }],\r\n    close: [{ type: Output }]\r\n};\r\n/**\r\n * \\@docs-private We show the \"_MatMenu\" class as \"MatMenu\" in the docs.\r\n */\r\nclass MatMenu extends _MatMenuBase {\r\n}\r\n// Note on the weird inheritance setup: we need three classes, because the MDC-based menu has to\r\n// extend `MatMenu`, however keeping a reference to it will cause the inlined template and styles\r\n// to be retained as well. The MDC menu also has to provide itself as a `MatMenu` in order for\r\n// queries and DI to work correctly, while still not referencing the actual menu class.\r\n// Class responsibility is split up as follows:\r\n// * _MatMenuBase - provides all the functionality without any of the Angular metadata.\r\n// * MatMenu - keeps the same name symbol name as the current menu and\r\n// is used as a provider for DI and query purposes.\r\n// * _MatMenu - the actual menu component implementation with the Angular metadata that should\r\n// be tree shaken away for MDC.\r\n/**\r\n * \\@docs-public MatMenu\r\n */\r\n// tslint:disable-next-line:class-name\r\nclass _MatMenu extends MatMenu {\r\n    /**\r\n     * @param {?} elementRef\r\n     * @param {?} ngZone\r\n     * @param {?} defaultOptions\r\n     */\r\n    constructor(elementRef, ngZone, defaultOptions) {\r\n        super(elementRef, ngZone, defaultOptions);\r\n    }\r\n}\r\n_MatMenu.decorators = [\r\n    { type: Component, args: [{selector: 'mat-menu',\r\n                template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_onAnimationStart($event)\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\r\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                exportAs: 'matMenu',\r\n                animations: [\r\n                    matMenuAnimations.transformMenu,\r\n                    matMenuAnimations.fadeInItems\r\n                ],\r\n                providers: [\r\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu },\r\n                    { provide: MatMenu, useExisting: _MatMenu }\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\n_MatMenu.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Injection token that determines the scroll handling while the menu is open.\r\n * @type {?}\r\n */\r\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return (/**\r\n     * @return {?}\r\n     */\r\n    () => overlay.scrollStrategies.reposition());\r\n}\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_MENU_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/**\r\n * Default top padding of the menu panel.\r\n * @type {?}\r\n */\r\nconst MENU_PANEL_TOP_PADDING = 8;\r\n/**\r\n * Options for binding a passive event listener.\r\n * @type {?}\r\n */\r\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\r\n// TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors\r\n/**\r\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\r\n * responsible for toggling the display of the provided menu instance.\r\n */\r\nclass MatMenuTrigger {\r\n    /**\r\n     * @param {?} _overlay\r\n     * @param {?} _element\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} scrollStrategy\r\n     * @param {?} _parentMenu\r\n     * @param {?} _menuItemInstance\r\n     * @param {?} _dir\r\n     * @param {?=} _focusMonitor\r\n     */\r\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\r\n        this._overlay = _overlay;\r\n        this._element = _element;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._parentMenu = _parentMenu;\r\n        this._menuItemInstance = _menuItemInstance;\r\n        this._dir = _dir;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._overlayRef = null;\r\n        this._menuOpen = false;\r\n        this._closingActionsSubscription = Subscription.EMPTY;\r\n        this._hoverSubscription = Subscription.EMPTY;\r\n        this._menuCloseSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Handles touch start events on the trigger.\r\n         * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\r\n         */\r\n        this._handleTouchStart = (/**\r\n         * @return {?}\r\n         */\r\n        () => this._openedBy = 'touch');\r\n        // Tracking input type is necessary so it's possible to only auto-focus\r\n        // the first item of the list when the menu is opened via the keyboard\r\n        this._openedBy = null;\r\n        /**\r\n         * Whether focus should be restored when the menu is closed.\r\n         * Note that disabling this option can have accessibility implications\r\n         * and it's up to you to manage focus, if you decide to turn it off.\r\n         */\r\n        this.restoreFocus = true;\r\n        /**\r\n         * Event emitted when the associated menu is opened.\r\n         */\r\n        this.menuOpened = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is opened.\r\n         * @deprecated Switch to `menuOpened` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onMenuOpen = this.menuOpened;\r\n        /**\r\n         * Event emitted when the associated menu is closed.\r\n         */\r\n        this.menuClosed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is closed.\r\n         * @deprecated Switch to `menuClosed` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onMenuClose = this.menuClosed;\r\n        _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\r\n        if (_menuItemInstance) {\r\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\r\n        }\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    /**\r\n     * @deprecated\r\n     * \\@breaking-change 8.0.0\r\n     * @return {?}\r\n     */\r\n    get _deprecatedMatMenuTriggerFor() { return this.menu; }\r\n    /**\r\n     * @param {?} v\r\n     * @return {?}\r\n     */\r\n    set _deprecatedMatMenuTriggerFor(v) {\r\n        this.menu = v;\r\n    }\r\n    /**\r\n     * References the menu instance that the trigger is associated with.\r\n     * @return {?}\r\n     */\r\n    get menu() { return this._menu; }\r\n    /**\r\n     * @param {?} menu\r\n     * @return {?}\r\n     */\r\n    set menu(menu) {\r\n        if (menu === this._menu) {\r\n            return;\r\n        }\r\n        this._menu = menu;\r\n        this._menuCloseSubscription.unsubscribe();\r\n        if (menu) {\r\n            this._menuCloseSubscription = menu.close.asObservable().subscribe((/**\r\n             * @param {?} reason\r\n             * @return {?}\r\n             */\r\n            reason => {\r\n                this._destroyMenu();\r\n                // If a click closed the menu, we should close the entire chain of nested menus.\r\n                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\r\n                    this._parentMenu.closed.emit(reason);\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this._checkMenu();\r\n        this._handleHover();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._overlayRef) {\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n        this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\r\n        this._menuCloseSubscription.unsubscribe();\r\n        this._closingActionsSubscription.unsubscribe();\r\n        this._hoverSubscription.unsubscribe();\r\n    }\r\n    /**\r\n     * Whether the menu is open.\r\n     * @return {?}\r\n     */\r\n    get menuOpen() {\r\n        return this._menuOpen;\r\n    }\r\n    /**\r\n     * The text direction of the containing app.\r\n     * @return {?}\r\n     */\r\n    get dir() {\r\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\r\n    }\r\n    /**\r\n     * Whether the menu triggers a sub-menu or a top-level one.\r\n     * @return {?}\r\n     */\r\n    triggersSubmenu() {\r\n        return !!(this._menuItemInstance && this._parentMenu);\r\n    }\r\n    /**\r\n     * Toggles the menu between the open and closed states.\r\n     * @return {?}\r\n     */\r\n    toggleMenu() {\r\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\r\n    }\r\n    /**\r\n     * Opens the menu.\r\n     * @return {?}\r\n     */\r\n    openMenu() {\r\n        if (this._menuOpen) {\r\n            return;\r\n        }\r\n        this._checkMenu();\r\n        /** @type {?} */\r\n        const overlayRef = this._createOverlay();\r\n        /** @type {?} */\r\n        const overlayConfig = overlayRef.getConfig();\r\n        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));\r\n        overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :\r\n            this.menu.hasBackdrop;\r\n        overlayRef.attach(this._getPortal());\r\n        if (this.menu.lazyContent) {\r\n            this.menu.lazyContent.attach(this.menuData);\r\n        }\r\n        this._closingActionsSubscription = this._menuClosingActions().subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => this.closeMenu()));\r\n        this._initMenu();\r\n        if (this.menu instanceof MatMenu) {\r\n            this.menu._startAnimation();\r\n        }\r\n    }\r\n    /**\r\n     * Closes the menu.\r\n     * @return {?}\r\n     */\r\n    closeMenu() {\r\n        this.menu.close.emit();\r\n    }\r\n    /**\r\n     * Focuses the menu trigger.\r\n     * @param {?=} origin Source of the menu trigger's focus.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    focus(origin = 'program', options) {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.focusVia(this._element, origin, options);\r\n        }\r\n        else {\r\n            this._element.nativeElement.focus(options);\r\n        }\r\n    }\r\n    /**\r\n     * Closes the menu and does the necessary cleanup.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _destroyMenu() {\r\n        if (!this._overlayRef || !this.menuOpen) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const menu = this.menu;\r\n        this._closingActionsSubscription.unsubscribe();\r\n        this._overlayRef.detach();\r\n        if (menu instanceof MatMenu) {\r\n            menu._resetAnimation();\r\n            if (menu.lazyContent) {\r\n                // Wait for the exit animation to finish before detaching the content.\r\n                menu._animationDone\r\n                    .pipe(filter((/**\r\n                 * @param {?} event\r\n                 * @return {?}\r\n                 */\r\n                event => event.toState === 'void')), take(1), \r\n                // Interrupt if the content got re-attached.\r\n                takeUntil(menu.lazyContent._attached))\r\n                    .subscribe({\r\n                    next: (/**\r\n                     * @return {?}\r\n                     */\r\n                    () => (/** @type {?} */ (menu.lazyContent)).detach()),\r\n                    // No matter whether the content got re-attached, reset the menu.\r\n                    complete: (/**\r\n                     * @return {?}\r\n                     */\r\n                    () => this._setIsMenuOpen(false))\r\n                });\r\n            }\r\n            else {\r\n                this._setIsMenuOpen(false);\r\n            }\r\n        }\r\n        else {\r\n            this._setIsMenuOpen(false);\r\n            if (menu.lazyContent) {\r\n                menu.lazyContent.detach();\r\n            }\r\n        }\r\n        this._restoreFocus();\r\n    }\r\n    /**\r\n     * This method sets the menu state to open and focuses the first item if\r\n     * the menu was opened via the keyboard.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _initMenu() {\r\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\r\n        this.menu.direction = this.dir;\r\n        this._setMenuElevation();\r\n        this._setIsMenuOpen(true);\r\n        this.menu.focusFirstItem(this._openedBy || 'program');\r\n    }\r\n    /**\r\n     * Updates the menu elevation based on the amount of parent menus that it has.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _setMenuElevation() {\r\n        if (this.menu.setElevation) {\r\n            /** @type {?} */\r\n            let depth = 0;\r\n            /** @type {?} */\r\n            let parentMenu = this.menu.parentMenu;\r\n            while (parentMenu) {\r\n                depth++;\r\n                parentMenu = parentMenu.parentMenu;\r\n            }\r\n            this.menu.setElevation(depth);\r\n        }\r\n    }\r\n    /**\r\n     * Restores focus to the element that was focused before the menu was open.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _restoreFocus() {\r\n        // We should reset focus if the user is navigating using a keyboard or\r\n        // if we have a top-level trigger which might cause focus to be lost\r\n        // when clicking on the backdrop.\r\n        if (this.restoreFocus) {\r\n            if (!this._openedBy) {\r\n                // Note that the focus style will show up both for `program` and\r\n                // `keyboard` so we don't have to specify which one it is.\r\n                this.focus();\r\n            }\r\n            else if (!this.triggersSubmenu()) {\r\n                this.focus(this._openedBy);\r\n            }\r\n        }\r\n        this._openedBy = null;\r\n    }\r\n    // set state rather than toggle to support triggers sharing a menu\r\n    /**\r\n     * @private\r\n     * @param {?} isOpen\r\n     * @return {?}\r\n     */\r\n    _setIsMenuOpen(isOpen) {\r\n        this._menuOpen = isOpen;\r\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\r\n        if (this.triggersSubmenu()) {\r\n            this._menuItemInstance._highlighted = isOpen;\r\n        }\r\n    }\r\n    /**\r\n     * This method checks that a valid instance of MatMenu has been passed into\r\n     * matMenuTriggerFor. If not, an exception is thrown.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _checkMenu() {\r\n        if (!this.menu) {\r\n            throwMatMenuMissingError();\r\n        }\r\n    }\r\n    /**\r\n     * This method creates the overlay from the provided menu's template and saves its\r\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createOverlay() {\r\n        if (!this._overlayRef) {\r\n            /** @type {?} */\r\n            const config = this._getOverlayConfig();\r\n            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));\r\n            this._overlayRef = this._overlay.create(config);\r\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\r\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\r\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\r\n            this._overlayRef.keydownEvents().subscribe();\r\n        }\r\n        return this._overlayRef;\r\n    }\r\n    /**\r\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\r\n     * @private\r\n     * @return {?} OverlayConfig\r\n     */\r\n    _getOverlayConfig() {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._overlay.position()\r\n                .flexibleConnectedTo(this._element)\r\n                .withLockedPosition()\r\n                .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\r\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\r\n            scrollStrategy: this._scrollStrategy(),\r\n            direction: this._dir\r\n        });\r\n    }\r\n    /**\r\n     * Listens to changes in the position of the overlay and sets the correct classes\r\n     * on the menu based on the new position. This ensures the animation origin is always\r\n     * correct, even if a fallback position is used for the overlay.\r\n     * @private\r\n     * @param {?} position\r\n     * @return {?}\r\n     */\r\n    _subscribeToPositions(position) {\r\n        if (this.menu.setPositionClasses) {\r\n            position.positionChanges.subscribe((/**\r\n             * @param {?} change\r\n             * @return {?}\r\n             */\r\n            change => {\r\n                /** @type {?} */\r\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\r\n                /** @type {?} */\r\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\r\n                (/** @type {?} */ (this.menu.setPositionClasses))(posX, posY);\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Sets the appropriate positions on a position strategy\r\n     * so the overlay connects with the trigger correctly.\r\n     * @private\r\n     * @param {?} positionStrategy Strategy whose position to update.\r\n     * @return {?}\r\n     */\r\n    _setPosition(positionStrategy) {\r\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\r\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\r\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\r\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\r\n        /** @type {?} */\r\n        let offsetY = 0;\r\n        if (this.triggersSubmenu()) {\r\n            // When the menu is a sub-menu, it should always align itself\r\n            // to the edges of the trigger, instead of overlapping it.\r\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\r\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\r\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\r\n        }\r\n        else if (!this.menu.overlapTrigger) {\r\n            originY = overlayY === 'top' ? 'bottom' : 'top';\r\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\r\n        }\r\n        positionStrategy.withPositions([\r\n            { originX, originY, overlayX, overlayY, offsetY },\r\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\r\n            {\r\n                originX,\r\n                originY: originFallbackY,\r\n                overlayX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            },\r\n            {\r\n                originX: originFallbackX,\r\n                originY: originFallbackY,\r\n                overlayX: overlayFallbackX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            }\r\n        ]);\r\n    }\r\n    /**\r\n     * Returns a stream that emits whenever an action that should close the menu occurs.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _menuClosingActions() {\r\n        /** @type {?} */\r\n        const backdrop = (/** @type {?} */ (this._overlayRef)).backdropClick();\r\n        /** @type {?} */\r\n        const detachments = (/** @type {?} */ (this._overlayRef)).detachments();\r\n        /** @type {?} */\r\n        const parentClose = this._parentMenu ? this._parentMenu.closed : of();\r\n        /** @type {?} */\r\n        const hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter((/**\r\n         * @param {?} active\r\n         * @return {?}\r\n         */\r\n        active => active !== this._menuItemInstance)), filter((/**\r\n         * @return {?}\r\n         */\r\n        () => this._menuOpen))) : of();\r\n        return merge(backdrop, parentClose, hover, detachments);\r\n    }\r\n    /**\r\n     * Handles mouse presses on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleMousedown(event) {\r\n        if (!isFakeMousedownFromScreenReader(event)) {\r\n            // Since right or middle button clicks won't trigger the `click` event,\r\n            // we shouldn't consider the menu as opened by mouse in those cases.\r\n            this._openedBy = event.button === 0 ? 'mouse' : null;\r\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\r\n            // we should prevent focus from moving onto it via click to avoid the\r\n            // highlight from lingering on the menu item.\r\n            if (this.triggersSubmenu()) {\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles key presses on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\r\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\r\n            this.openMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Handles click events on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleClick(event) {\r\n        if (this.triggersSubmenu()) {\r\n            // Stop event propagation to avoid closing the parent menu.\r\n            event.stopPropagation();\r\n            this.openMenu();\r\n        }\r\n        else {\r\n            this.toggleMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Handles the cases where the user hovers over the trigger.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _handleHover() {\r\n        // Subscribe to changes in the hovered item in order to toggle the panel.\r\n        if (!this.triggersSubmenu()) {\r\n            return;\r\n        }\r\n        this._hoverSubscription = this._parentMenu._hovered()\r\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\r\n            // with different data and triggers), we have to delay it by a tick to ensure that\r\n            // it won't be closed immediately after it is opened.\r\n            .pipe(filter((/**\r\n         * @param {?} active\r\n         * @return {?}\r\n         */\r\n        active => active === this._menuItemInstance && !active.disabled)), delay(0, asapScheduler))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._openedBy = 'mouse';\r\n            // If the same menu is used between multiple triggers, it might still be animating\r\n            // while the new trigger tries to re-open it. Wait for the animation to finish\r\n            // before doing so. Also interrupt if the user moves to another item.\r\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\r\n                // We need the `delay(0)` here in order to avoid\r\n                // 'changed after checked' errors in some cases. See #12194.\r\n                this.menu._animationDone\r\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))\r\n                    .subscribe((/**\r\n                 * @return {?}\r\n                 */\r\n                () => this.openMenu()));\r\n            }\r\n            else {\r\n                this.openMenu();\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Gets the portal that should be attached to the overlay.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getPortal() {\r\n        // Note that we can avoid this check by keeping the portal on the menu panel.\r\n        // While it would be cleaner, we'd have to introduce another required method on\r\n        // `MatMenuPanel`, making it harder to consume.\r\n        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {\r\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\r\n        }\r\n        return this._portal;\r\n    }\r\n}\r\nMatMenuTrigger.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\r\n                host: {\r\n                    'class': 'mat-menu-trigger',\r\n                    'aria-haspopup': 'true',\r\n                    '[attr.aria-expanded]': 'menuOpen || null',\r\n                    '(mousedown)': '_handleMousedown($event)',\r\n                    '(keydown)': '_handleKeydown($event)',\r\n                    '(click)': '_handleClick($event)',\r\n                },\r\n                exportAs: 'matMenuTrigger'\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuTrigger.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: ElementRef },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\r\n    { type: MatMenu, decorators: [{ type: Optional }] },\r\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: FocusMonitor }\r\n];\r\nMatMenuTrigger.propDecorators = {\r\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\r\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\r\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\r\n    restoreFocus: [{ type: Input, args: ['matMenuTriggerRestoreFocus',] }],\r\n    menuOpened: [{ type: Output }],\r\n    onMenuOpen: [{ type: Output }],\r\n    menuClosed: [{ type: Output }],\r\n    onMenuClose: [{ type: Output }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Used by both the current `MatMenuModule` and the MDC `MatMenuModule`\r\n * to declare the menu-related directives.\r\n */\r\n// tslint:disable-next-line:class-name\r\nclass _MatMenuDirectivesModule {\r\n}\r\n_MatMenuDirectivesModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                exports: [MatMenuTrigger, MatMenuContent, MatCommonModule],\r\n                declarations: [MatMenuTrigger, MatMenuContent],\r\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\r\n            },] },\r\n];\r\nclass MatMenuModule {\r\n}\r\nMatMenuModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    MatRippleModule,\r\n                    OverlayModule,\r\n                    _MatMenuDirectivesModule,\r\n                ],\r\n                exports: [_MatMenu, MatMenuItem, _MatMenuDirectivesModule],\r\n                declarations: [_MatMenu, MatMenuItem],\r\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatMenu, MAT_MENU_DEFAULT_OPTIONS, _MatMenu, _MatMenuBase, MatMenuItem, MatMenuTrigger, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_PANEL, _MatMenuDirectivesModule, MatMenuModule, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as a22, MAT_MENU_SCROLL_STRATEGY_FACTORY as b22, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as c22 };\r\n\r\n"]}