{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm2015/input.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCC,sCAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAocD,aA4BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BD,8BAmBC","file":"input.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\r\nimport { Directive, Input, InjectionToken, ElementRef, Inject, NgZone, Optional, Self, NgModule } from '@angular/core';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\r\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\r\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\r\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\r\nimport { Subject } from 'rxjs';\r\nimport { CommonModule } from '@angular/common';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Directive to automatically resize a textarea to fit its content.\r\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\r\n * \\@breaking-change 8.0.0\r\n */\r\nclass MatTextareaAutosize extends CdkTextareaAutosize {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get matAutosizeMinRows() { return this.minRows; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set matAutosizeMinRows(value) { this.minRows = value; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get matAutosizeMaxRows() { return this.maxRows; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set matAutosizeMaxRows(value) { this.maxRows = value; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get matAutosize() { return this.enabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set matAutosize(value) { this.enabled = value; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get matTextareaAutosize() { return this.enabled; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set matTextareaAutosize(value) { this.enabled = value; }\r\n}\r\nMatTextareaAutosize.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\r\n                exportAs: 'matTextareaAutosize',\r\n                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\r\n                host: {\r\n                    'class': 'cdk-textarea-autosize mat-autosize',\r\n                    // Textarea elements that have the directive applied should have a single row by default.\r\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\r\n                    'rows': '1',\r\n                    '(input)': '_noopInputHandler()',\r\n                },\r\n            },] },\r\n];\r\nMatTextareaAutosize.propDecorators = {\r\n    matAutosizeMinRows: [{ type: Input }],\r\n    matAutosizeMaxRows: [{ type: Input }],\r\n    matAutosize: [{ type: Input, args: ['mat-autosize',] }],\r\n    matTextareaAutosize: [{ type: Input }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * \\@docs-private\r\n * @param {?} type\r\n * @return {?}\r\n */\r\nfunction getMatInputUnsupportedTypeError(type) {\r\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\r\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\r\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\r\n * value to them.\r\n * @type {?}\r\n */\r\nconst MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\r\n/** @type {?} */\r\nconst MAT_INPUT_INVALID_TYPES = [\r\n    'button',\r\n    'checkbox',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'submit'\r\n];\r\n/** @type {?} */\r\nlet nextUniqueId = 0;\r\n// Boilerplate for applying mixins to MatInput.\r\n/**\r\n * \\@docs-private\r\n */\r\nclass MatInputBase {\r\n    /**\r\n     * @param {?} _defaultErrorStateMatcher\r\n     * @param {?} _parentForm\r\n     * @param {?} _parentFormGroup\r\n     * @param {?} ngControl\r\n     */\r\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\r\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\r\n        this._parentForm = _parentForm;\r\n        this._parentFormGroup = _parentFormGroup;\r\n        this.ngControl = ngControl;\r\n    }\r\n}\r\n/** @type {?} */\r\nconst _MatInputMixinBase = mixinErrorState(MatInputBase);\r\n/**\r\n * Directive that allows a native input to work inside a `MatFormField`.\r\n */\r\nclass MatInput extends _MatInputMixinBase {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _platform\r\n     * @param {?} ngControl\r\n     * @param {?} _parentForm\r\n     * @param {?} _parentFormGroup\r\n     * @param {?} _defaultErrorStateMatcher\r\n     * @param {?} inputValueAccessor\r\n     * @param {?} _autofillMonitor\r\n     * @param {?} ngZone\r\n     */\r\n    constructor(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\r\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\r\n        this._elementRef = _elementRef;\r\n        this._platform = _platform;\r\n        this.ngControl = ngControl;\r\n        this._autofillMonitor = _autofillMonitor;\r\n        this._uid = `mat-input-${nextUniqueId++}`;\r\n        /**\r\n         * Whether the component is being rendered on the server.\r\n         */\r\n        this._isServer = false;\r\n        /**\r\n         * Whether the component is a native html select.\r\n         */\r\n        this._isNativeSelect = false;\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        this.focused = false;\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        this.stateChanges = new Subject();\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        this.controlType = 'mat-input';\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        this.autofilled = false;\r\n        this._disabled = false;\r\n        this._required = false;\r\n        this._type = 'text';\r\n        this._readonly = false;\r\n        this._neverEmptyInputTypes = [\r\n            'date',\r\n            'datetime',\r\n            'datetime-local',\r\n            'month',\r\n            'time',\r\n            'week'\r\n        ].filter((/**\r\n         * @param {?} t\r\n         * @return {?}\r\n         */\r\n        t => getSupportedInputTypes().has(t)));\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        // If no input value accessor was explicitly specified, use the element as the input value\r\n        // accessor.\r\n        this._inputValueAccessor = inputValueAccessor || element;\r\n        this._previousNativeValue = this.value;\r\n        // Force setter to be called in case id was not specified.\r\n        this.id = this.id;\r\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\r\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\r\n        // exists on iOS, we only bother to install the listener on iOS.\r\n        if (_platform.IOS) {\r\n            ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                _elementRef.nativeElement.addEventListener('keyup', (/**\r\n                 * @param {?} event\r\n                 * @return {?}\r\n                 */\r\n                (event) => {\r\n                    /** @type {?} */\r\n                    let el = (/** @type {?} */ (event.target));\r\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\r\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\r\n                        // `1, 1` fixes it for the first time that you type text and\r\n                        // then hold delete. Toggling to `1, 1` and then back to\r\n                        // `0, 0` seems to completely fix it.\r\n                        el.setSelectionRange(1, 1);\r\n                        el.setSelectionRange(0, 0);\r\n                    }\r\n                }));\r\n            }));\r\n        }\r\n        this._isServer = !this._platform.isBrowser;\r\n        this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\r\n        if (this._isNativeSelect) {\r\n            this.controlType = ((/** @type {?} */ (element))).multiple ? 'mat-native-select-multiple' :\r\n                'mat-native-select';\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get disabled() {\r\n        if (this.ngControl && this.ngControl.disabled !== null) {\r\n            return this.ngControl.disabled;\r\n        }\r\n        return this._disabled;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        // Browsers may not fire the blur event if the input is disabled too quickly.\r\n        // Reset from here to ensure that the element doesn't become stuck.\r\n        if (this.focused) {\r\n            this.focused = false;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get id() { return this._id; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set id(value) { this._id = value || this._uid; }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get required() { return this._required; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set required(value) { this._required = coerceBooleanProperty(value); }\r\n    /**\r\n     * Input type of the element.\r\n     * @return {?}\r\n     */\r\n    get type() { return this._type; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set type(value) {\r\n        this._type = value || 'text';\r\n        this._validateType();\r\n        // When using Angular inputs, developers are no longer able to set the properties on the native\r\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\r\n        // with the native property. Textarea elements don't support the type property or attribute.\r\n        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\r\n            ((/** @type {?} */ (this._elementRef.nativeElement))).type = this._type;\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get value() { return this._inputValueAccessor.value; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set value(value) {\r\n        if (value !== this.value) {\r\n            this._inputValueAccessor.value = value;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /**\r\n     * Whether the element is readonly.\r\n     * @return {?}\r\n     */\r\n    get readonly() { return this._readonly; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set readonly(value) { this._readonly = coerceBooleanProperty(value); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            event => {\r\n                this.autofilled = event.isAutofilled;\r\n                this.stateChanges.next();\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnChanges() {\r\n        this.stateChanges.next();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this.stateChanges.complete();\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngDoCheck() {\r\n        if (this.ngControl) {\r\n            // We need to re-evaluate this on every change detection cycle, because there are some\r\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\r\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\r\n            this.updateErrorState();\r\n        }\r\n        // We need to dirty-check the native element's value, because there are some cases where\r\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\r\n        // updating the value using `emitEvent: false`).\r\n        this._dirtyCheckNativeValue();\r\n    }\r\n    /**\r\n     * Focuses the input.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    focus(options) {\r\n        this._elementRef.nativeElement.focus(options);\r\n    }\r\n    /**\r\n     * Callback for the cases where the focused state of the input changes.\r\n     * @param {?} isFocused\r\n     * @return {?}\r\n     */\r\n    _focusChanged(isFocused) {\r\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\r\n            this.focused = isFocused;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    _onInput() {\r\n        // This is a noop function and is used to let Angular know whenever the value changes.\r\n        // Angular will run a new change detection each time the `input` event has been dispatched.\r\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\r\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\r\n        // value changes and will not disappear.\r\n        // Listening to the input event wouldn't be necessary when the input is using the\r\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\r\n    }\r\n    /**\r\n     * Does some manual dirty checking on the native input `value` property.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    _dirtyCheckNativeValue() {\r\n        /** @type {?} */\r\n        const newValue = this._elementRef.nativeElement.value;\r\n        if (this._previousNativeValue !== newValue) {\r\n            this._previousNativeValue = newValue;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /**\r\n     * Make sure the input is a supported type.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    _validateType() {\r\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\r\n            throw getMatInputUnsupportedTypeError(this._type);\r\n        }\r\n    }\r\n    /**\r\n     * Checks whether the input type is one of the types that are never empty.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    _isNeverEmpty() {\r\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\r\n    }\r\n    /**\r\n     * Checks whether the input is invalid based on the native validation.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    _isBadInput() {\r\n        // The `validity` property won't be present on platform-server.\r\n        /** @type {?} */\r\n        let validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;\r\n        return validity && validity.badInput;\r\n    }\r\n    /**\r\n     * Determines if the component host is a textarea.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    _isTextarea() {\r\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get empty() {\r\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\r\n            !this.autofilled;\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    get shouldLabelFloat() {\r\n        if (this._isNativeSelect) {\r\n            // For a single-selection `<select>`, the label should float when the selected option has\r\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\r\n            // overlapping the label with the options.\r\n            /** @type {?} */\r\n            const selectElement = (/** @type {?} */ (this._elementRef.nativeElement));\r\n            /** @type {?} */\r\n            const firstOption = selectElement.options[0];\r\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\r\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\r\n            return this.focused || selectElement.multiple || !this.empty ||\r\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\r\n        }\r\n        else {\r\n            return this.focused || !this.empty;\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @param {?} ids\r\n     * @return {?}\r\n     */\r\n    setDescribedByIds(ids) {\r\n        this._ariaDescribedby = ids.join(' ');\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    onContainerClick() {\r\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\r\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\r\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\r\n        if (!this.focused) {\r\n            this.focus();\r\n        }\r\n    }\r\n}\r\nMatInput.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: `input[matInput], textarea[matInput], select[matNativeControl],\r\n      input[matNativeControl], textarea[matNativeControl]`,\r\n                exportAs: 'matInput',\r\n                host: {\r\n                    /**\r\n                     * \\@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\r\n                     */\r\n                    'class': 'mat-input-element mat-form-field-autofill-control',\r\n                    '[class.mat-input-server]': '_isServer',\r\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\r\n                    // the native input element. Otherwise property bindings for those don't work.\r\n                    '[attr.id]': 'id',\r\n                    '[attr.placeholder]': 'placeholder',\r\n                    '[disabled]': 'disabled',\r\n                    '[required]': 'required',\r\n                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\r\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\r\n                    '[attr.aria-invalid]': 'errorState',\r\n                    '[attr.aria-required]': 'required.toString()',\r\n                    '(blur)': '_focusChanged(false)',\r\n                    '(focus)': '_focusChanged(true)',\r\n                    '(input)': '_onInput()',\r\n                },\r\n                providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatInput.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Platform },\r\n    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },\r\n    { type: NgForm, decorators: [{ type: Optional }] },\r\n    { type: FormGroupDirective, decorators: [{ type: Optional }] },\r\n    { type: ErrorStateMatcher },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\r\n    { type: AutofillMonitor },\r\n    { type: NgZone }\r\n];\r\nMatInput.propDecorators = {\r\n    disabled: [{ type: Input }],\r\n    id: [{ type: Input }],\r\n    placeholder: [{ type: Input }],\r\n    required: [{ type: Input }],\r\n    type: [{ type: Input }],\r\n    errorStateMatcher: [{ type: Input }],\r\n    value: [{ type: Input }],\r\n    readonly: [{ type: Input }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass MatInputModule {\r\n}\r\nMatInputModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [MatInput, MatTextareaAutosize],\r\n                imports: [\r\n                    CommonModule,\r\n                    TextFieldModule,\r\n                    MatFormFieldModule,\r\n                ],\r\n                exports: [\r\n                    TextFieldModule,\r\n                    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\r\n                    // be used together with `MatFormField`.\r\n                    MatFormFieldModule,\r\n                    MatInput,\r\n                    MatTextareaAutosize,\r\n                ],\r\n                providers: [ErrorStateMatcher],\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR };\r\n\r\n"]}