{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/expansion.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAmFK,AAKC;;;;;;;;;;;4EAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoNH,AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAkBA;;;;;KAKD;;;;;;;;;;;;0CAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA8OA,AA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4MAYA;;;;;;;;;;KAUD;;;;;;;;;;;;0CAQC;;;;;;;;;;KAUD;;;;;;;;;;;;0CAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgGA,AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAMA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yNAuBC","file":"expansion.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { InjectionToken, Directive, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, EventEmitter, ElementRef, Input, Inject, Optional, Output, SkipSelf, ViewContainerRef, ViewEncapsulation, ViewChild, Host, ContentChildren, NgModule } from '@angular/core';\r\nimport { animate, animateChild, group, state, style, transition, trigger, query } from '@angular/animations';\r\nimport { __extends } from 'tslib';\r\nimport { CdkAccordionItem, CdkAccordion, CdkAccordionModule } from '@angular/cdk/accordion';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\r\nimport { TemplatePortal, PortalModule } from '@angular/cdk/portal';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\nimport { Subject, merge, Subscription, EMPTY } from 'rxjs';\r\nimport { filter, startWith, take, distinctUntilChanged } from 'rxjs/operators';\r\nimport { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';\r\nimport { ENTER, SPACE, hasModifierKey, HOME, END } from '@angular/cdk/keycodes';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Token used to provide a `MatAccordion` to `MatExpansionPanel`.\r\n * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.\r\n * @type {?}\r\n */\r\nvar MAT_ACCORDION = new InjectionToken('MAT_ACCORDION');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Time and timing curve for expansion panel animations.\r\n * @type {?}\r\n */\r\nvar EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';\r\n/**\r\n * Animations used by the Material expansion panel.\r\n *\r\n * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()\r\n * causes the animation state of moved components to become `void` upon exit, and not update again\r\n * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state\r\n * of the panel is `expanded` or `collapsed` but the animation state is `void`.\r\n *\r\n * To correctly handle animating to the next state, we animate between `void` and `collapsed` which\r\n * are defined to have the same styles. Since angular animates from the current styles to the\r\n * destination state's style definition, in situations where we are moving from `void`'s styles to\r\n * `collapsed` this acts a noop since no style values change.\r\n *\r\n * In the case where angular's animation state is out of sync with the expansion panel's state, the\r\n * expansion panel being `expanded` and angular animations being `void`, the animation from the\r\n * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will\r\n * occur as expected.\r\n *\r\n * Angular Bug: https://github.com/angular/angular/issues/18847\r\n *\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar matExpansionAnimations = {\r\n    /**\r\n     * Animation that rotates the indicator arrow.\r\n     */\r\n    indicatorRotate: trigger('indicatorRotate', [\r\n        state('collapsed, void', style({ transform: 'rotate(0deg)' })),\r\n        state('expanded', style({ transform: 'rotate(180deg)' })),\r\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\r\n    ]),\r\n    /**\r\n     * Animation that expands and collapses the panel header height.\r\n     */\r\n    expansionHeaderHeight: trigger('expansionHeight', [\r\n        state('collapsed, void', style({\r\n            height: '{{collapsedHeight}}',\r\n        }), {\r\n            params: { collapsedHeight: '48px' },\r\n        }),\r\n        state('expanded', style({\r\n            height: '{{expandedHeight}}'\r\n        }), {\r\n            params: { expandedHeight: '64px' }\r\n        }),\r\n        transition('expanded <=> collapsed, void => collapsed', group([\r\n            query('@indicatorRotate', animateChild(), { optional: true }),\r\n            animate(EXPANSION_PANEL_ANIMATION_TIMING),\r\n        ])),\r\n    ]),\r\n    /**\r\n     * Animation that expands and collapses the panel content.\r\n     */\r\n    bodyExpansion: trigger('bodyExpansion', [\r\n        state('collapsed, void', style({ height: '0px', visibility: 'hidden' })),\r\n        state('expanded', style({ height: '*', visibility: 'visible' })),\r\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\r\n    ])\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Expansion panel content that will be rendered lazily\r\n * after the panel is opened for the first time.\r\n */\r\nvar MatExpansionPanelContent = /** @class */ (function () {\r\n    function MatExpansionPanelContent(_template) {\r\n        this._template = _template;\r\n    }\r\n    MatExpansionPanelContent.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'ng-template[matExpansionPanelContent]'\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatExpansionPanelContent.ctorParameters = function () { return [\r\n        { type: TemplateRef }\r\n    ]; };\r\n    return MatExpansionPanelContent;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Counter for generating unique element ids.\r\n * @type {?}\r\n */\r\nvar uniqueId = 0;\r\n/**\r\n * Injection token that can be used to configure the defalt\r\n * options for the expansion panel component.\r\n * @type {?}\r\n */\r\nvar MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new InjectionToken('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');\r\nvar ɵ0 = undefined;\r\n/**\r\n * `<mat-expansion-panel>`\r\n *\r\n * This component can be used as a single element to show expandable content, or as one of\r\n * multiple children of an element with the MatAccordion directive attached.\r\n */\r\nvar MatExpansionPanel = /** @class */ (function (_super) {\r\n    __extends(MatExpansionPanel, _super);\r\n    function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {\r\n        var _this = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;\r\n        _this._viewContainerRef = _viewContainerRef;\r\n        _this._animationMode = _animationMode;\r\n        _this._hideToggle = false;\r\n        /**\r\n         * An event emitted after the body's expansion animation happens.\r\n         */\r\n        _this.afterExpand = new EventEmitter();\r\n        /**\r\n         * An event emitted after the body's collapse animation happens.\r\n         */\r\n        _this.afterCollapse = new EventEmitter();\r\n        /**\r\n         * Stream that emits for changes in `\\@Input` properties.\r\n         */\r\n        _this._inputChanges = new Subject();\r\n        /**\r\n         * ID for the associated header element. Used for a11y labelling.\r\n         */\r\n        _this._headerId = \"mat-expansion-panel-header-\" + uniqueId++;\r\n        /**\r\n         * Stream of body animation done events.\r\n         */\r\n        _this._bodyAnimationDone = new Subject();\r\n        _this.accordion = accordion;\r\n        _this._document = _document;\r\n        // We need a Subject with distinctUntilChanged, because the `done` event\r\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\r\n        _this._bodyAnimationDone.pipe(distinctUntilChanged((/**\r\n         * @param {?} x\r\n         * @param {?} y\r\n         * @return {?}\r\n         */\r\n        function (x, y) {\r\n            return x.fromState === y.fromState && x.toState === y.toState;\r\n        }))).subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            if (event.fromState !== 'void') {\r\n                if (event.toState === 'expanded') {\r\n                    _this.afterExpand.emit();\r\n                }\r\n                else if (event.toState === 'collapsed') {\r\n                    _this.afterCollapse.emit();\r\n                }\r\n            }\r\n        }));\r\n        if (defaultOptions) {\r\n            _this.hideToggle = defaultOptions.hideToggle;\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatExpansionPanel.prototype, \"hideToggle\", {\r\n        /** Whether the toggle indicator should be hidden. */\r\n        get: /**\r\n         * Whether the toggle indicator should be hidden.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._hideToggle || (this.accordion && this.accordion.hideToggle);\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._hideToggle = coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatExpansionPanel.prototype, \"togglePosition\", {\r\n        /** The position of the expansion indicator. */\r\n        get: /**\r\n         * The position of the expansion indicator.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._togglePosition || (this.accordion && this.accordion.togglePosition);\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._togglePosition = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Determines whether the expansion panel should have spacing between it and its siblings. */\r\n    /**\r\n     * Determines whether the expansion panel should have spacing between it and its siblings.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype._hasSpacing = /**\r\n     * Determines whether the expansion panel should have spacing between it and its siblings.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this.accordion) {\r\n            // We don't need to subscribe to the `stateChanges` of the parent accordion because each time\r\n            // the [displayMode] input changes, the change detection will also cover the host bindings\r\n            // of this expansion panel.\r\n            return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';\r\n        }\r\n        return false;\r\n    };\r\n    /** Gets the expanded state string. */\r\n    /**\r\n     * Gets the expanded state string.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype._getExpandedState = /**\r\n     * Gets the expanded state string.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.expanded ? 'expanded' : 'collapsed';\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (this._lazyContent) {\r\n            // Render the content as soon as the panel becomes open.\r\n            this.opened.pipe(startWith((/** @type {?} */ (null))), filter((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this.expanded && !_this._portal; })), take(1)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this._portal = new TemplatePortal(_this._lazyContent._template, _this._viewContainerRef);\r\n            }));\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        this._inputChanges.next(changes);\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        _super.prototype.ngOnDestroy.call(this);\r\n        this._bodyAnimationDone.complete();\r\n        this._inputChanges.complete();\r\n    };\r\n    /** Checks whether the expansion panel's content contains the currently-focused element. */\r\n    /**\r\n     * Checks whether the expansion panel's content contains the currently-focused element.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanel.prototype._containsFocus = /**\r\n     * Checks whether the expansion panel's content contains the currently-focused element.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._body) {\r\n            /** @type {?} */\r\n            var focusedElement = this._document.activeElement;\r\n            /** @type {?} */\r\n            var bodyElement = this._body.nativeElement;\r\n            return focusedElement === bodyElement || bodyElement.contains(focusedElement);\r\n        }\r\n        return false;\r\n    };\r\n    MatExpansionPanel.decorators = [\r\n        { type: Component, args: [{styles: [\".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}\"],\r\n                    selector: 'mat-expansion-panel',\r\n                    exportAs: 'matExpansionPanel',\r\n                    template: \"<ng-content select=\\\"mat-expansion-panel-header\\\"></ng-content><div class=\\\"mat-expansion-panel-content\\\" role=\\\"region\\\" [@bodyExpansion]=\\\"_getExpandedState()\\\" (@bodyExpansion.done)=\\\"_bodyAnimationDone.next($event)\\\" [attr.aria-labelledby]=\\\"_headerId\\\" [id]=\\\"id\\\" #body><div class=\\\"mat-expansion-panel-body\\\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\\\"_portal\\\"></ng-template></div><ng-content select=\\\"mat-action-row\\\"></ng-content></div>\",\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    inputs: ['disabled', 'expanded'],\r\n                    outputs: ['opened', 'closed', 'expandedChange'],\r\n                    animations: [matExpansionAnimations.bodyExpansion],\r\n                    providers: [\r\n                        // Provide MatAccordion as undefined to prevent nested expansion panels from registering\r\n                        // to the same accordion.\r\n                        { provide: MAT_ACCORDION, useValue: ɵ0 },\r\n                    ],\r\n                    host: {\r\n                        'class': 'mat-expansion-panel',\r\n                        '[class.mat-expanded]': 'expanded',\r\n                        '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\r\n                        '[class.mat-expansion-panel-spacing]': '_hasSpacing()',\r\n                    }\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatExpansionPanel.ctorParameters = function () { return [\r\n        { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [MAT_ACCORDION,] }] },\r\n        { type: ChangeDetectorRef },\r\n        { type: UniqueSelectionDispatcher },\r\n        { type: ViewContainerRef },\r\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\r\n    ]; };\r\n    MatExpansionPanel.propDecorators = {\r\n        hideToggle: [{ type: Input }],\r\n        togglePosition: [{ type: Input }],\r\n        afterExpand: [{ type: Output }],\r\n        afterCollapse: [{ type: Output }],\r\n        _lazyContent: [{ type: ContentChild, args: [MatExpansionPanelContent, { static: false },] }],\r\n        _body: [{ type: ViewChild, args: ['body', { static: false },] }]\r\n    };\r\n    return MatExpansionPanel;\r\n}(CdkAccordionItem));\r\nvar MatExpansionPanelActionRow = /** @class */ (function () {\r\n    function MatExpansionPanelActionRow() {\r\n    }\r\n    MatExpansionPanelActionRow.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'mat-action-row',\r\n                    host: {\r\n                        class: 'mat-action-row'\r\n                    }\r\n                },] },\r\n    ];\r\n    return MatExpansionPanelActionRow;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * `<mat-expansion-panel-header>`\r\n *\r\n * This component corresponds to the header element of an `<mat-expansion-panel>`.\r\n */\r\nvar MatExpansionPanelHeader = /** @class */ (function () {\r\n    function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {\r\n        var _this = this;\r\n        this.panel = panel;\r\n        this._element = _element;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._parentChangeSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Whether Angular animations in the panel header should be disabled.\r\n         */\r\n        this._animationsDisabled = true;\r\n        /** @type {?} */\r\n        var accordionHideToggleChange = panel.accordion ?\r\n            panel.accordion._stateChanges.pipe(filter((/**\r\n             * @param {?} changes\r\n             * @return {?}\r\n             */\r\n            function (changes) { return !!(changes['hideToggle'] || changes['togglePosition']); }))) :\r\n            EMPTY;\r\n        // Since the toggle state depends on an @Input on the panel, we\r\n        // need to subscribe and trigger change detection manually.\r\n        this._parentChangeSubscription =\r\n            merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter((/**\r\n             * @param {?} changes\r\n             * @return {?}\r\n             */\r\n            function (changes) {\r\n                return !!(changes['hideToggle'] ||\r\n                    changes['disabled'] ||\r\n                    changes['togglePosition']);\r\n            }))))\r\n                .subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._changeDetectorRef.markForCheck(); }));\r\n        // Avoids focus being lost if the panel contained the focused element and was closed.\r\n        panel.closed\r\n            .pipe(filter((/**\r\n         * @return {?}\r\n         */\r\n        function () { return panel._containsFocus(); })))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _focusMonitor.focusVia(_element, 'program'); }));\r\n        _focusMonitor.monitor(_element).subscribe((/**\r\n         * @param {?} origin\r\n         * @return {?}\r\n         */\r\n        function (origin) {\r\n            if (origin && panel.accordion) {\r\n                panel.accordion._handleHeaderFocus(_this);\r\n            }\r\n        }));\r\n        if (defaultOptions) {\r\n            this.expandedHeight = defaultOptions.expandedHeight;\r\n            this.collapsedHeight = defaultOptions.collapsedHeight;\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._animationStarted = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // Currently the `expansionHeight` animation has a `void => collapsed` transition which is\r\n        // there to work around a bug in Angular (see #13088), however this introduces a different\r\n        // issue. The new transition will cause the header to animate in on init (see #16067), if the\r\n        // consumer has set a header height that is different from the default one. We work around it\r\n        // by disabling animations on the header and re-enabling them after the first animation has run.\r\n        // Note that Angular dispatches animation events even if animations are disabled. Ideally this\r\n        // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait\r\n        // for https://github.com/angular/angular/issues/18847 to be resolved.\r\n        this._animationsDisabled = false;\r\n    };\r\n    Object.defineProperty(MatExpansionPanelHeader.prototype, \"disabled\", {\r\n        /**\r\n         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this.panel.disabled;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Toggles the expanded state of the panel. */\r\n    /**\r\n     * Toggles the expanded state of the panel.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._toggle = /**\r\n     * Toggles the expanded state of the panel.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.panel.toggle();\r\n    };\r\n    /** Gets whether the panel is expanded. */\r\n    /**\r\n     * Gets whether the panel is expanded.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._isExpanded = /**\r\n     * Gets whether the panel is expanded.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.panel.expanded;\r\n    };\r\n    /** Gets the expanded state string of the panel. */\r\n    /**\r\n     * Gets the expanded state string of the panel.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._getExpandedState = /**\r\n     * Gets the expanded state string of the panel.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.panel._getExpandedState();\r\n    };\r\n    /** Gets the panel id. */\r\n    /**\r\n     * Gets the panel id.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._getPanelId = /**\r\n     * Gets the panel id.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.panel.id;\r\n    };\r\n    /** Gets the toggle position for the header. */\r\n    /**\r\n     * Gets the toggle position for the header.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._getTogglePosition = /**\r\n     * Gets the toggle position for the header.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.panel.togglePosition;\r\n    };\r\n    /** Gets whether the expand indicator should be shown. */\r\n    /**\r\n     * Gets whether the expand indicator should be shown.\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._showToggle = /**\r\n     * Gets whether the expand indicator should be shown.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return !this.panel.hideToggle && !this.panel.disabled;\r\n    };\r\n    /** Handle keydown event calling to toggle() if appropriate. */\r\n    /**\r\n     * Handle keydown event calling to toggle() if appropriate.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype._keydown = /**\r\n     * Handle keydown event calling to toggle() if appropriate.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        switch (event.keyCode) {\r\n            // Toggle for space and enter keys.\r\n            case SPACE:\r\n            case ENTER:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    this._toggle();\r\n                }\r\n                break;\r\n            default:\r\n                if (this.panel.accordion) {\r\n                    this.panel.accordion._handleHeaderKeydown(event);\r\n                }\r\n                return;\r\n        }\r\n    };\r\n    /**\r\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\r\n     * @param origin Origin of the action that triggered the focus.\r\n     * @docs-private\r\n     */\r\n    /**\r\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\r\n     * \\@docs-private\r\n     * @param {?=} origin Origin of the action that triggered the focus.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype.focus = /**\r\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\r\n     * \\@docs-private\r\n     * @param {?=} origin Origin of the action that triggered the focus.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    function (origin, options) {\r\n        if (origin === void 0) { origin = 'program'; }\r\n        this._focusMonitor.focusVia(this._element, origin, options);\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatExpansionPanelHeader.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._parentChangeSubscription.unsubscribe();\r\n        this._focusMonitor.stopMonitoring(this._element);\r\n    };\r\n    MatExpansionPanelHeader.decorators = [\r\n        { type: Component, args: [{selector: 'mat-expansion-panel-header',\r\n                    styles: [\".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\"],\r\n                    template: \"<span class=\\\"mat-content\\\"><ng-content select=\\\"mat-panel-title\\\"></ng-content><ng-content select=\\\"mat-panel-description\\\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\\\"_getExpandedState()\\\" *ngIf=\\\"_showToggle()\\\" class=\\\"mat-expansion-indicator\\\"></span>\",\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    animations: [\r\n                        matExpansionAnimations.indicatorRotate,\r\n                        matExpansionAnimations.expansionHeaderHeight\r\n                    ],\r\n                    host: {\r\n                        'class': 'mat-expansion-panel-header',\r\n                        'role': 'button',\r\n                        '[attr.id]': 'panel._headerId',\r\n                        '[attr.tabindex]': 'disabled ? -1 : 0',\r\n                        '[attr.aria-controls]': '_getPanelId()',\r\n                        '[attr.aria-expanded]': '_isExpanded()',\r\n                        '[attr.aria-disabled]': 'panel.disabled',\r\n                        '[class.mat-expanded]': '_isExpanded()',\r\n                        '[class.mat-expansion-toggle-indicator-after]': \"_getTogglePosition() === 'after'\",\r\n                        '[class.mat-expansion-toggle-indicator-before]': \"_getTogglePosition() === 'before'\",\r\n                        '(click)': '_toggle()',\r\n                        '(keydown)': '_keydown($event)',\r\n                        '[@.disabled]': '_animationsDisabled',\r\n                        '(@expansionHeight.start)': '_animationStarted()',\r\n                        '[@expansionHeight]': \"{\\n        value: _getExpandedState(),\\n        params: {\\n          collapsedHeight: collapsedHeight,\\n          expandedHeight: expandedHeight\\n        }\\n    }\",\r\n                    },\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatExpansionPanelHeader.ctorParameters = function () { return [\r\n        { type: MatExpansionPanel, decorators: [{ type: Host }] },\r\n        { type: ElementRef },\r\n        { type: FocusMonitor },\r\n        { type: ChangeDetectorRef },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\r\n    ]; };\r\n    MatExpansionPanelHeader.propDecorators = {\r\n        expandedHeight: [{ type: Input }],\r\n        collapsedHeight: [{ type: Input }]\r\n    };\r\n    return MatExpansionPanelHeader;\r\n}());\r\n/**\r\n * `<mat-panel-description>`\r\n *\r\n * This directive is to be used inside of the MatExpansionPanelHeader component.\r\n */\r\nvar MatExpansionPanelDescription = /** @class */ (function () {\r\n    function MatExpansionPanelDescription() {\r\n    }\r\n    MatExpansionPanelDescription.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'mat-panel-description',\r\n                    host: {\r\n                        class: 'mat-expansion-panel-header-description'\r\n                    }\r\n                },] },\r\n    ];\r\n    return MatExpansionPanelDescription;\r\n}());\r\n/**\r\n * `<mat-panel-title>`\r\n *\r\n * This directive is to be used inside of the MatExpansionPanelHeader component.\r\n */\r\nvar MatExpansionPanelTitle = /** @class */ (function () {\r\n    function MatExpansionPanelTitle() {\r\n    }\r\n    MatExpansionPanelTitle.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'mat-panel-title',\r\n                    host: {\r\n                        class: 'mat-expansion-panel-header-title'\r\n                    }\r\n                },] },\r\n    ];\r\n    return MatExpansionPanelTitle;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Directive for a Material Design Accordion.\r\n */\r\nvar MatAccordion = /** @class */ (function (_super) {\r\n    __extends(MatAccordion, _super);\r\n    function MatAccordion() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._hideToggle = false;\r\n        /**\r\n         * Display mode used for all expansion panels in the accordion. Currently two display\r\n         * modes exist:\r\n         *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\r\n         *     panel at a different elevation from the rest of the accordion.\r\n         *  flat - no spacing is placed around expanded panels, showing all panels at the same\r\n         *     elevation.\r\n         */\r\n        _this.displayMode = 'default';\r\n        /**\r\n         * The position of the expansion indicator.\r\n         */\r\n        _this.togglePosition = 'after';\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatAccordion.prototype, \"hideToggle\", {\r\n        /** Whether the expansion indicator should be hidden. */\r\n        get: /**\r\n         * Whether the expansion indicator should be hidden.\r\n         * @return {?}\r\n         */\r\n        function () { return this._hideToggle; },\r\n        set: /**\r\n         * @param {?} show\r\n         * @return {?}\r\n         */\r\n        function (show) { this._hideToggle = coerceBooleanProperty(show); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatAccordion.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._keyManager = new FocusKeyManager(this._headers).withWrap();\r\n    };\r\n    /** Handles keyboard events coming in from the panel headers. */\r\n    /**\r\n     * Handles keyboard events coming in from the panel headers.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatAccordion.prototype._handleHeaderKeydown = /**\r\n     * Handles keyboard events coming in from the panel headers.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        var keyCode = event.keyCode;\r\n        /** @type {?} */\r\n        var manager = this._keyManager;\r\n        if (keyCode === HOME) {\r\n            if (!hasModifierKey(event)) {\r\n                manager.setFirstItemActive();\r\n                event.preventDefault();\r\n            }\r\n        }\r\n        else if (keyCode === END) {\r\n            if (!hasModifierKey(event)) {\r\n                manager.setLastItemActive();\r\n                event.preventDefault();\r\n            }\r\n        }\r\n        else {\r\n            this._keyManager.onKeydown(event);\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} header\r\n     * @return {?}\r\n     */\r\n    MatAccordion.prototype._handleHeaderFocus = /**\r\n     * @param {?} header\r\n     * @return {?}\r\n     */\r\n    function (header) {\r\n        this._keyManager.updateActiveItem(header);\r\n    };\r\n    MatAccordion.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'mat-accordion',\r\n                    exportAs: 'matAccordion',\r\n                    inputs: ['multi'],\r\n                    providers: [{\r\n                            provide: MAT_ACCORDION,\r\n                            useExisting: MatAccordion\r\n                        }],\r\n                    host: {\r\n                        class: 'mat-accordion'\r\n                    }\r\n                },] },\r\n    ];\r\n    MatAccordion.propDecorators = {\r\n        _headers: [{ type: ContentChildren, args: [MatExpansionPanelHeader, { descendants: true },] }],\r\n        hideToggle: [{ type: Input }],\r\n        displayMode: [{ type: Input }],\r\n        togglePosition: [{ type: Input }]\r\n    };\r\n    return MatAccordion;\r\n}(CdkAccordion));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatExpansionModule = /** @class */ (function () {\r\n    function MatExpansionModule() {\r\n    }\r\n    MatExpansionModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [CommonModule, CdkAccordionModule, PortalModule],\r\n                    exports: [\r\n                        MatAccordion,\r\n                        MatExpansionPanel,\r\n                        MatExpansionPanelActionRow,\r\n                        MatExpansionPanelHeader,\r\n                        MatExpansionPanelTitle,\r\n                        MatExpansionPanelDescription,\r\n                        MatExpansionPanelContent,\r\n                    ],\r\n                    declarations: [\r\n                        MatAccordion,\r\n                        MatExpansionPanel,\r\n                        MatExpansionPanelActionRow,\r\n                        MatExpansionPanelHeader,\r\n                        MatExpansionPanelTitle,\r\n                        MatExpansionPanelDescription,\r\n                        MatExpansionPanelContent,\r\n                    ],\r\n                },] },\r\n    ];\r\n    return MatExpansionModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatExpansionModule, MatAccordion, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations };\r\n\r\n"]}