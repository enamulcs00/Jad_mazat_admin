{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/input.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAwDO,AAcD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uCAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6jBA,AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAsBA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAmBC","file":"input.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\r\nimport { Directive, Input, InjectionToken, ElementRef, Inject, NgZone, Optional, Self, NgModule } from '@angular/core';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\r\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\r\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\r\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\r\nimport { Subject } from 'rxjs';\r\nimport { CommonModule } from '@angular/common';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Directive to automatically resize a textarea to fit its content.\r\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\r\n * \\@breaking-change 8.0.0\r\n */\r\nvar MatTextareaAutosize = /** @class */ (function (_super) {\r\n    __extends(MatTextareaAutosize, _super);\r\n    function MatTextareaAutosize() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMinRows\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () { return this.minRows; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.minRows = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMaxRows\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () { return this.maxRows; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.maxRows = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosize\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () { return this.enabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.enabled = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matTextareaAutosize\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () { return this.enabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.enabled = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MatTextareaAutosize.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\r\n                    exportAs: 'matTextareaAutosize',\r\n                    inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\r\n                    host: {\r\n                        'class': 'cdk-textarea-autosize mat-autosize',\r\n                        // Textarea elements that have the directive applied should have a single row by default.\r\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\r\n                        'rows': '1',\r\n                        '(input)': '_noopInputHandler()',\r\n                    },\r\n                },] },\r\n    ];\r\n    MatTextareaAutosize.propDecorators = {\r\n        matAutosizeMinRows: [{ type: Input }],\r\n        matAutosizeMaxRows: [{ type: Input }],\r\n        matAutosize: [{ type: Input, args: ['mat-autosize',] }],\r\n        matTextareaAutosize: [{ type: Input }]\r\n    };\r\n    return MatTextareaAutosize;\r\n}(CdkTextareaAutosize));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * \\@docs-private\r\n * @param {?} type\r\n * @return {?}\r\n */\r\nfunction getMatInputUnsupportedTypeError(type) {\r\n    return Error(\"Input type \\\"\" + type + \"\\\" isn't supported by matInput.\");\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\r\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\r\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\r\n * value to them.\r\n * @type {?}\r\n */\r\nvar MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\r\n/** @type {?} */\r\nvar MAT_INPUT_INVALID_TYPES = [\r\n    'button',\r\n    'checkbox',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'submit'\r\n];\r\n/** @type {?} */\r\nvar nextUniqueId = 0;\r\n// Boilerplate for applying mixins to MatInput.\r\n/**\r\n * \\@docs-private\r\n */\r\nvar \r\n// Boilerplate for applying mixins to MatInput.\r\n/**\r\n * \\@docs-private\r\n */\r\nMatInputBase = /** @class */ (function () {\r\n    function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\r\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\r\n        this._parentForm = _parentForm;\r\n        this._parentFormGroup = _parentFormGroup;\r\n        this.ngControl = ngControl;\r\n    }\r\n    return MatInputBase;\r\n}());\r\n/** @type {?} */\r\nvar _MatInputMixinBase = mixinErrorState(MatInputBase);\r\n/**\r\n * Directive that allows a native input to work inside a `MatFormField`.\r\n */\r\nvar MatInput = /** @class */ (function (_super) {\r\n    __extends(MatInput, _super);\r\n    function MatInput(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\r\n        var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\r\n        _this._elementRef = _elementRef;\r\n        _this._platform = _platform;\r\n        _this.ngControl = ngControl;\r\n        _this._autofillMonitor = _autofillMonitor;\r\n        _this._uid = \"mat-input-\" + nextUniqueId++;\r\n        /**\r\n         * Whether the component is being rendered on the server.\r\n         */\r\n        _this._isServer = false;\r\n        /**\r\n         * Whether the component is a native html select.\r\n         */\r\n        _this._isNativeSelect = false;\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        _this.focused = false;\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        _this.stateChanges = new Subject();\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        _this.controlType = 'mat-input';\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         */\r\n        _this.autofilled = false;\r\n        _this._disabled = false;\r\n        _this._required = false;\r\n        _this._type = 'text';\r\n        _this._readonly = false;\r\n        _this._neverEmptyInputTypes = [\r\n            'date',\r\n            'datetime',\r\n            'datetime-local',\r\n            'month',\r\n            'time',\r\n            'week'\r\n        ].filter((/**\r\n         * @param {?} t\r\n         * @return {?}\r\n         */\r\n        function (t) { return getSupportedInputTypes().has(t); }));\r\n        /** @type {?} */\r\n        var element = _this._elementRef.nativeElement;\r\n        // If no input value accessor was explicitly specified, use the element as the input value\r\n        // accessor.\r\n        _this._inputValueAccessor = inputValueAccessor || element;\r\n        _this._previousNativeValue = _this.value;\r\n        // Force setter to be called in case id was not specified.\r\n        _this.id = _this.id;\r\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\r\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\r\n        // exists on iOS, we only bother to install the listener on iOS.\r\n        if (_platform.IOS) {\r\n            ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _elementRef.nativeElement.addEventListener('keyup', (/**\r\n                 * @param {?} event\r\n                 * @return {?}\r\n                 */\r\n                function (event) {\r\n                    /** @type {?} */\r\n                    var el = (/** @type {?} */ (event.target));\r\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\r\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\r\n                        // `1, 1` fixes it for the first time that you type text and\r\n                        // then hold delete. Toggling to `1, 1` and then back to\r\n                        // `0, 0` seems to completely fix it.\r\n                        el.setSelectionRange(1, 1);\r\n                        el.setSelectionRange(0, 0);\r\n                    }\r\n                }));\r\n            }));\r\n        }\r\n        _this._isServer = !_this._platform.isBrowser;\r\n        _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\r\n        if (_this._isNativeSelect) {\r\n            _this.controlType = ((/** @type {?} */ (element))).multiple ? 'mat-native-select-multiple' :\r\n                'mat-native-select';\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatInput.prototype, \"disabled\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this.ngControl && this.ngControl.disabled !== null) {\r\n                return this.ngControl.disabled;\r\n            }\r\n            return this._disabled;\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._disabled = coerceBooleanProperty(value);\r\n            // Browsers may not fire the blur event if the input is disabled too quickly.\r\n            // Reset from here to ensure that the element doesn't become stuck.\r\n            if (this.focused) {\r\n                this.focused = false;\r\n                this.stateChanges.next();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"id\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () { return this._id; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._id = value || this._uid; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"required\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () { return this._required; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._required = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"type\", {\r\n        /** Input type of the element. */\r\n        get: /**\r\n         * Input type of the element.\r\n         * @return {?}\r\n         */\r\n        function () { return this._type; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._type = value || 'text';\r\n            this._validateType();\r\n            // When using Angular inputs, developers are no longer able to set the properties on the native\r\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\r\n            // with the native property. Textarea elements don't support the type property or attribute.\r\n            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\r\n                ((/** @type {?} */ (this._elementRef.nativeElement))).type = this._type;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"value\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () { return this._inputValueAccessor.value; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            if (value !== this.value) {\r\n                this._inputValueAccessor.value = value;\r\n                this.stateChanges.next();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"readonly\", {\r\n        /** Whether the element is readonly. */\r\n        get: /**\r\n         * Whether the element is readonly.\r\n         * @return {?}\r\n         */\r\n        function () { return this._readonly; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._readonly = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.ngOnInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            function (event) {\r\n                _this.autofilled = event.isAutofilled;\r\n                _this.stateChanges.next();\r\n            }));\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.ngOnChanges = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.stateChanges.next();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.stateChanges.complete();\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.ngDoCheck = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this.ngControl) {\r\n            // We need to re-evaluate this on every change detection cycle, because there are some\r\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\r\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\r\n            this.updateErrorState();\r\n        }\r\n        // We need to dirty-check the native element's value, because there are some cases where\r\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\r\n        // updating the value using `emitEvent: false`).\r\n        this._dirtyCheckNativeValue();\r\n    };\r\n    /** Focuses the input. */\r\n    /**\r\n     * Focuses the input.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.focus = /**\r\n     * Focuses the input.\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    function (options) {\r\n        this._elementRef.nativeElement.focus(options);\r\n    };\r\n    /** Callback for the cases where the focused state of the input changes. */\r\n    /**\r\n     * Callback for the cases where the focused state of the input changes.\r\n     * @param {?} isFocused\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._focusChanged = /**\r\n     * Callback for the cases where the focused state of the input changes.\r\n     * @param {?} isFocused\r\n     * @return {?}\r\n     */\r\n    function (isFocused) {\r\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\r\n            this.focused = isFocused;\r\n            this.stateChanges.next();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._onInput = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // This is a noop function and is used to let Angular know whenever the value changes.\r\n        // Angular will run a new change detection each time the `input` event has been dispatched.\r\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\r\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\r\n        // value changes and will not disappear.\r\n        // Listening to the input event wouldn't be necessary when the input is using the\r\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\r\n    };\r\n    /** Does some manual dirty checking on the native input `value` property. */\r\n    /**\r\n     * Does some manual dirty checking on the native input `value` property.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._dirtyCheckNativeValue = /**\r\n     * Does some manual dirty checking on the native input `value` property.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var newValue = this._elementRef.nativeElement.value;\r\n        if (this._previousNativeValue !== newValue) {\r\n            this._previousNativeValue = newValue;\r\n            this.stateChanges.next();\r\n        }\r\n    };\r\n    /** Make sure the input is a supported type. */\r\n    /**\r\n     * Make sure the input is a supported type.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._validateType = /**\r\n     * Make sure the input is a supported type.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\r\n            throw getMatInputUnsupportedTypeError(this._type);\r\n        }\r\n    };\r\n    /** Checks whether the input type is one of the types that are never empty. */\r\n    /**\r\n     * Checks whether the input type is one of the types that are never empty.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._isNeverEmpty = /**\r\n     * Checks whether the input type is one of the types that are never empty.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\r\n    };\r\n    /** Checks whether the input is invalid based on the native validation. */\r\n    /**\r\n     * Checks whether the input is invalid based on the native validation.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._isBadInput = /**\r\n     * Checks whether the input is invalid based on the native validation.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // The `validity` property won't be present on platform-server.\r\n        /** @type {?} */\r\n        var validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;\r\n        return validity && validity.badInput;\r\n    };\r\n    /** Determines if the component host is a textarea. */\r\n    /**\r\n     * Determines if the component host is a textarea.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype._isTextarea = /**\r\n     * Determines if the component host is a textarea.\r\n     * @protected\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\r\n    };\r\n    Object.defineProperty(MatInput.prototype, \"empty\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\r\n                !this.autofilled;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatInput.prototype, \"shouldLabelFloat\", {\r\n        /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * @docs-private\r\n         */\r\n        get: /**\r\n         * Implemented as part of MatFormFieldControl.\r\n         * \\@docs-private\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this._isNativeSelect) {\r\n                // For a single-selection `<select>`, the label should float when the selected option has\r\n                // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\r\n                // overlapping the label with the options.\r\n                /** @type {?} */\r\n                var selectElement = (/** @type {?} */ (this._elementRef.nativeElement));\r\n                /** @type {?} */\r\n                var firstOption = selectElement.options[0];\r\n                // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\r\n                // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\r\n                return this.focused || selectElement.multiple || !this.empty ||\r\n                    !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\r\n            }\r\n            else {\r\n                return this.focused || !this.empty;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @param {?} ids\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.setDescribedByIds = /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @param {?} ids\r\n     * @return {?}\r\n     */\r\n    function (ids) {\r\n        this._ariaDescribedby = ids.join(' ');\r\n    };\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    MatInput.prototype.onContainerClick = /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\r\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\r\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\r\n        if (!this.focused) {\r\n            this.focus();\r\n        }\r\n    };\r\n    MatInput.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\",\r\n                    exportAs: 'matInput',\r\n                    host: {\r\n                        /**\r\n                         * \\@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\r\n                         */\r\n                        'class': 'mat-input-element mat-form-field-autofill-control',\r\n                        '[class.mat-input-server]': '_isServer',\r\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\r\n                        // the native input element. Otherwise property bindings for those don't work.\r\n                        '[attr.id]': 'id',\r\n                        '[attr.placeholder]': 'placeholder',\r\n                        '[disabled]': 'disabled',\r\n                        '[required]': 'required',\r\n                        '[attr.readonly]': 'readonly && !_isNativeSelect || null',\r\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\r\n                        '[attr.aria-invalid]': 'errorState',\r\n                        '[attr.aria-required]': 'required.toString()',\r\n                        '(blur)': '_focusChanged(false)',\r\n                        '(focus)': '_focusChanged(true)',\r\n                        '(input)': '_onInput()',\r\n                    },\r\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatInput.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: Platform },\r\n        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },\r\n        { type: NgForm, decorators: [{ type: Optional }] },\r\n        { type: FormGroupDirective, decorators: [{ type: Optional }] },\r\n        { type: ErrorStateMatcher },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\r\n        { type: AutofillMonitor },\r\n        { type: NgZone }\r\n    ]; };\r\n    MatInput.propDecorators = {\r\n        disabled: [{ type: Input }],\r\n        id: [{ type: Input }],\r\n        placeholder: [{ type: Input }],\r\n        required: [{ type: Input }],\r\n        type: [{ type: Input }],\r\n        errorStateMatcher: [{ type: Input }],\r\n        value: [{ type: Input }],\r\n        readonly: [{ type: Input }]\r\n    };\r\n    return MatInput;\r\n}(_MatInputMixinBase));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatInputModule = /** @class */ (function () {\r\n    function MatInputModule() {\r\n    }\r\n    MatInputModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    declarations: [MatInput, MatTextareaAutosize],\r\n                    imports: [\r\n                        CommonModule,\r\n                        TextFieldModule,\r\n                        MatFormFieldModule,\r\n                    ],\r\n                    exports: [\r\n                        TextFieldModule,\r\n                        // We re-export the `MatFormFieldModule` since `MatInput` will almost always\r\n                        // be used together with `MatFormField`.\r\n                        MatFormFieldModule,\r\n                        MatInput,\r\n                        MatTextareaAutosize,\r\n                    ],\r\n                    providers: [ErrorStateMatcher],\r\n                },] },\r\n    ];\r\n    return MatInputModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR };\r\n\r\n"]}