{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/datepicker.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4EM,AAGA;;;;;;8SAC6M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoI7M,AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6ZA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmVA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+dA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAiMA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kUAWG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+VH,AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgHA,AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4jBA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgiBA,AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qXAiBA;;;;;;;;;;;;;KAaD;;;;;;;0CAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0GA,AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAcA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA8CC","file":"datepicker.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Injectable, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, forwardRef, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, ElementRef, NgZone, InjectionToken, ViewContainerRef, Directive, Attribute, ContentChild, ɵɵdefineInjectable } from '@angular/core';\r\nimport { Subject, merge, Subscription, of } from 'rxjs';\r\nimport { take, filter } from 'rxjs/operators';\r\nimport { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, UP_ARROW, SPACE, ESCAPE } from '@angular/cdk/keycodes';\r\nimport { DateAdapter, MAT_DATE_FORMATS, mixinColor } from '@angular/material/core';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\r\nimport { animate, state, style, transition, trigger } from '@angular/animations';\r\nimport { __extends } from 'tslib';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { MatDialog, MatDialogModule } from '@angular/material/dialog';\r\nimport { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';\r\nimport { MatFormField } from '@angular/material/form-field';\r\nimport { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';\r\nimport { MatButtonModule } from '@angular/material/button';\r\nimport { A11yModule } from '@angular/cdk/a11y';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * \\@docs-private\r\n * @param {?} provider\r\n * @return {?}\r\n */\r\nfunction createMissingDateImplError(provider) {\r\n    return Error(\"MatDatepicker: No provider found for \" + provider + \". You must import one of the following \" +\r\n        \"modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a \" +\r\n        \"custom implementation.\");\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Datepicker data that requires internationalization.\r\n */\r\nvar MatDatepickerIntl = /** @class */ (function () {\r\n    function MatDatepickerIntl() {\r\n        /**\r\n         * Stream that emits whenever the labels here are changed. Use this to notify\r\n         * components if the labels have changed after initialization.\r\n         */\r\n        this.changes = new Subject();\r\n        /**\r\n         * A label for the calendar popup (used by screen readers).\r\n         */\r\n        this.calendarLabel = 'Calendar';\r\n        /**\r\n         * A label for the button used to open the calendar popup (used by screen readers).\r\n         */\r\n        this.openCalendarLabel = 'Open calendar';\r\n        /**\r\n         * A label for the previous month button (used by screen readers).\r\n         */\r\n        this.prevMonthLabel = 'Previous month';\r\n        /**\r\n         * A label for the next month button (used by screen readers).\r\n         */\r\n        this.nextMonthLabel = 'Next month';\r\n        /**\r\n         * A label for the previous year button (used by screen readers).\r\n         */\r\n        this.prevYearLabel = 'Previous year';\r\n        /**\r\n         * A label for the next year button (used by screen readers).\r\n         */\r\n        this.nextYearLabel = 'Next year';\r\n        /**\r\n         * A label for the previous multi-year button (used by screen readers).\r\n         */\r\n        this.prevMultiYearLabel = 'Previous 20 years';\r\n        /**\r\n         * A label for the next multi-year button (used by screen readers).\r\n         */\r\n        this.nextMultiYearLabel = 'Next 20 years';\r\n        /**\r\n         * A label for the 'switch to month view' button (used by screen readers).\r\n         */\r\n        this.switchToMonthViewLabel = 'Choose date';\r\n        /**\r\n         * A label for the 'switch to year view' button (used by screen readers).\r\n         */\r\n        this.switchToMultiYearViewLabel = 'Choose month and year';\r\n    }\r\n    /** Formats a range of years. */\r\n    /**\r\n     * Formats a range of years.\r\n     * @param {?} start\r\n     * @param {?} end\r\n     * @return {?}\r\n     */\r\n    MatDatepickerIntl.prototype.formatYearRange = /**\r\n     * Formats a range of years.\r\n     * @param {?} start\r\n     * @param {?} end\r\n     * @return {?}\r\n     */\r\n    function (start, end) {\r\n        return start + \" \\u2013 \" + end;\r\n    };\r\n    MatDatepickerIntl.decorators = [\r\n        { type: Injectable, args: [{ providedIn: 'root' },] },\r\n    ];\r\n    /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = ɵɵdefineInjectable({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: \"root\" });\r\n    return MatDatepickerIntl;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * An internal class that represents the data corresponding to a single calendar cell.\r\n * \\@docs-private\r\n */\r\nvar  /**\r\n * An internal class that represents the data corresponding to a single calendar cell.\r\n * \\@docs-private\r\n */\r\nMatCalendarCell = /** @class */ (function () {\r\n    function MatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {\r\n        this.value = value;\r\n        this.displayValue = displayValue;\r\n        this.ariaLabel = ariaLabel;\r\n        this.enabled = enabled;\r\n        this.cssClasses = cssClasses;\r\n    }\r\n    return MatCalendarCell;\r\n}());\r\n/**\r\n * An internal component used to display calendar data in a table.\r\n * \\@docs-private\r\n */\r\nvar MatCalendarBody = /** @class */ (function () {\r\n    function MatCalendarBody(_elementRef, _ngZone) {\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        /**\r\n         * The number of columns in the table.\r\n         */\r\n        this.numCols = 7;\r\n        /**\r\n         * The cell number of the active cell in the table.\r\n         */\r\n        this.activeCell = 0;\r\n        /**\r\n         * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\r\n         * maintained even as the table resizes.\r\n         */\r\n        this.cellAspectRatio = 1;\r\n        /**\r\n         * Emits when a new value is selected.\r\n         */\r\n        this.selectedValueChange = new EventEmitter();\r\n    }\r\n    /**\r\n     * @param {?} cell\r\n     * @return {?}\r\n     */\r\n    MatCalendarBody.prototype._cellClicked = /**\r\n     * @param {?} cell\r\n     * @return {?}\r\n     */\r\n    function (cell) {\r\n        if (cell.enabled) {\r\n            this.selectedValueChange.emit(cell.value);\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatCalendarBody.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        /** @type {?} */\r\n        var columnChanges = changes['numCols'];\r\n        var _a = this, rows = _a.rows, numCols = _a.numCols;\r\n        if (changes['rows'] || columnChanges) {\r\n            this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;\r\n        }\r\n        if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {\r\n            this._cellPadding = 50 * this.cellAspectRatio / numCols + \"%\";\r\n        }\r\n        if (columnChanges || !this._cellWidth) {\r\n            this._cellWidth = 100 / numCols + \"%\";\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} rowIndex\r\n     * @param {?} colIndex\r\n     * @return {?}\r\n     */\r\n    MatCalendarBody.prototype._isActiveCell = /**\r\n     * @param {?} rowIndex\r\n     * @param {?} colIndex\r\n     * @return {?}\r\n     */\r\n    function (rowIndex, colIndex) {\r\n        /** @type {?} */\r\n        var cellNumber = rowIndex * this.numCols + colIndex;\r\n        // Account for the fact that the first row may not have as many cells.\r\n        if (rowIndex) {\r\n            cellNumber -= this._firstRowOffset;\r\n        }\r\n        return cellNumber == this.activeCell;\r\n    };\r\n    /** Focuses the active cell after the microtask queue is empty. */\r\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    MatCalendarBody.prototype._focusActiveCell = /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                /** @type {?} */\r\n                var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');\r\n                if (activeCell) {\r\n                    activeCell.focus();\r\n                }\r\n            }));\r\n        }));\r\n    };\r\n    MatCalendarBody.decorators = [\r\n        { type: Component, args: [{selector: '[mat-calendar-body]',\r\n                    template: \"<tr *ngIf=\\\"_firstRowOffset < labelMinRequiredCells\\\" aria-hidden=\\\"true\\\"><td class=\\\"mat-calendar-body-label\\\" [attr.colspan]=\\\"numCols\\\" [style.paddingTop]=\\\"_cellPadding\\\" [style.paddingBottom]=\\\"_cellPadding\\\">{{label}}</td></tr><tr *ngFor=\\\"let row of rows; let rowIndex = index\\\" role=\\\"row\\\"><td *ngIf=\\\"rowIndex === 0 && _firstRowOffset\\\" aria-hidden=\\\"true\\\" class=\\\"mat-calendar-body-label\\\" [attr.colspan]=\\\"_firstRowOffset\\\" [style.paddingTop]=\\\"_cellPadding\\\" [style.paddingBottom]=\\\"_cellPadding\\\">{{_firstRowOffset >= labelMinRequiredCells ? label : ''}}</td><td *ngFor=\\\"let item of row; let colIndex = index\\\" role=\\\"gridcell\\\" class=\\\"mat-calendar-body-cell\\\" [ngClass]=\\\"item.cssClasses\\\" [tabindex]=\\\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\\\" [class.mat-calendar-body-disabled]=\\\"!item.enabled\\\" [class.mat-calendar-body-active]=\\\"_isActiveCell(rowIndex, colIndex)\\\" [attr.aria-label]=\\\"item.ariaLabel\\\" [attr.aria-disabled]=\\\"!item.enabled || null\\\" [attr.aria-selected]=\\\"selectedValue === item.value\\\" (click)=\\\"_cellClicked(item)\\\" [style.width]=\\\"_cellWidth\\\" [style.paddingTop]=\\\"_cellPadding\\\" role=\\\"button\\\" [style.paddingBottom]=\\\"_cellPadding\\\"><div class=\\\"mat-calendar-body-cell-content\\\" [class.mat-calendar-body-selected]=\\\"selectedValue === item.value\\\" [class.mat-calendar-body-today]=\\\"todayValue === item.value\\\">{{item.displayValue}}</div></td></tr>\",\r\n                    styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}}[dir=rtl] .mat-calendar-body-label{text-align:right}\"],\r\n                    host: {\r\n                        'class': 'mat-calendar-body',\r\n                        'role': 'grid',\r\n                        'aria-readonly': 'true'\r\n                    },\r\n                    exportAs: 'matCalendarBody',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatCalendarBody.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: NgZone }\r\n    ]; };\r\n    MatCalendarBody.propDecorators = {\r\n        label: [{ type: Input }],\r\n        rows: [{ type: Input }],\r\n        todayValue: [{ type: Input }],\r\n        selectedValue: [{ type: Input }],\r\n        labelMinRequiredCells: [{ type: Input }],\r\n        numCols: [{ type: Input }],\r\n        activeCell: [{ type: Input }],\r\n        cellAspectRatio: [{ type: Input }],\r\n        selectedValueChange: [{ type: Output }]\r\n    };\r\n    return MatCalendarBody;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nvar DAYS_PER_WEEK = 7;\r\n/**\r\n * An internal component used to display a single month in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\r\nvar MatMonthView = /** @class */ (function () {\r\n    function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dateFormats = _dateFormats;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dir = _dir;\r\n        /**\r\n         * Emits when a new date is selected.\r\n         */\r\n        this.selectedChange = new EventEmitter();\r\n        /**\r\n         * Emits when any date is selected.\r\n         */\r\n        this._userSelection = new EventEmitter();\r\n        /**\r\n         * Emits when any date is activated.\r\n         */\r\n        this.activeDateChange = new EventEmitter();\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        if (!this._dateFormats) {\r\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\r\n        }\r\n        this._activeDate = this._dateAdapter.today();\r\n    }\r\n    Object.defineProperty(MatMonthView.prototype, \"activeDate\", {\r\n        /**\r\n         * The date to display in this month view (everything other than the month and year is ignored).\r\n         */\r\n        get: /**\r\n         * The date to display in this month view (everything other than the month and year is ignored).\r\n         * @return {?}\r\n         */\r\n        function () { return this._activeDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            /** @type {?} */\r\n            var oldActiveDate = this._activeDate;\r\n            /** @type {?} */\r\n            var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\r\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\r\n            if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\r\n                this._init();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMonthView.prototype, \"selected\", {\r\n        /** The currently selected date. */\r\n        get: /**\r\n         * The currently selected date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._selected; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n            this._selectedDate = this._getDateInCurrentMonth(this._selected);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMonthView.prototype, \"minDate\", {\r\n        /** The minimum selectable date. */\r\n        get: /**\r\n         * The minimum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._minDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMonthView.prototype, \"maxDate\", {\r\n        /** The maximum selectable date. */\r\n        get: /**\r\n         * The maximum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._maxDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._init();\r\n    };\r\n    /** Handles when a new date is selected. */\r\n    /**\r\n     * Handles when a new date is selected.\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._dateSelected = /**\r\n     * Handles when a new date is selected.\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        if (this._selectedDate != date) {\r\n            /** @type {?} */\r\n            var selectedYear = this._dateAdapter.getYear(this.activeDate);\r\n            /** @type {?} */\r\n            var selectedMonth = this._dateAdapter.getMonth(this.activeDate);\r\n            /** @type {?} */\r\n            var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);\r\n            this.selectedChange.emit(selectedDate);\r\n        }\r\n        this._userSelection.emit();\r\n    };\r\n    /** Handles keydown events on the calendar body when calendar is in month view. */\r\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in month view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._handleCalendarBodyKeydown = /**\r\n     * Handles keydown events on the calendar body when calendar is in month view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\r\n        // disabled ones from being selected. This may not be ideal, we should look into whether\r\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\r\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\r\n        // disabled ones from being selected. This may not be ideal, we should look into whether\r\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\r\n        /** @type {?} */\r\n        var oldActiveDate = this._activeDate;\r\n        /** @type {?} */\r\n        var isRtl = this._isRtl();\r\n        switch (event.keyCode) {\r\n            case LEFT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\r\n                break;\r\n            case RIGHT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\r\n                break;\r\n            case UP_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\r\n                break;\r\n            case DOWN_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\r\n                break;\r\n            case HOME:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\r\n                break;\r\n            case END:\r\n                this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -\r\n                    this._dateAdapter.getDate(this._activeDate)));\r\n                break;\r\n            case PAGE_UP:\r\n                this.activeDate = event.altKey ?\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, -1) :\r\n                    this._dateAdapter.addCalendarMonths(this._activeDate, -1);\r\n                break;\r\n            case PAGE_DOWN:\r\n                this.activeDate = event.altKey ?\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, 1) :\r\n                    this._dateAdapter.addCalendarMonths(this._activeDate, 1);\r\n                break;\r\n            case ENTER:\r\n            case SPACE:\r\n                if (!this.dateFilter || this.dateFilter(this._activeDate)) {\r\n                    this._dateSelected(this._dateAdapter.getDate(this._activeDate));\r\n                    this._userSelection.emit();\r\n                    // Prevent unexpected default actions such as form submission.\r\n                    event.preventDefault();\r\n                }\r\n                return;\r\n            default:\r\n                // Don't prevent default or focus active cell on keys that we don't explicitly handle.\r\n                return;\r\n        }\r\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\r\n            this.activeDateChange.emit(this.activeDate);\r\n        }\r\n        this._focusActiveCell();\r\n        // Prevent unexpected default actions such as form submission.\r\n        event.preventDefault();\r\n    };\r\n    /** Initializes this month view. */\r\n    /**\r\n     * Initializes this month view.\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._init = /**\r\n     * Initializes this month view.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._selectedDate = this._getDateInCurrentMonth(this.selected);\r\n        this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());\r\n        this._monthLabel =\r\n            this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]\r\n                .toLocaleUpperCase();\r\n        /** @type {?} */\r\n        var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\r\n        this._firstWeekOffset =\r\n            (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -\r\n                this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\r\n        this._initWeekdays();\r\n        this._createWeekCells();\r\n        this._changeDetectorRef.markForCheck();\r\n    };\r\n    /** Focuses the active cell after the microtask queue is empty. */\r\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._focusActiveCell = /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._matCalendarBody._focusActiveCell();\r\n    };\r\n    /** Initializes the weekdays. */\r\n    /**\r\n     * Initializes the weekdays.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._initWeekdays = /**\r\n     * Initializes the weekdays.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\r\n        /** @type {?} */\r\n        var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\r\n        /** @type {?} */\r\n        var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');\r\n        // Rotate the labels for days of the week based on the configured first day of the week.\r\n        /** @type {?} */\r\n        var weekdays = longWeekdays.map((/**\r\n         * @param {?} long\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        function (long, i) {\r\n            return { long: long, narrow: narrowWeekdays[i] };\r\n        }));\r\n        this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\r\n    };\r\n    /** Creates MatCalendarCells for the dates in this month. */\r\n    /**\r\n     * Creates MatCalendarCells for the dates in this month.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._createWeekCells = /**\r\n     * Creates MatCalendarCells for the dates in this month.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\r\n        /** @type {?} */\r\n        var dateNames = this._dateAdapter.getDateNames();\r\n        this._weeks = [[]];\r\n        for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\r\n            if (cell == DAYS_PER_WEEK) {\r\n                this._weeks.push([]);\r\n                cell = 0;\r\n            }\r\n            /** @type {?} */\r\n            var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\r\n            /** @type {?} */\r\n            var enabled = this._shouldEnableDate(date);\r\n            /** @type {?} */\r\n            var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\r\n            /** @type {?} */\r\n            var cellClasses = this.dateClass ? this.dateClass(date) : undefined;\r\n            this._weeks[this._weeks.length - 1]\r\n                .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));\r\n        }\r\n    };\r\n    /** Date filter for the month */\r\n    /**\r\n     * Date filter for the month\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._shouldEnableDate = /**\r\n     * Date filter for the month\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        return !!date &&\r\n            (!this.dateFilter || this.dateFilter(date)) &&\r\n            (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&\r\n            (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);\r\n    };\r\n    /**\r\n     * Gets the date in this month that the given Date falls on.\r\n     * Returns null if the given Date is in another month.\r\n     */\r\n    /**\r\n     * Gets the date in this month that the given Date falls on.\r\n     * Returns null if the given Date is in another month.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._getDateInCurrentMonth = /**\r\n     * Gets the date in this month that the given Date falls on.\r\n     * Returns null if the given Date is in another month.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        return date && this._hasSameMonthAndYear(date, this.activeDate) ?\r\n            this._dateAdapter.getDate(date) : null;\r\n    };\r\n    /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */\r\n    /**\r\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\r\n     * @private\r\n     * @param {?} d1\r\n     * @param {?} d2\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._hasSameMonthAndYear = /**\r\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\r\n     * @private\r\n     * @param {?} d1\r\n     * @param {?} d2\r\n     * @return {?}\r\n     */\r\n    function (d1, d2) {\r\n        return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&\r\n            this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatMonthView.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    /** Determines whether the user has the RTL layout direction. */\r\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatMonthView.prototype._isRtl = /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._dir && this._dir.value === 'rtl';\r\n    };\r\n    MatMonthView.decorators = [\r\n        { type: Component, args: [{selector: 'mat-month-view',\r\n                    template: \"<table class=\\\"mat-calendar-table\\\" role=\\\"presentation\\\"><thead class=\\\"mat-calendar-table-header\\\"><tr><th scope=\\\"col\\\" *ngFor=\\\"let day of _weekdays\\\" [attr.aria-label]=\\\"day.long\\\">{{day.narrow}}</th></tr><tr><th class=\\\"mat-calendar-table-header-divider\\\" colspan=\\\"7\\\" aria-hidden=\\\"true\\\"></th></tr></thead><tbody mat-calendar-body [label]=\\\"_monthLabel\\\" [rows]=\\\"_weeks\\\" [todayValue]=\\\"_todayDate\\\" [selectedValue]=\\\"_selectedDate\\\" [labelMinRequiredCells]=\\\"3\\\" [activeCell]=\\\"_dateAdapter.getDate(activeDate) - 1\\\" (selectedValueChange)=\\\"_dateSelected($event)\\\" (keydown)=\\\"_handleCalendarBodyKeydown($event)\\\"></tbody></table>\",\r\n                    exportAs: 'matMonthView',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatMonthView.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] }\r\n    ]; };\r\n    MatMonthView.propDecorators = {\r\n        activeDate: [{ type: Input }],\r\n        selected: [{ type: Input }],\r\n        minDate: [{ type: Input }],\r\n        maxDate: [{ type: Input }],\r\n        dateFilter: [{ type: Input }],\r\n        dateClass: [{ type: Input }],\r\n        selectedChange: [{ type: Output }],\r\n        _userSelection: [{ type: Output }],\r\n        activeDateChange: [{ type: Output }],\r\n        _matCalendarBody: [{ type: ViewChild, args: [MatCalendarBody, { static: false },] }]\r\n    };\r\n    return MatMonthView;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nvar yearsPerPage = 24;\r\n/** @type {?} */\r\nvar yearsPerRow = 4;\r\n/**\r\n * An internal component used to display a year selector in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\r\nvar MatMultiYearView = /** @class */ (function () {\r\n    function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dir = _dir;\r\n        /**\r\n         * Emits when a new year is selected.\r\n         */\r\n        this.selectedChange = new EventEmitter();\r\n        /**\r\n         * Emits the selected year. This doesn't imply a change on the selected date\r\n         */\r\n        this.yearSelected = new EventEmitter();\r\n        /**\r\n         * Emits when any date is activated.\r\n         */\r\n        this.activeDateChange = new EventEmitter();\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        this._activeDate = this._dateAdapter.today();\r\n    }\r\n    Object.defineProperty(MatMultiYearView.prototype, \"activeDate\", {\r\n        /** The date to display in this multi-year view (everything other than the year is ignored). */\r\n        get: /**\r\n         * The date to display in this multi-year view (everything other than the year is ignored).\r\n         * @return {?}\r\n         */\r\n        function () { return this._activeDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            /** @type {?} */\r\n            var oldActiveDate = this._activeDate;\r\n            /** @type {?} */\r\n            var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\r\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\r\n            if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {\r\n                this._init();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMultiYearView.prototype, \"selected\", {\r\n        /** The currently selected date. */\r\n        get: /**\r\n         * The currently selected date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._selected; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n            this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMultiYearView.prototype, \"minDate\", {\r\n        /** The minimum selectable date. */\r\n        get: /**\r\n         * The minimum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._minDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatMultiYearView.prototype, \"maxDate\", {\r\n        /** The maximum selectable date. */\r\n        get: /**\r\n         * The maximum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._maxDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._init();\r\n    };\r\n    /** Initializes this multi-year view. */\r\n    /**\r\n     * Initializes this multi-year view.\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._init = /**\r\n     * Initializes this multi-year view.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());\r\n        // We want a range years such that we maximize the number of\r\n        // enabled dates visible at once. This prevents issues where the minimum year\r\n        // is the last item of a page OR the maximum year is the first item of a page.\r\n        // The offset from the active year to the \"slot\" for the starting year is the\r\n        // *actual* first rendered year in the multi-year view.\r\n        /** @type {?} */\r\n        var activeYear = this._dateAdapter.getYear(this._activeDate);\r\n        /** @type {?} */\r\n        var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\r\n        this._years = [];\r\n        for (var i = 0, row = []; i < yearsPerPage; i++) {\r\n            row.push(minYearOfPage + i);\r\n            if (row.length == yearsPerRow) {\r\n                this._years.push(row.map((/**\r\n                 * @param {?} year\r\n                 * @return {?}\r\n                 */\r\n                function (year) { return _this._createCellForYear(year); })));\r\n                row = [];\r\n            }\r\n        }\r\n        this._changeDetectorRef.markForCheck();\r\n    };\r\n    /** Handles when a new year is selected. */\r\n    /**\r\n     * Handles when a new year is selected.\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._yearSelected = /**\r\n     * Handles when a new year is selected.\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    function (year) {\r\n        this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));\r\n        /** @type {?} */\r\n        var month = this._dateAdapter.getMonth(this.activeDate);\r\n        /** @type {?} */\r\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));\r\n        this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\r\n    };\r\n    /** Handles keydown events on the calendar body when calendar is in multi-year view. */\r\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in multi-year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._handleCalendarBodyKeydown = /**\r\n     * Handles keydown events on the calendar body when calendar is in multi-year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        /** @type {?} */\r\n        var oldActiveDate = this._activeDate;\r\n        /** @type {?} */\r\n        var isRtl = this._isRtl();\r\n        switch (event.keyCode) {\r\n            case LEFT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\r\n                break;\r\n            case RIGHT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\r\n                break;\r\n            case UP_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\r\n                break;\r\n            case DOWN_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\r\n                break;\r\n            case HOME:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));\r\n                break;\r\n            case END:\r\n                this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);\r\n                break;\r\n            case PAGE_UP:\r\n                this.activeDate =\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\r\n                break;\r\n            case PAGE_DOWN:\r\n                this.activeDate =\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\r\n                break;\r\n            case ENTER:\r\n            case SPACE:\r\n                this._yearSelected(this._dateAdapter.getYear(this._activeDate));\r\n                break;\r\n            default:\r\n                // Don't prevent default or focus active cell on keys that we don't explicitly handle.\r\n                return;\r\n        }\r\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\r\n            this.activeDateChange.emit(this.activeDate);\r\n        }\r\n        this._focusActiveCell();\r\n        // Prevent unexpected default actions such as form submission.\r\n        event.preventDefault();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._getActiveCell = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\r\n    };\r\n    /** Focuses the active cell after the microtask queue is empty. */\r\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._focusActiveCell = /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._matCalendarBody._focusActiveCell();\r\n    };\r\n    /** Creates an MatCalendarCell for the given year. */\r\n    /**\r\n     * Creates an MatCalendarCell for the given year.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._createCellForYear = /**\r\n     * Creates an MatCalendarCell for the given year.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    function (year) {\r\n        /** @type {?} */\r\n        var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));\r\n        return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));\r\n    };\r\n    /** Whether the given year is enabled. */\r\n    /**\r\n     * Whether the given year is enabled.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._shouldEnableYear = /**\r\n     * Whether the given year is enabled.\r\n     * @private\r\n     * @param {?} year\r\n     * @return {?}\r\n     */\r\n    function (year) {\r\n        // disable if the year is greater than maxDate lower than minDate\r\n        if (year === undefined || year === null ||\r\n            (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||\r\n            (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {\r\n            return false;\r\n        }\r\n        // enable if it reaches here and there's no filter defined\r\n        if (!this.dateFilter) {\r\n            return true;\r\n        }\r\n        /** @type {?} */\r\n        var firstOfYear = this._dateAdapter.createDate(year, 0, 1);\r\n        // If any date in the year is enabled count the year as enabled.\r\n        for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\r\n            if (this.dateFilter(date)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatMultiYearView.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    /** Determines whether the user has the RTL layout direction. */\r\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatMultiYearView.prototype._isRtl = /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._dir && this._dir.value === 'rtl';\r\n    };\r\n    MatMultiYearView.decorators = [\r\n        { type: Component, args: [{selector: 'mat-multi-year-view',\r\n                    template: \"<table class=\\\"mat-calendar-table\\\" role=\\\"presentation\\\"><thead class=\\\"mat-calendar-table-header\\\"><tr><th class=\\\"mat-calendar-table-header-divider\\\" colspan=\\\"4\\\"></th></tr></thead><tbody mat-calendar-body [rows]=\\\"_years\\\" [todayValue]=\\\"_todayYear\\\" [selectedValue]=\\\"_selectedYear\\\" [numCols]=\\\"4\\\" [cellAspectRatio]=\\\"4 / 7\\\" [activeCell]=\\\"_getActiveCell()\\\" (selectedValueChange)=\\\"_yearSelected($event)\\\" (keydown)=\\\"_handleCalendarBodyKeydown($event)\\\"></tbody></table>\",\r\n                    exportAs: 'matMultiYearView',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatMultiYearView.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] }\r\n    ]; };\r\n    MatMultiYearView.propDecorators = {\r\n        activeDate: [{ type: Input }],\r\n        selected: [{ type: Input }],\r\n        minDate: [{ type: Input }],\r\n        maxDate: [{ type: Input }],\r\n        dateFilter: [{ type: Input }],\r\n        selectedChange: [{ type: Output }],\r\n        yearSelected: [{ type: Output }],\r\n        activeDateChange: [{ type: Output }],\r\n        _matCalendarBody: [{ type: ViewChild, args: [MatCalendarBody, { static: false },] }]\r\n    };\r\n    return MatMultiYearView;\r\n}());\r\n/**\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} date1\r\n * @param {?} date2\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\r\nfunction isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {\r\n    /** @type {?} */\r\n    var year1 = dateAdapter.getYear(date1);\r\n    /** @type {?} */\r\n    var year2 = dateAdapter.getYear(date2);\r\n    /** @type {?} */\r\n    var startingYear = getStartingYear(dateAdapter, minDate, maxDate);\r\n    return Math.floor((year1 - startingYear) / yearsPerPage) ===\r\n        Math.floor((year2 - startingYear) / yearsPerPage);\r\n}\r\n/**\r\n * When the multi-year view is first opened, the active year will be in view.\r\n * So we compute how many years are between the active year and the *slot* where our\r\n * \"startingYear\" will render when paged into view.\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} activeDate\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\r\nfunction getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {\r\n    /** @type {?} */\r\n    var activeYear = dateAdapter.getYear(activeDate);\r\n    return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);\r\n}\r\n/**\r\n * We pick a \"starting\" year such that either the maximum year would be at the end\r\n * or the minimum year would be at the beginning of a page.\r\n * @template D\r\n * @param {?} dateAdapter\r\n * @param {?} minDate\r\n * @param {?} maxDate\r\n * @return {?}\r\n */\r\nfunction getStartingYear(dateAdapter, minDate, maxDate) {\r\n    /** @type {?} */\r\n    var startingYear = 0;\r\n    if (maxDate) {\r\n        /** @type {?} */\r\n        var maxYear = dateAdapter.getYear(maxDate);\r\n        startingYear = maxYear - yearsPerPage + 1;\r\n    }\r\n    else if (minDate) {\r\n        startingYear = dateAdapter.getYear(minDate);\r\n    }\r\n    return startingYear;\r\n}\r\n/**\r\n * Gets remainder that is non-negative, even if first number is negative\r\n * @param {?} a\r\n * @param {?} b\r\n * @return {?}\r\n */\r\nfunction euclideanModulo(a, b) {\r\n    return (a % b + b) % b;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * An internal component used to display a single year in the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\r\nvar MatYearView = /** @class */ (function () {\r\n    function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dateFormats = _dateFormats;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dir = _dir;\r\n        /**\r\n         * Emits when a new month is selected.\r\n         */\r\n        this.selectedChange = new EventEmitter();\r\n        /**\r\n         * Emits the selected month. This doesn't imply a change on the selected date\r\n         */\r\n        this.monthSelected = new EventEmitter();\r\n        /**\r\n         * Emits when any date is activated.\r\n         */\r\n        this.activeDateChange = new EventEmitter();\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        if (!this._dateFormats) {\r\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\r\n        }\r\n        this._activeDate = this._dateAdapter.today();\r\n    }\r\n    Object.defineProperty(MatYearView.prototype, \"activeDate\", {\r\n        /** The date to display in this year view (everything other than the year is ignored). */\r\n        get: /**\r\n         * The date to display in this year view (everything other than the year is ignored).\r\n         * @return {?}\r\n         */\r\n        function () { return this._activeDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            /** @type {?} */\r\n            var oldActiveDate = this._activeDate;\r\n            /** @type {?} */\r\n            var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\r\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\r\n            if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\r\n                this._init();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatYearView.prototype, \"selected\", {\r\n        /** The currently selected date. */\r\n        get: /**\r\n         * The currently selected date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._selected; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n            this._selectedMonth = this._getMonthInCurrentYear(this._selected);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatYearView.prototype, \"minDate\", {\r\n        /** The minimum selectable date. */\r\n        get: /**\r\n         * The minimum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._minDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatYearView.prototype, \"maxDate\", {\r\n        /** The maximum selectable date. */\r\n        get: /**\r\n         * The maximum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._maxDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._init();\r\n    };\r\n    /** Handles when a new month is selected. */\r\n    /**\r\n     * Handles when a new month is selected.\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._monthSelected = /**\r\n     * Handles when a new month is selected.\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    function (month) {\r\n        /** @type {?} */\r\n        var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\r\n        this.monthSelected.emit(normalizedDate);\r\n        /** @type {?} */\r\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\r\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\r\n    };\r\n    /** Handles keydown events on the calendar body when calendar is in year view. */\r\n    /**\r\n     * Handles keydown events on the calendar body when calendar is in year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._handleCalendarBodyKeydown = /**\r\n     * Handles keydown events on the calendar body when calendar is in year view.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\r\n        // disabled ones from being selected. This may not be ideal, we should look into whether\r\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\r\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\r\n        // disabled ones from being selected. This may not be ideal, we should look into whether\r\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\r\n        /** @type {?} */\r\n        var oldActiveDate = this._activeDate;\r\n        /** @type {?} */\r\n        var isRtl = this._isRtl();\r\n        switch (event.keyCode) {\r\n            case LEFT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\r\n                break;\r\n            case RIGHT_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\r\n                break;\r\n            case UP_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\r\n                break;\r\n            case DOWN_ARROW:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\r\n                break;\r\n            case HOME:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\r\n                break;\r\n            case END:\r\n                this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\r\n                break;\r\n            case PAGE_UP:\r\n                this.activeDate =\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\r\n                break;\r\n            case PAGE_DOWN:\r\n                this.activeDate =\r\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\r\n                break;\r\n            case ENTER:\r\n            case SPACE:\r\n                this._monthSelected(this._dateAdapter.getMonth(this._activeDate));\r\n                break;\r\n            default:\r\n                // Don't prevent default or focus active cell on keys that we don't explicitly handle.\r\n                return;\r\n        }\r\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\r\n            this.activeDateChange.emit(this.activeDate);\r\n        }\r\n        this._focusActiveCell();\r\n        // Prevent unexpected default actions such as form submission.\r\n        event.preventDefault();\r\n    };\r\n    /** Initializes this year view. */\r\n    /**\r\n     * Initializes this year view.\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._init = /**\r\n     * Initializes this year view.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._selectedMonth = this._getMonthInCurrentYear(this.selected);\r\n        this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\r\n        this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\r\n        /** @type {?} */\r\n        var monthNames = this._dateAdapter.getMonthNames('short');\r\n        // First row of months only contains 5 elements so we can fit the year label on the same row.\r\n        this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map((/**\r\n         * @param {?} row\r\n         * @return {?}\r\n         */\r\n        function (row) { return row.map((/**\r\n         * @param {?} month\r\n         * @return {?}\r\n         */\r\n        function (month) { return _this._createCellForMonth(month, monthNames[month]); })); }));\r\n        this._changeDetectorRef.markForCheck();\r\n    };\r\n    /** Focuses the active cell after the microtask queue is empty. */\r\n    /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._focusActiveCell = /**\r\n     * Focuses the active cell after the microtask queue is empty.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._matCalendarBody._focusActiveCell();\r\n    };\r\n    /**\r\n     * Gets the month in this year that the given Date falls on.\r\n     * Returns null if the given Date is in another year.\r\n     */\r\n    /**\r\n     * Gets the month in this year that the given Date falls on.\r\n     * Returns null if the given Date is in another year.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._getMonthInCurrentYear = /**\r\n     * Gets the month in this year that the given Date falls on.\r\n     * Returns null if the given Date is in another year.\r\n     * @private\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?\r\n            this._dateAdapter.getMonth(date) : null;\r\n    };\r\n    /** Creates an MatCalendarCell for the given month. */\r\n    /**\r\n     * Creates an MatCalendarCell for the given month.\r\n     * @private\r\n     * @param {?} month\r\n     * @param {?} monthName\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._createCellForMonth = /**\r\n     * Creates an MatCalendarCell for the given month.\r\n     * @private\r\n     * @param {?} month\r\n     * @param {?} monthName\r\n     * @return {?}\r\n     */\r\n    function (month, monthName) {\r\n        /** @type {?} */\r\n        var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\r\n        return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));\r\n    };\r\n    /** Whether the given month is enabled. */\r\n    /**\r\n     * Whether the given month is enabled.\r\n     * @private\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._shouldEnableMonth = /**\r\n     * Whether the given month is enabled.\r\n     * @private\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    function (month) {\r\n        /** @type {?} */\r\n        var activeYear = this._dateAdapter.getYear(this.activeDate);\r\n        if (month === undefined || month === null ||\r\n            this._isYearAndMonthAfterMaxDate(activeYear, month) ||\r\n            this._isYearAndMonthBeforeMinDate(activeYear, month)) {\r\n            return false;\r\n        }\r\n        if (!this.dateFilter) {\r\n            return true;\r\n        }\r\n        /** @type {?} */\r\n        var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);\r\n        // If any date in the month is enabled count the month as enabled.\r\n        for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\r\n            if (this.dateFilter(date)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Tests whether the combination month/year is after this.maxDate, considering\r\n     * just the month and year of this.maxDate\r\n     */\r\n    /**\r\n     * Tests whether the combination month/year is after this.maxDate, considering\r\n     * just the month and year of this.maxDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._isYearAndMonthAfterMaxDate = /**\r\n     * Tests whether the combination month/year is after this.maxDate, considering\r\n     * just the month and year of this.maxDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    function (year, month) {\r\n        if (this.maxDate) {\r\n            /** @type {?} */\r\n            var maxYear = this._dateAdapter.getYear(this.maxDate);\r\n            /** @type {?} */\r\n            var maxMonth = this._dateAdapter.getMonth(this.maxDate);\r\n            return year > maxYear || (year === maxYear && month > maxMonth);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Tests whether the combination month/year is before this.minDate, considering\r\n     * just the month and year of this.minDate\r\n     */\r\n    /**\r\n     * Tests whether the combination month/year is before this.minDate, considering\r\n     * just the month and year of this.minDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._isYearAndMonthBeforeMinDate = /**\r\n     * Tests whether the combination month/year is before this.minDate, considering\r\n     * just the month and year of this.minDate\r\n     * @private\r\n     * @param {?} year\r\n     * @param {?} month\r\n     * @return {?}\r\n     */\r\n    function (year, month) {\r\n        if (this.minDate) {\r\n            /** @type {?} */\r\n            var minYear = this._dateAdapter.getYear(this.minDate);\r\n            /** @type {?} */\r\n            var minMonth = this._dateAdapter.getMonth(this.minDate);\r\n            return year < minYear || (year === minYear && month < minMonth);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatYearView.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    /** Determines whether the user has the RTL layout direction. */\r\n    /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatYearView.prototype._isRtl = /**\r\n     * Determines whether the user has the RTL layout direction.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._dir && this._dir.value === 'rtl';\r\n    };\r\n    MatYearView.decorators = [\r\n        { type: Component, args: [{selector: 'mat-year-view',\r\n                    template: \"<table class=\\\"mat-calendar-table\\\" role=\\\"presentation\\\"><thead class=\\\"mat-calendar-table-header\\\"><tr><th class=\\\"mat-calendar-table-header-divider\\\" colspan=\\\"4\\\"></th></tr></thead><tbody mat-calendar-body [label]=\\\"_yearLabel\\\" [rows]=\\\"_months\\\" [todayValue]=\\\"_todayMonth\\\" [selectedValue]=\\\"_selectedMonth\\\" [labelMinRequiredCells]=\\\"2\\\" [numCols]=\\\"4\\\" [cellAspectRatio]=\\\"4 / 7\\\" [activeCell]=\\\"_dateAdapter.getMonth(activeDate)\\\" (selectedValueChange)=\\\"_monthSelected($event)\\\" (keydown)=\\\"_handleCalendarBodyKeydown($event)\\\"></tbody></table>\",\r\n                    exportAs: 'matYearView',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatYearView.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] }\r\n    ]; };\r\n    MatYearView.propDecorators = {\r\n        activeDate: [{ type: Input }],\r\n        selected: [{ type: Input }],\r\n        minDate: [{ type: Input }],\r\n        maxDate: [{ type: Input }],\r\n        dateFilter: [{ type: Input }],\r\n        selectedChange: [{ type: Output }],\r\n        monthSelected: [{ type: Output }],\r\n        activeDateChange: [{ type: Output }],\r\n        _matCalendarBody: [{ type: ViewChild, args: [MatCalendarBody, { static: false },] }]\r\n    };\r\n    return MatYearView;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Default header for MatCalendar\r\n * @template D\r\n */\r\nvar MatCalendarHeader = /** @class */ (function () {\r\n    function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {\r\n        this._intl = _intl;\r\n        this.calendar = calendar;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dateFormats = _dateFormats;\r\n        this.calendar.stateChanges.subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return changeDetectorRef.markForCheck(); }));\r\n    }\r\n    Object.defineProperty(MatCalendarHeader.prototype, \"periodButtonText\", {\r\n        /** The label for the current calendar view. */\r\n        get: /**\r\n         * The label for the current calendar view.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this.calendar.currentView == 'month') {\r\n                return this._dateAdapter\r\n                    .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)\r\n                    .toLocaleUpperCase();\r\n            }\r\n            if (this.calendar.currentView == 'year') {\r\n                return this._dateAdapter.getYearName(this.calendar.activeDate);\r\n            }\r\n            // The offset from the active year to the \"slot\" for the starting year is the\r\n            // *actual* first rendered year in the multi-year view, and the last year is\r\n            // just yearsPerPage - 1 away.\r\n            /** @type {?} */\r\n            var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\r\n            /** @type {?} */\r\n            var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);\r\n            /** @type {?} */\r\n            var maxYearOfPage = minYearOfPage + yearsPerPage - 1;\r\n            /** @type {?} */\r\n            var minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));\r\n            /** @type {?} */\r\n            var maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));\r\n            return this._intl.formatYearRange(minYearName, maxYearName);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendarHeader.prototype, \"periodButtonLabel\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this.calendar.currentView == 'month' ?\r\n                this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendarHeader.prototype, \"prevButtonLabel\", {\r\n        /** The label for the previous button. */\r\n        get: /**\r\n         * The label for the previous button.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return {\r\n                'month': this._intl.prevMonthLabel,\r\n                'year': this._intl.prevYearLabel,\r\n                'multi-year': this._intl.prevMultiYearLabel\r\n            }[this.calendar.currentView];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendarHeader.prototype, \"nextButtonLabel\", {\r\n        /** The label for the next button. */\r\n        get: /**\r\n         * The label for the next button.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return {\r\n                'month': this._intl.nextMonthLabel,\r\n                'year': this._intl.nextYearLabel,\r\n                'multi-year': this._intl.nextMultiYearLabel\r\n            }[this.calendar.currentView];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Handles user clicks on the period label. */\r\n    /**\r\n     * Handles user clicks on the period label.\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype.currentPeriodClicked = /**\r\n     * Handles user clicks on the period label.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\r\n    };\r\n    /** Handles user clicks on the previous button. */\r\n    /**\r\n     * Handles user clicks on the previous button.\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype.previousClicked = /**\r\n     * Handles user clicks on the previous button.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.calendar.activeDate = this.calendar.currentView == 'month' ?\r\n            this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :\r\n            this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);\r\n    };\r\n    /** Handles user clicks on the next button. */\r\n    /**\r\n     * Handles user clicks on the next button.\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype.nextClicked = /**\r\n     * Handles user clicks on the next button.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.calendar.activeDate = this.calendar.currentView == 'month' ?\r\n            this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :\r\n            this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);\r\n    };\r\n    /** Whether the previous period button is enabled. */\r\n    /**\r\n     * Whether the previous period button is enabled.\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype.previousEnabled = /**\r\n     * Whether the previous period button is enabled.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this.calendar.minDate) {\r\n            return true;\r\n        }\r\n        return !this.calendar.minDate ||\r\n            !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\r\n    };\r\n    /** Whether the next period button is enabled. */\r\n    /**\r\n     * Whether the next period button is enabled.\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype.nextEnabled = /**\r\n     * Whether the next period button is enabled.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return !this.calendar.maxDate ||\r\n            !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\r\n    };\r\n    /** Whether the two dates represent the same view in the current view mode (month or year). */\r\n    /**\r\n     * Whether the two dates represent the same view in the current view mode (month or year).\r\n     * @private\r\n     * @param {?} date1\r\n     * @param {?} date2\r\n     * @return {?}\r\n     */\r\n    MatCalendarHeader.prototype._isSameView = /**\r\n     * Whether the two dates represent the same view in the current view mode (month or year).\r\n     * @private\r\n     * @param {?} date1\r\n     * @param {?} date2\r\n     * @return {?}\r\n     */\r\n    function (date1, date2) {\r\n        if (this.calendar.currentView == 'month') {\r\n            return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&\r\n                this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\r\n        }\r\n        if (this.calendar.currentView == 'year') {\r\n            return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\r\n        }\r\n        // Otherwise we are in 'multi-year' view.\r\n        return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);\r\n    };\r\n    MatCalendarHeader.decorators = [\r\n        { type: Component, args: [{selector: 'mat-calendar-header',\r\n                    template: \"<div class=\\\"mat-calendar-header\\\"><div class=\\\"mat-calendar-controls\\\"><button mat-button type=\\\"button\\\" class=\\\"mat-calendar-period-button\\\" (click)=\\\"currentPeriodClicked()\\\" [attr.aria-label]=\\\"periodButtonLabel\\\" cdkAriaLive=\\\"polite\\\">{{periodButtonText}}<div class=\\\"mat-calendar-arrow\\\" [class.mat-calendar-invert]=\\\"calendar.currentView != 'month'\\\"></div></button><div class=\\\"mat-calendar-spacer\\\"></div><ng-content></ng-content><button mat-icon-button type=\\\"button\\\" class=\\\"mat-calendar-previous-button\\\" [disabled]=\\\"!previousEnabled()\\\" (click)=\\\"previousClicked()\\\" [attr.aria-label]=\\\"prevButtonLabel\\\"></button> <button mat-icon-button type=\\\"button\\\" class=\\\"mat-calendar-next-button\\\" [disabled]=\\\"!nextEnabled()\\\" (click)=\\\"nextClicked()\\\" [attr.aria-label]=\\\"nextButtonLabel\\\"></button></div></div>\",\r\n                    exportAs: 'matCalendarHeader',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatCalendarHeader.ctorParameters = function () { return [\r\n        { type: MatDatepickerIntl },\r\n        { type: MatCalendar, decorators: [{ type: Inject, args: [forwardRef((/**\r\n                         * @return {?}\r\n                         */\r\n                        function () { return MatCalendar; })),] }] },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },\r\n        { type: ChangeDetectorRef }\r\n    ]; };\r\n    return MatCalendarHeader;\r\n}());\r\n/**\r\n * A calendar that is used as part of the datepicker.\r\n * \\@docs-private\r\n * @template D\r\n */\r\nvar MatCalendar = /** @class */ (function () {\r\n    function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {\r\n        var _this = this;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dateFormats = _dateFormats;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        /**\r\n         * Used for scheduling that focus should be moved to the active cell on the next tick.\r\n         * We need to schedule it, rather than do it immediately, because we have to wait\r\n         * for Angular to re-evaluate the view children.\r\n         */\r\n        this._moveFocusOnNextTick = false;\r\n        /**\r\n         * Whether the calendar should be started in month or year view.\r\n         */\r\n        this.startView = 'month';\r\n        /**\r\n         * Emits when the currently selected date changes.\r\n         */\r\n        this.selectedChange = new EventEmitter();\r\n        /**\r\n         * Emits the year chosen in multiyear view.\r\n         * This doesn't imply a change on the selected date.\r\n         */\r\n        this.yearSelected = new EventEmitter();\r\n        /**\r\n         * Emits the month chosen in year view.\r\n         * This doesn't imply a change on the selected date.\r\n         */\r\n        this.monthSelected = new EventEmitter();\r\n        /**\r\n         * Emits when any date is selected.\r\n         */\r\n        this._userSelection = new EventEmitter();\r\n        /**\r\n         * Emits whenever there is a state change that the header may need to respond to.\r\n         */\r\n        this.stateChanges = new Subject();\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        if (!this._dateFormats) {\r\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\r\n        }\r\n        this._intlChanges = _intl.changes.subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _changeDetectorRef.markForCheck();\r\n            _this.stateChanges.next();\r\n        }));\r\n    }\r\n    Object.defineProperty(MatCalendar.prototype, \"startAt\", {\r\n        /** A date representing the period (month or year) to start the calendar in. */\r\n        get: /**\r\n         * A date representing the period (month or year) to start the calendar in.\r\n         * @return {?}\r\n         */\r\n        function () { return this._startAt; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendar.prototype, \"selected\", {\r\n        /** The currently selected date. */\r\n        get: /**\r\n         * The currently selected date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._selected; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendar.prototype, \"minDate\", {\r\n        /** The minimum selectable date. */\r\n        get: /**\r\n         * The minimum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._minDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendar.prototype, \"maxDate\", {\r\n        /** The maximum selectable date. */\r\n        get: /**\r\n         * The maximum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._maxDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendar.prototype, \"activeDate\", {\r\n        /**\r\n         * The current active date. This determines which time period is shown and which date is\r\n         * highlighted when using keyboard navigation.\r\n         */\r\n        get: /**\r\n         * The current active date. This determines which time period is shown and which date is\r\n         * highlighted when using keyboard navigation.\r\n         * @return {?}\r\n         */\r\n        function () { return this._clampedActiveDate; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\r\n            this.stateChanges.next();\r\n            this._changeDetectorRef.markForCheck();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatCalendar.prototype, \"currentView\", {\r\n        /** Whether the calendar is in month view. */\r\n        get: /**\r\n         * Whether the calendar is in month view.\r\n         * @return {?}\r\n         */\r\n        function () { return this._currentView; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._currentView = value;\r\n            this._moveFocusOnNextTick = true;\r\n            this._changeDetectorRef.markForCheck();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\r\n        this.activeDate = this.startAt || this._dateAdapter.today();\r\n        // Assign to the private property since we don't want to move focus on init.\r\n        this._currentView = this.startView;\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.ngAfterViewChecked = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._moveFocusOnNextTick) {\r\n            this._moveFocusOnNextTick = false;\r\n            this.focusActiveCell();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._intlChanges.unsubscribe();\r\n        this.stateChanges.complete();\r\n    };\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        /** @type {?} */\r\n        var change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];\r\n        if (change && !change.firstChange) {\r\n            /** @type {?} */\r\n            var view = this._getCurrentViewComponent();\r\n            if (view) {\r\n                // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are\r\n                // passed down to the view via data bindings which won't be up-to-date when we call `_init`.\r\n                this._changeDetectorRef.detectChanges();\r\n                view._init();\r\n            }\r\n        }\r\n        this.stateChanges.next();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.focusActiveCell = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._getCurrentViewComponent()._focusActiveCell();\r\n    };\r\n    /** Updates today's date after an update of the active date */\r\n    /**\r\n     * Updates today's date after an update of the active date\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype.updateTodaysDate = /**\r\n     * Updates today's date after an update of the active date\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var view = this.currentView == 'month' ? this.monthView :\r\n            (this.currentView == 'year' ? this.yearView : this.multiYearView);\r\n        view.ngAfterContentInit();\r\n    };\r\n    /** Handles date selection in the month view. */\r\n    /**\r\n     * Handles date selection in the month view.\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._dateSelected = /**\r\n     * Handles date selection in the month view.\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        if (!this._dateAdapter.sameDate(date, this.selected)) {\r\n            this.selectedChange.emit(date);\r\n        }\r\n    };\r\n    /** Handles year selection in the multiyear view. */\r\n    /**\r\n     * Handles year selection in the multiyear view.\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._yearSelectedInMultiYearView = /**\r\n     * Handles year selection in the multiyear view.\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\r\n    function (normalizedYear) {\r\n        this.yearSelected.emit(normalizedYear);\r\n    };\r\n    /** Handles month selection in the year view. */\r\n    /**\r\n     * Handles month selection in the year view.\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._monthSelectedInYearView = /**\r\n     * Handles month selection in the year view.\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\r\n    function (normalizedMonth) {\r\n        this.monthSelected.emit(normalizedMonth);\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._userSelected = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._userSelection.emit();\r\n    };\r\n    /** Handles year/month selection in the multi-year/year views. */\r\n    /**\r\n     * Handles year/month selection in the multi-year/year views.\r\n     * @param {?} date\r\n     * @param {?} view\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._goToDateInView = /**\r\n     * Handles year/month selection in the multi-year/year views.\r\n     * @param {?} date\r\n     * @param {?} view\r\n     * @return {?}\r\n     */\r\n    function (date, view) {\r\n        this.activeDate = date;\r\n        this.currentView = view;\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatCalendar.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    /** Returns the component instance that corresponds to the current calendar view. */\r\n    /**\r\n     * Returns the component instance that corresponds to the current calendar view.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatCalendar.prototype._getCurrentViewComponent = /**\r\n     * Returns the component instance that corresponds to the current calendar view.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.monthView || this.yearView || this.multiYearView;\r\n    };\r\n    MatCalendar.decorators = [\r\n        { type: Component, args: [{selector: 'mat-calendar',\r\n                    template: \"<ng-template [cdkPortalOutlet]=\\\"_calendarHeaderPortal\\\"></ng-template><div class=\\\"mat-calendar-content\\\" [ngSwitch]=\\\"currentView\\\" cdkMonitorSubtreeFocus tabindex=\\\"-1\\\"><mat-month-view *ngSwitchCase=\\\"'month'\\\" [(activeDate)]=\\\"activeDate\\\" [selected]=\\\"selected\\\" [dateFilter]=\\\"dateFilter\\\" [maxDate]=\\\"maxDate\\\" [minDate]=\\\"minDate\\\" [dateClass]=\\\"dateClass\\\" (selectedChange)=\\\"_dateSelected($event)\\\" (_userSelection)=\\\"_userSelected()\\\"></mat-month-view><mat-year-view *ngSwitchCase=\\\"'year'\\\" [(activeDate)]=\\\"activeDate\\\" [selected]=\\\"selected\\\" [dateFilter]=\\\"dateFilter\\\" [maxDate]=\\\"maxDate\\\" [minDate]=\\\"minDate\\\" (monthSelected)=\\\"_monthSelectedInYearView($event)\\\" (selectedChange)=\\\"_goToDateInView($event, 'month')\\\"></mat-year-view><mat-multi-year-view *ngSwitchCase=\\\"'multi-year'\\\" [(activeDate)]=\\\"activeDate\\\" [selected]=\\\"selected\\\" [dateFilter]=\\\"dateFilter\\\" [maxDate]=\\\"maxDate\\\" [minDate]=\\\"minDate\\\" (yearSelected)=\\\"_yearSelectedInMultiYearView($event)\\\" (selectedChange)=\\\"_goToDateInView($event, 'year')\\\"></mat-multi-year-view></div>\",\r\n                    styles: [\".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}\"],\r\n                    host: {\r\n                        'class': 'mat-calendar',\r\n                    },\r\n                    exportAs: 'matCalendar',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatCalendar.ctorParameters = function () { return [\r\n        { type: MatDatepickerIntl },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },\r\n        { type: ChangeDetectorRef }\r\n    ]; };\r\n    MatCalendar.propDecorators = {\r\n        headerComponent: [{ type: Input }],\r\n        startAt: [{ type: Input }],\r\n        startView: [{ type: Input }],\r\n        selected: [{ type: Input }],\r\n        minDate: [{ type: Input }],\r\n        maxDate: [{ type: Input }],\r\n        dateFilter: [{ type: Input }],\r\n        dateClass: [{ type: Input }],\r\n        selectedChange: [{ type: Output }],\r\n        yearSelected: [{ type: Output }],\r\n        monthSelected: [{ type: Output }],\r\n        _userSelection: [{ type: Output }],\r\n        monthView: [{ type: ViewChild, args: [MatMonthView, { static: false },] }],\r\n        yearView: [{ type: ViewChild, args: [MatYearView, { static: false },] }],\r\n        multiYearView: [{ type: ViewChild, args: [MatMultiYearView, { static: false },] }]\r\n    };\r\n    return MatCalendar;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Animations used by the Material datepicker.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar matDatepickerAnimations = {\r\n    /**\r\n     * Transforms the height of the datepicker's calendar.\r\n     */\r\n    transformPanel: trigger('transformPanel', [\r\n        state('void', style({\r\n            opacity: 0,\r\n            transform: 'scale(1, 0.8)'\r\n        })),\r\n        transition('void => enter', animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({\r\n            opacity: 1,\r\n            transform: 'scale(1, 1)'\r\n        }))),\r\n        transition('* => void', animate('100ms linear', style({ opacity: 0 })))\r\n    ]),\r\n    /**\r\n     * Fades in the content of the calendar.\r\n     */\r\n    fadeInCalendar: trigger('fadeInCalendar', [\r\n        state('void', style({ opacity: 0 })),\r\n        state('enter', style({ opacity: 1 })),\r\n        // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we\r\n        // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.\r\n        transition('void => *', animate('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))\r\n    ])\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Used to generate a unique ID for each datepicker instance.\r\n * @type {?}\r\n */\r\nvar datepickerUid = 0;\r\n/**\r\n * Injection token that determines the scroll handling while the calendar is open.\r\n * @type {?}\r\n */\r\nvar MAT_DATEPICKER_SCROLL_STRATEGY = new InjectionToken('mat-datepicker-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return (/**\r\n     * @return {?}\r\n     */\r\n    function () { return overlay.scrollStrategies.reposition(); });\r\n}\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_DATEPICKER_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,\r\n};\r\n// Boilerplate for applying mixins to MatDatepickerContent.\r\n/**\r\n * \\@docs-private\r\n */\r\nvar \r\n// Boilerplate for applying mixins to MatDatepickerContent.\r\n/**\r\n * \\@docs-private\r\n */\r\nMatDatepickerContentBase = /** @class */ (function () {\r\n    function MatDatepickerContentBase(_elementRef) {\r\n        this._elementRef = _elementRef;\r\n    }\r\n    return MatDatepickerContentBase;\r\n}());\r\n/** @type {?} */\r\nvar _MatDatepickerContentMixinBase = mixinColor(MatDatepickerContentBase);\r\n/**\r\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\r\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\r\n * place to put additional features of the popup that are not part of the calendar itself in the\r\n * future. (e.g. confirmation buttons).\r\n * \\@docs-private\r\n * @template D\r\n */\r\nvar MatDatepickerContent = /** @class */ (function (_super) {\r\n    __extends(MatDatepickerContent, _super);\r\n    function MatDatepickerContent(elementRef) {\r\n        return _super.call(this, elementRef) || this;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepickerContent.prototype.ngAfterViewInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._calendar.focusActiveCell();\r\n    };\r\n    MatDatepickerContent.decorators = [\r\n        { type: Component, args: [{selector: 'mat-datepicker-content',\r\n                    template: \"<mat-calendar cdkTrapFocus [id]=\\\"datepicker.id\\\" [ngClass]=\\\"datepicker.panelClass\\\" [startAt]=\\\"datepicker.startAt\\\" [startView]=\\\"datepicker.startView\\\" [minDate]=\\\"datepicker._minDate\\\" [maxDate]=\\\"datepicker._maxDate\\\" [dateFilter]=\\\"datepicker._dateFilter\\\" [headerComponent]=\\\"datepicker.calendarHeaderComponent\\\" [selected]=\\\"datepicker._selected\\\" [dateClass]=\\\"datepicker.dateClass\\\" [@fadeInCalendar]=\\\"'enter'\\\" (selectedChange)=\\\"datepicker.select($event)\\\" (yearSelected)=\\\"datepicker._selectYear($event)\\\" (monthSelected)=\\\"datepicker._selectMonth($event)\\\" (_userSelection)=\\\"datepicker.close()\\\"></mat-calendar>\",\r\n                    styles: [\".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}\"],\r\n                    host: {\r\n                        'class': 'mat-datepicker-content',\r\n                        '[@transformPanel]': '\"enter\"',\r\n                        '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',\r\n                    },\r\n                    animations: [\r\n                        matDatepickerAnimations.transformPanel,\r\n                        matDatepickerAnimations.fadeInCalendar,\r\n                    ],\r\n                    exportAs: 'matDatepickerContent',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    inputs: ['color'],\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDatepickerContent.ctorParameters = function () { return [\r\n        { type: ElementRef }\r\n    ]; };\r\n    MatDatepickerContent.propDecorators = {\r\n        _calendar: [{ type: ViewChild, args: [MatCalendar, { static: false },] }]\r\n    };\r\n    return MatDatepickerContent;\r\n}(_MatDatepickerContentMixinBase));\r\n// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\r\n// template reference variables (e.g. #d vs #d=\"matDatepicker\"). We can change this to a directive\r\n// if angular adds support for `exportAs: '$implicit'` on directives.\r\n/**\r\n * Component responsible for managing the datepicker popup/dialog.\r\n * @template D\r\n */\r\nvar MatDatepicker = /** @class */ (function () {\r\n    function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {\r\n        this._dialog = _dialog;\r\n        this._overlay = _overlay;\r\n        this._ngZone = _ngZone;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dir = _dir;\r\n        this._document = _document;\r\n        /**\r\n         * The view that the calendar should start in.\r\n         */\r\n        this.startView = 'month';\r\n        this._touchUi = false;\r\n        /**\r\n         * Emits selected year in multiyear view.\r\n         * This doesn't imply a change on the selected date.\r\n         */\r\n        this.yearSelected = new EventEmitter();\r\n        /**\r\n         * Emits selected month in year view.\r\n         * This doesn't imply a change on the selected date.\r\n         */\r\n        this.monthSelected = new EventEmitter();\r\n        /**\r\n         * Emits when the datepicker has been opened.\r\n         */\r\n        this.openedStream = new EventEmitter();\r\n        /**\r\n         * Emits when the datepicker has been closed.\r\n         */\r\n        this.closedStream = new EventEmitter();\r\n        this._opened = false;\r\n        /**\r\n         * The id for the datepicker calendar.\r\n         */\r\n        this.id = \"mat-datepicker-\" + datepickerUid++;\r\n        this._validSelected = null;\r\n        /**\r\n         * The element that was focused before the datepicker was opened.\r\n         */\r\n        this._focusedElementBeforeOpen = null;\r\n        /**\r\n         * Subscription to value changes in the associated input element.\r\n         */\r\n        this._inputSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Emits when the datepicker is disabled.\r\n         */\r\n        this._disabledChange = new Subject();\r\n        /**\r\n         * Emits new selected date when selected date changes.\r\n         */\r\n        this._selectedChanged = new Subject();\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    Object.defineProperty(MatDatepicker.prototype, \"startAt\", {\r\n        /** The date to open the calendar to initially. */\r\n        get: /**\r\n         * The date to open the calendar to initially.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // If an explicit startAt is set we start there, otherwise we start at whatever the currently\r\n            // selected value is.\r\n            return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"color\", {\r\n        /** Color palette to use on the datepicker's calendar. */\r\n        get: /**\r\n         * Color palette to use on the datepicker's calendar.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._color ||\r\n                (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._color = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"touchUi\", {\r\n        /**\r\n         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\r\n         * than a popup and elements have more padding to allow for bigger touch targets.\r\n         */\r\n        get: /**\r\n         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\r\n         * than a popup and elements have more padding to allow for bigger touch targets.\r\n         * @return {?}\r\n         */\r\n        function () { return this._touchUi; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._touchUi = coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"disabled\", {\r\n        /** Whether the datepicker pop-up should be disabled. */\r\n        get: /**\r\n         * Whether the datepicker pop-up should be disabled.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._disabled === undefined && this._datepickerInput ?\r\n                this._datepickerInput.disabled : !!this._disabled;\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            /** @type {?} */\r\n            var newValue = coerceBooleanProperty(value);\r\n            if (newValue !== this._disabled) {\r\n                this._disabled = newValue;\r\n                this._disabledChange.next(newValue);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"opened\", {\r\n        /** Whether the calendar is open. */\r\n        get: /**\r\n         * Whether the calendar is open.\r\n         * @return {?}\r\n         */\r\n        function () { return this._opened; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { value ? this.open() : this.close(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"_selected\", {\r\n        /** The currently selected date. */\r\n        get: /**\r\n         * The currently selected date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._validSelected; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._validSelected = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"_minDate\", {\r\n        /** The minimum selectable date. */\r\n        get: /**\r\n         * The minimum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._datepickerInput && this._datepickerInput.min;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"_maxDate\", {\r\n        /** The maximum selectable date. */\r\n        get: /**\r\n         * The maximum selectable date.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._datepickerInput && this._datepickerInput.max;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepicker.prototype, \"_dateFilter\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._datepickerInput && this._datepickerInput._dateFilter;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.close();\r\n        this._inputSubscription.unsubscribe();\r\n        this._disabledChange.complete();\r\n        if (this._popupRef) {\r\n            this._popupRef.dispose();\r\n            this._popupComponentRef = null;\r\n        }\r\n    };\r\n    /** Selects the given date */\r\n    /**\r\n     * Selects the given date\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype.select = /**\r\n     * Selects the given date\r\n     * @param {?} date\r\n     * @return {?}\r\n     */\r\n    function (date) {\r\n        /** @type {?} */\r\n        var oldValue = this._selected;\r\n        this._selected = date;\r\n        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {\r\n            this._selectedChanged.next(date);\r\n        }\r\n    };\r\n    /** Emits the selected year in multiyear view */\r\n    /**\r\n     * Emits the selected year in multiyear view\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._selectYear = /**\r\n     * Emits the selected year in multiyear view\r\n     * @param {?} normalizedYear\r\n     * @return {?}\r\n     */\r\n    function (normalizedYear) {\r\n        this.yearSelected.emit(normalizedYear);\r\n    };\r\n    /** Emits selected month in year view */\r\n    /**\r\n     * Emits selected month in year view\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._selectMonth = /**\r\n     * Emits selected month in year view\r\n     * @param {?} normalizedMonth\r\n     * @return {?}\r\n     */\r\n    function (normalizedMonth) {\r\n        this.monthSelected.emit(normalizedMonth);\r\n    };\r\n    /**\r\n     * Register an input with this datepicker.\r\n     * @param input The datepicker input to register with this datepicker.\r\n     */\r\n    /**\r\n     * Register an input with this datepicker.\r\n     * @param {?} input The datepicker input to register with this datepicker.\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._registerInput = /**\r\n     * Register an input with this datepicker.\r\n     * @param {?} input The datepicker input to register with this datepicker.\r\n     * @return {?}\r\n     */\r\n    function (input) {\r\n        var _this = this;\r\n        if (this._datepickerInput) {\r\n            throw Error('A MatDatepicker can only be associated with a single input.');\r\n        }\r\n        this._datepickerInput = input;\r\n        this._inputSubscription =\r\n            this._datepickerInput._valueChange.subscribe((/**\r\n             * @param {?} value\r\n             * @return {?}\r\n             */\r\n            function (value) { return _this._selected = value; }));\r\n    };\r\n    /** Open the calendar. */\r\n    /**\r\n     * Open the calendar.\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype.open = /**\r\n     * Open the calendar.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._opened || this.disabled) {\r\n            return;\r\n        }\r\n        if (!this._datepickerInput) {\r\n            throw Error('Attempted to open an MatDatepicker with no associated input.');\r\n        }\r\n        if (this._document) {\r\n            this._focusedElementBeforeOpen = this._document.activeElement;\r\n        }\r\n        this.touchUi ? this._openAsDialog() : this._openAsPopup();\r\n        this._opened = true;\r\n        this.openedStream.emit();\r\n    };\r\n    /** Close the calendar. */\r\n    /**\r\n     * Close the calendar.\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype.close = /**\r\n     * Close the calendar.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (!this._opened) {\r\n            return;\r\n        }\r\n        if (this._popupRef && this._popupRef.hasAttached()) {\r\n            this._popupRef.detach();\r\n        }\r\n        if (this._dialogRef) {\r\n            this._dialogRef.close();\r\n            this._dialogRef = null;\r\n        }\r\n        if (this._calendarPortal && this._calendarPortal.isAttached) {\r\n            this._calendarPortal.detach();\r\n        }\r\n        /** @type {?} */\r\n        var completeClose = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // The `_opened` could've been reset already if\r\n            // we got two events in quick succession.\r\n            if (_this._opened) {\r\n                _this._opened = false;\r\n                _this.closedStream.emit();\r\n                _this._focusedElementBeforeOpen = null;\r\n            }\r\n        });\r\n        if (this._focusedElementBeforeOpen &&\r\n            typeof this._focusedElementBeforeOpen.focus === 'function') {\r\n            // Because IE moves focus asynchronously, we can't count on it being restored before we've\r\n            // marked the datepicker as closed. If the event fires out of sequence and the element that\r\n            // we're refocusing opens the datepicker on focus, the user could be stuck with not being\r\n            // able to close the calendar at all. We work around it by making the logic, that marks\r\n            // the datepicker as closed, async as well.\r\n            this._focusedElementBeforeOpen.focus();\r\n            setTimeout(completeClose);\r\n        }\r\n        else {\r\n            completeClose();\r\n        }\r\n    };\r\n    /** Open the calendar as a dialog. */\r\n    /**\r\n     * Open the calendar as a dialog.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._openAsDialog = /**\r\n     * Open the calendar as a dialog.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // Usually this would be handled by `open` which ensures that we can only have one overlay\r\n        // open at a time, however since we reset the variables in async handlers some overlays\r\n        // may slip through if the user opens and closes multiple times in quick succession (e.g.\r\n        // by holding down the enter key).\r\n        if (this._dialogRef) {\r\n            this._dialogRef.close();\r\n        }\r\n        this._dialogRef = this._dialog.open(MatDatepickerContent, {\r\n            direction: this._dir ? this._dir.value : 'ltr',\r\n            viewContainerRef: this._viewContainerRef,\r\n            panelClass: 'mat-datepicker-dialog',\r\n        });\r\n        this._dialogRef.afterClosed().subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this.close(); }));\r\n        this._dialogRef.componentInstance.datepicker = this;\r\n        this._setColor();\r\n    };\r\n    /** Open the calendar as a popup. */\r\n    /**\r\n     * Open the calendar as a popup.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._openAsPopup = /**\r\n     * Open the calendar as a popup.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (!this._calendarPortal) {\r\n            this._calendarPortal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);\r\n        }\r\n        if (!this._popupRef) {\r\n            this._createPopup();\r\n        }\r\n        if (!this._popupRef.hasAttached()) {\r\n            this._popupComponentRef = this._popupRef.attach(this._calendarPortal);\r\n            this._popupComponentRef.instance.datepicker = this;\r\n            this._setColor();\r\n            // Update the position once the calendar has rendered.\r\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this._popupRef.updatePosition();\r\n            }));\r\n        }\r\n    };\r\n    /** Create the popup. */\r\n    /**\r\n     * Create the popup.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._createPopup = /**\r\n     * Create the popup.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        /** @type {?} */\r\n        var overlayConfig = new OverlayConfig({\r\n            positionStrategy: this._createPopupPositionStrategy(),\r\n            hasBackdrop: true,\r\n            backdropClass: 'mat-overlay-transparent-backdrop',\r\n            direction: this._dir,\r\n            scrollStrategy: this._scrollStrategy(),\r\n            panelClass: 'mat-datepicker-popup',\r\n        });\r\n        this._popupRef = this._overlay.create(overlayConfig);\r\n        this._popupRef.overlayElement.setAttribute('role', 'dialog');\r\n        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            // Closing on alt + up is only valid when there's an input associated with the datepicker.\r\n            return event.keyCode === ESCAPE ||\r\n                (_this._datepickerInput && event.altKey && event.keyCode === UP_ARROW);\r\n        })))).subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            if (event) {\r\n                event.preventDefault();\r\n            }\r\n            _this.close();\r\n        }));\r\n    };\r\n    /** Create the popup PositionStrategy. */\r\n    /**\r\n     * Create the popup PositionStrategy.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._createPopupPositionStrategy = /**\r\n     * Create the popup PositionStrategy.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._overlay.position()\r\n            .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())\r\n            .withTransformOriginOn('.mat-datepicker-content')\r\n            .withFlexibleDimensions(false)\r\n            .withViewportMargin(8)\r\n            .withLockedPosition()\r\n            .withPositions([\r\n            {\r\n                originX: 'start',\r\n                originY: 'bottom',\r\n                overlayX: 'start',\r\n                overlayY: 'top'\r\n            },\r\n            {\r\n                originX: 'start',\r\n                originY: 'top',\r\n                overlayX: 'start',\r\n                overlayY: 'bottom'\r\n            },\r\n            {\r\n                originX: 'end',\r\n                originY: 'bottom',\r\n                overlayX: 'end',\r\n                overlayY: 'top'\r\n            },\r\n            {\r\n                originX: 'end',\r\n                originY: 'top',\r\n                overlayX: 'end',\r\n                overlayY: 'bottom'\r\n            }\r\n        ]);\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatDatepicker.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    /** Passes the current theme color along to the calendar overlay. */\r\n    /**\r\n     * Passes the current theme color along to the calendar overlay.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepicker.prototype._setColor = /**\r\n     * Passes the current theme color along to the calendar overlay.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var color = this.color;\r\n        if (this._popupComponentRef) {\r\n            this._popupComponentRef.instance.color = color;\r\n        }\r\n        if (this._dialogRef) {\r\n            this._dialogRef.componentInstance.color = color;\r\n        }\r\n    };\r\n    MatDatepicker.decorators = [\r\n        { type: Component, args: [{selector: 'mat-datepicker',\r\n                    template: '',\r\n                    exportAs: 'matDatepicker',\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDatepicker.ctorParameters = function () { return [\r\n        { type: MatDialog },\r\n        { type: Overlay },\r\n        { type: NgZone },\r\n        { type: ViewContainerRef },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n    ]; };\r\n    MatDatepicker.propDecorators = {\r\n        calendarHeaderComponent: [{ type: Input }],\r\n        startAt: [{ type: Input }],\r\n        startView: [{ type: Input }],\r\n        color: [{ type: Input }],\r\n        touchUi: [{ type: Input }],\r\n        disabled: [{ type: Input }],\r\n        yearSelected: [{ type: Output }],\r\n        monthSelected: [{ type: Output }],\r\n        panelClass: [{ type: Input }],\r\n        dateClass: [{ type: Input }],\r\n        openedStream: [{ type: Output, args: ['opened',] }],\r\n        closedStream: [{ type: Output, args: ['closed',] }],\r\n        opened: [{ type: Input }]\r\n    };\r\n    return MatDatepicker;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_DATEPICKER_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef((/**\r\n     * @return {?}\r\n     */\r\n    function () { return MatDatepickerInput; })),\r\n    multi: true\r\n};\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_DATEPICKER_VALIDATORS = {\r\n    provide: NG_VALIDATORS,\r\n    useExisting: forwardRef((/**\r\n     * @return {?}\r\n     */\r\n    function () { return MatDatepickerInput; })),\r\n    multi: true\r\n};\r\n/**\r\n * An event used for datepicker input and change events. We don't always have access to a native\r\n * input or change event because the event may have been triggered by the user clicking on the\r\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\r\n * @template D\r\n */\r\nvar  /**\r\n * An event used for datepicker input and change events. We don't always have access to a native\r\n * input or change event because the event may have been triggered by the user clicking on the\r\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\r\n * @template D\r\n */\r\nMatDatepickerInputEvent = /** @class */ (function () {\r\n    function MatDatepickerInputEvent(target, targetElement) {\r\n        this.target = target;\r\n        this.targetElement = targetElement;\r\n        this.value = this.target.value;\r\n    }\r\n    return MatDatepickerInputEvent;\r\n}());\r\n/**\r\n * Directive used to connect an input to a MatDatepicker.\r\n * @template D\r\n */\r\nvar MatDatepickerInput = /** @class */ (function () {\r\n    function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {\r\n        var _this = this;\r\n        this._elementRef = _elementRef;\r\n        this._dateAdapter = _dateAdapter;\r\n        this._dateFormats = _dateFormats;\r\n        this._formField = _formField;\r\n        /**\r\n         * Emits when a `change` event is fired on this `<input>`.\r\n         */\r\n        this.dateChange = new EventEmitter();\r\n        /**\r\n         * Emits when an `input` event is fired on this `<input>`.\r\n         */\r\n        this.dateInput = new EventEmitter();\r\n        /**\r\n         * Emits when the value changes (either due to user input or programmatic change).\r\n         */\r\n        this._valueChange = new EventEmitter();\r\n        /**\r\n         * Emits when the disabled state has changed\r\n         */\r\n        this._disabledChange = new EventEmitter();\r\n        this._onTouched = (/**\r\n         * @return {?}\r\n         */\r\n        function () { });\r\n        this._cvaOnChange = (/**\r\n         * @return {?}\r\n         */\r\n        function () { });\r\n        this._validatorOnChange = (/**\r\n         * @return {?}\r\n         */\r\n        function () { });\r\n        this._datepickerSubscription = Subscription.EMPTY;\r\n        this._localeSubscription = Subscription.EMPTY;\r\n        /**\r\n         * The form control validator for whether the input parses.\r\n         */\r\n        this._parseValidator = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return _this._lastValueValid ?\r\n                null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };\r\n        });\r\n        /**\r\n         * The form control validator for the min date.\r\n         */\r\n        this._minValidator = (/**\r\n         * @param {?} control\r\n         * @return {?}\r\n         */\r\n        function (control) {\r\n            /** @type {?} */\r\n            var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\r\n            return (!_this.min || !controlValue ||\r\n                _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?\r\n                null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };\r\n        });\r\n        /**\r\n         * The form control validator for the max date.\r\n         */\r\n        this._maxValidator = (/**\r\n         * @param {?} control\r\n         * @return {?}\r\n         */\r\n        function (control) {\r\n            /** @type {?} */\r\n            var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\r\n            return (!_this.max || !controlValue ||\r\n                _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?\r\n                null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };\r\n        });\r\n        /**\r\n         * The form control validator for the date filter.\r\n         */\r\n        this._filterValidator = (/**\r\n         * @param {?} control\r\n         * @return {?}\r\n         */\r\n        function (control) {\r\n            /** @type {?} */\r\n            var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\r\n            return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?\r\n                null : { 'matDatepickerFilter': true };\r\n        });\r\n        /**\r\n         * The combined form control validator for this input.\r\n         */\r\n        this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);\r\n        /**\r\n         * Whether the last value set on the input was valid.\r\n         */\r\n        this._lastValueValid = false;\r\n        if (!this._dateAdapter) {\r\n            throw createMissingDateImplError('DateAdapter');\r\n        }\r\n        if (!this._dateFormats) {\r\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\r\n        }\r\n        // Update the displayed date when the locale changes.\r\n        this._localeSubscription = _dateAdapter.localeChanges.subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this.value = _this.value;\r\n        }));\r\n    }\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"matDatepicker\", {\r\n        /** The datepicker that this input is associated with. */\r\n        set: /**\r\n         * The datepicker that this input is associated with.\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            var _this = this;\r\n            if (!value) {\r\n                return;\r\n            }\r\n            this._datepicker = value;\r\n            this._datepicker._registerInput(this);\r\n            this._datepickerSubscription.unsubscribe();\r\n            this._datepickerSubscription = this._datepicker._selectedChanged.subscribe((/**\r\n             * @param {?} selected\r\n             * @return {?}\r\n             */\r\n            function (selected) {\r\n                _this.value = selected;\r\n                _this._cvaOnChange(selected);\r\n                _this._onTouched();\r\n                _this.dateInput.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));\r\n                _this.dateChange.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));\r\n            }));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"matDatepickerFilter\", {\r\n        /** Function that can be used to filter out dates within the datepicker. */\r\n        set: /**\r\n         * Function that can be used to filter out dates within the datepicker.\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._dateFilter = value;\r\n            this._validatorOnChange();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"value\", {\r\n        /** The value of the input. */\r\n        get: /**\r\n         * The value of the input.\r\n         * @return {?}\r\n         */\r\n        function () { return this._value; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            value = this._dateAdapter.deserialize(value);\r\n            this._lastValueValid = !value || this._dateAdapter.isValid(value);\r\n            value = this._getValidDateOrNull(value);\r\n            /** @type {?} */\r\n            var oldDate = this.value;\r\n            this._value = value;\r\n            this._formatValue(value);\r\n            if (!this._dateAdapter.sameDate(oldDate, value)) {\r\n                this._valueChange.emit(value);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"min\", {\r\n        /** The minimum valid date. */\r\n        get: /**\r\n         * The minimum valid date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._min; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n            this._validatorOnChange();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"max\", {\r\n        /** The maximum valid date. */\r\n        get: /**\r\n         * The maximum valid date.\r\n         * @return {?}\r\n         */\r\n        function () { return this._max; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\r\n            this._validatorOnChange();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDatepickerInput.prototype, \"disabled\", {\r\n        /** Whether the datepicker-input is disabled. */\r\n        get: /**\r\n         * Whether the datepicker-input is disabled.\r\n         * @return {?}\r\n         */\r\n        function () { return !!this._disabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            /** @type {?} */\r\n            var newValue = coerceBooleanProperty(value);\r\n            /** @type {?} */\r\n            var element = this._elementRef.nativeElement;\r\n            if (this._disabled !== newValue) {\r\n                this._disabled = newValue;\r\n                this._disabledChange.emit(newValue);\r\n            }\r\n            // We need to null check the `blur` method, because it's undefined during SSR.\r\n            if (newValue && element.blur) {\r\n                // Normally, native input elements automatically blur if they turn disabled. This behavior\r\n                // is problematic, because it would mean that it triggers another change detection cycle,\r\n                // which then causes a changed after checked error if the input element was focused before.\r\n                element.blur();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._datepickerSubscription.unsubscribe();\r\n        this._localeSubscription.unsubscribe();\r\n        this._valueChange.complete();\r\n        this._disabledChange.complete();\r\n    };\r\n    /** @docs-private */\r\n    /**\r\n     * \\@docs-private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.registerOnValidatorChange = /**\r\n     * \\@docs-private\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        this._validatorOnChange = fn;\r\n    };\r\n    /** @docs-private */\r\n    /**\r\n     * \\@docs-private\r\n     * @param {?} c\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.validate = /**\r\n     * \\@docs-private\r\n     * @param {?} c\r\n     * @return {?}\r\n     */\r\n    function (c) {\r\n        return this._validator ? this._validator(c) : null;\r\n    };\r\n    /**\r\n     * @deprecated\r\n     * @breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\r\n     */\r\n    /**\r\n     * @deprecated\r\n     * \\@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.getPopupConnectionElementRef = /**\r\n     * @deprecated\r\n     * \\@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.getConnectedOverlayOrigin();\r\n    };\r\n    /**\r\n     * Gets the element that the datepicker popup should be connected to.\r\n     * @return The element to connect the popup to.\r\n     */\r\n    /**\r\n     * Gets the element that the datepicker popup should be connected to.\r\n     * @return {?} The element to connect the popup to.\r\n     */\r\n    MatDatepickerInput.prototype.getConnectedOverlayOrigin = /**\r\n     * Gets the element that the datepicker popup should be connected to.\r\n     * @return {?} The element to connect the popup to.\r\n     */\r\n    function () {\r\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.writeValue = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        this.value = value;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.registerOnChange = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        this._cvaOnChange = fn;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.registerOnTouched = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        this._onTouched = fn;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype.setDisabledState = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    function (isDisabled) {\r\n        this.disabled = isDisabled;\r\n    };\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._onKeydown = /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        /** @type {?} */\r\n        var isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;\r\n        if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\r\n            this._datepicker.open();\r\n            event.preventDefault();\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._onInput = /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        /** @type {?} */\r\n        var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\r\n        this._lastValueValid = !date || this._dateAdapter.isValid(date);\r\n        date = this._getValidDateOrNull(date);\r\n        if (!this._dateAdapter.sameDate(date, this._value)) {\r\n            this._value = date;\r\n            this._cvaOnChange(date);\r\n            this._valueChange.emit(date);\r\n            this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\r\n        }\r\n        else {\r\n            this._validatorOnChange();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._onChange = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\r\n    };\r\n    /** Returns the palette used by the input's form field, if any. */\r\n    /**\r\n     * Returns the palette used by the input's form field, if any.\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._getThemePalette = /**\r\n     * Returns the palette used by the input's form field, if any.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._formField ? this._formField.color : undefined;\r\n    };\r\n    /** Handles blur events on the input. */\r\n    /**\r\n     * Handles blur events on the input.\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._onBlur = /**\r\n     * Handles blur events on the input.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // Reformat the input only if we have a valid value.\r\n        if (this.value) {\r\n            this._formatValue(this.value);\r\n        }\r\n        this._onTouched();\r\n    };\r\n    /** Formats a value and sets it on the input element. */\r\n    /**\r\n     * Formats a value and sets it on the input element.\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    MatDatepickerInput.prototype._formatValue = /**\r\n     * Formats a value and sets it on the input element.\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        this._elementRef.nativeElement.value =\r\n            value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\r\n    };\r\n    /**\r\n     * @param obj The object to check.\r\n     * @returns The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    MatDatepickerInput.prototype._getValidDateOrNull = /**\r\n     * @private\r\n     * @param {?} obj The object to check.\r\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    function (obj) {\r\n        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\r\n    };\r\n    MatDatepickerInput.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: 'input[matDatepicker]',\r\n                    providers: [\r\n                        MAT_DATEPICKER_VALUE_ACCESSOR,\r\n                        MAT_DATEPICKER_VALIDATORS,\r\n                        { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatDatepickerInput },\r\n                    ],\r\n                    host: {\r\n                        '[attr.aria-haspopup]': '_datepicker ? \"dialog\" : null',\r\n                        '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',\r\n                        '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',\r\n                        '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',\r\n                        '[disabled]': 'disabled',\r\n                        '(input)': '_onInput($event.target.value)',\r\n                        '(change)': '_onChange()',\r\n                        '(blur)': '_onBlur()',\r\n                        '(keydown)': '_onKeydown($event)',\r\n                    },\r\n                    exportAs: 'matDatepickerInput',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDatepickerInput.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: DateAdapter, decorators: [{ type: Optional }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },\r\n        { type: MatFormField, decorators: [{ type: Optional }] }\r\n    ]; };\r\n    MatDatepickerInput.propDecorators = {\r\n        matDatepicker: [{ type: Input }],\r\n        matDatepickerFilter: [{ type: Input }],\r\n        value: [{ type: Input }],\r\n        min: [{ type: Input }],\r\n        max: [{ type: Input }],\r\n        disabled: [{ type: Input }],\r\n        dateChange: [{ type: Output }],\r\n        dateInput: [{ type: Output }]\r\n    };\r\n    return MatDatepickerInput;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Can be used to override the icon of a `matDatepickerToggle`.\r\n */\r\nvar MatDatepickerToggleIcon = /** @class */ (function () {\r\n    function MatDatepickerToggleIcon() {\r\n    }\r\n    MatDatepickerToggleIcon.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[matDatepickerToggleIcon]'\r\n                },] },\r\n    ];\r\n    return MatDatepickerToggleIcon;\r\n}());\r\n/**\r\n * @template D\r\n */\r\nvar MatDatepickerToggle = /** @class */ (function () {\r\n    function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {\r\n        this._intl = _intl;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._stateChanges = Subscription.EMPTY;\r\n        /** @type {?} */\r\n        var parsedTabIndex = Number(defaultTabIndex);\r\n        this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;\r\n    }\r\n    Object.defineProperty(MatDatepickerToggle.prototype, \"disabled\", {\r\n        /** Whether the toggle button is disabled. */\r\n        get: /**\r\n         * Whether the toggle button is disabled.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this._disabled === undefined && this.datepicker) {\r\n                return this.datepicker.disabled;\r\n            }\r\n            return !!this._disabled;\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._disabled = coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatDatepickerToggle.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        if (changes['datepicker']) {\r\n            this._watchStateChanges();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepickerToggle.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._stateChanges.unsubscribe();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDatepickerToggle.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._watchStateChanges();\r\n    };\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatDatepickerToggle.prototype._open = /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        if (this.datepicker && !this.disabled) {\r\n            this.datepicker.open();\r\n            event.stopPropagation();\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDatepickerToggle.prototype._watchStateChanges = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        /** @type {?} */\r\n        var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : of();\r\n        /** @type {?} */\r\n        var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?\r\n            this.datepicker._datepickerInput._disabledChange : of();\r\n        /** @type {?} */\r\n        var datepickerToggled = this.datepicker ?\r\n            merge(this.datepicker.openedStream, this.datepicker.closedStream) :\r\n            of();\r\n        this._stateChanges.unsubscribe();\r\n        this._stateChanges = merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this._changeDetectorRef.markForCheck(); }));\r\n    };\r\n    MatDatepickerToggle.decorators = [\r\n        { type: Component, args: [{selector: 'mat-datepicker-toggle',\r\n                    template: \"<button #button mat-icon-button type=\\\"button\\\" [attr.aria-haspopup]=\\\"datepicker ? 'dialog' : null\\\" [attr.aria-label]=\\\"_intl.openCalendarLabel\\\" [attr.tabindex]=\\\"disabled ? -1 : tabIndex\\\" [disabled]=\\\"disabled\\\" [disableRipple]=\\\"disableRipple\\\" (click)=\\\"_open($event)\\\"><svg *ngIf=\\\"!_customIcon\\\" class=\\\"mat-datepicker-toggle-default-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24px\\\" height=\\\"24px\\\" fill=\\\"currentColor\\\" focusable=\\\"false\\\"><path d=\\\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\\\"/></svg><ng-content select=\\\"[matDatepickerToggleIcon]\\\"></ng-content></button>\",\r\n                    styles: [\".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}\"],\r\n                    host: {\r\n                        'class': 'mat-datepicker-toggle',\r\n                        // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the\r\n                        // consumer may have provided, while still being able to receive focus.\r\n                        '[attr.tabindex]': '-1',\r\n                        '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',\r\n                        '[class.mat-accent]': 'datepicker && datepicker.color === \"accent\"',\r\n                        '[class.mat-warn]': 'datepicker && datepicker.color === \"warn\"',\r\n                        '(focus)': '_button.focus()',\r\n                    },\r\n                    exportAs: 'matDatepickerToggle',\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDatepickerToggle.ctorParameters = function () { return [\r\n        { type: MatDatepickerIntl },\r\n        { type: ChangeDetectorRef },\r\n        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] }\r\n    ]; };\r\n    MatDatepickerToggle.propDecorators = {\r\n        datepicker: [{ type: Input, args: ['for',] }],\r\n        tabIndex: [{ type: Input }],\r\n        disabled: [{ type: Input }],\r\n        disableRipple: [{ type: Input }],\r\n        _customIcon: [{ type: ContentChild, args: [MatDatepickerToggleIcon, { static: false },] }],\r\n        _button: [{ type: ViewChild, args: ['button', { static: false },] }]\r\n    };\r\n    return MatDatepickerToggle;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatDatepickerModule = /** @class */ (function () {\r\n    function MatDatepickerModule() {\r\n    }\r\n    MatDatepickerModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [\r\n                        CommonModule,\r\n                        MatButtonModule,\r\n                        MatDialogModule,\r\n                        OverlayModule,\r\n                        A11yModule,\r\n                        PortalModule,\r\n                    ],\r\n                    exports: [\r\n                        MatCalendar,\r\n                        MatCalendarBody,\r\n                        MatDatepicker,\r\n                        MatDatepickerContent,\r\n                        MatDatepickerInput,\r\n                        MatDatepickerToggle,\r\n                        MatDatepickerToggleIcon,\r\n                        MatMonthView,\r\n                        MatYearView,\r\n                        MatMultiYearView,\r\n                        MatCalendarHeader,\r\n                    ],\r\n                    declarations: [\r\n                        MatCalendar,\r\n                        MatCalendarBody,\r\n                        MatDatepicker,\r\n                        MatDatepickerContent,\r\n                        MatDatepickerInput,\r\n                        MatDatepickerToggle,\r\n                        MatDatepickerToggleIcon,\r\n                        MatMonthView,\r\n                        MatYearView,\r\n                        MatMultiYearView,\r\n                        MatCalendarHeader,\r\n                    ],\r\n                    providers: [\r\n                        MatDatepickerIntl,\r\n                        MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,\r\n                    ],\r\n                    entryComponents: [\r\n                        MatDatepickerContent,\r\n                        MatCalendarHeader,\r\n                    ]\r\n                },] },\r\n    ];\r\n    return MatDatepickerModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatMultiYearView, yearsPerPage, yearsPerRow, MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView };\r\n\r\n"]}