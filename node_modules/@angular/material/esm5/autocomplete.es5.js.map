{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/autocomplete.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyOM,AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmBA;;;;;;;;;;;;;;;KAeD,AAMC;;;;;;;;;;;;4EAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsgCH,AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAoBA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;;;;;4BAcC","file":"autocomplete.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, InjectionToken, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, Directive, forwardRef, Host, NgZone, Optional, ViewContainerRef, NgModule } from '@angular/core';\r\nimport { MAT_OPTION_PARENT_COMPONENT, MatOptgroup, MatOption, mixinDisableRipple, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionSelectionChange, MatOptionModule, MatCommonModule } from '@angular/material/core';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@angular/cdk/keycodes';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { _supportsShadowDom } from '@angular/cdk/platform';\r\nimport { TemplatePortal } from '@angular/cdk/portal';\r\nimport { ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { MatFormField } from '@angular/material/form-field';\r\nimport { defer, fromEvent, merge, of, Subject, Subscription } from 'rxjs';\r\nimport { delay, filter, map, switchMap, take, tap } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\r\n * the component definition.\r\n * @type {?}\r\n */\r\nvar _uniqueAutocompleteIdCounter = 0;\r\n/**\r\n * Event object that is emitted when an autocomplete option is selected.\r\n */\r\nvar  /**\r\n * Event object that is emitted when an autocomplete option is selected.\r\n */\r\nMatAutocompleteSelectedEvent = /** @class */ (function () {\r\n    function MatAutocompleteSelectedEvent(source, option) {\r\n        this.source = source;\r\n        this.option = option;\r\n    }\r\n    return MatAutocompleteSelectedEvent;\r\n}());\r\n// Boilerplate for applying mixins to MatAutocomplete.\r\n/**\r\n * \\@docs-private\r\n */\r\nvar \r\n// Boilerplate for applying mixins to MatAutocomplete.\r\n/**\r\n * \\@docs-private\r\n */\r\nMatAutocompleteBase = /** @class */ (function () {\r\n    function MatAutocompleteBase() {\r\n    }\r\n    return MatAutocompleteBase;\r\n}());\r\n/** @type {?} */\r\nvar _MatAutocompleteMixinBase = mixinDisableRipple(MatAutocompleteBase);\r\n/**\r\n * Injection token to be used to override the default options for `mat-autocomplete`.\r\n * @type {?}\r\n */\r\nvar MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\r\n    return { autoActiveFirstOption: false };\r\n}\r\nvar MatAutocomplete = /** @class */ (function (_super) {\r\n    __extends(MatAutocomplete, _super);\r\n    function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\r\n        var _this = _super.call(this) || this;\r\n        _this._changeDetectorRef = _changeDetectorRef;\r\n        _this._elementRef = _elementRef;\r\n        /**\r\n         * Whether the autocomplete panel should be visible, depending on option length.\r\n         */\r\n        _this.showPanel = false;\r\n        _this._isOpen = false;\r\n        /**\r\n         * Function that maps an option's control value to its display value in the trigger.\r\n         */\r\n        _this.displayWith = null;\r\n        /**\r\n         * Event that is emitted whenever an option from the list is selected.\r\n         */\r\n        _this.optionSelected = new EventEmitter();\r\n        /**\r\n         * Event that is emitted when the autocomplete panel is opened.\r\n         */\r\n        _this.opened = new EventEmitter();\r\n        /**\r\n         * Event that is emitted when the autocomplete panel is closed.\r\n         */\r\n        _this.closed = new EventEmitter();\r\n        _this._classList = {};\r\n        /**\r\n         * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\r\n         */\r\n        _this.id = \"mat-autocomplete-\" + _uniqueAutocompleteIdCounter++;\r\n        _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatAutocomplete.prototype, \"isOpen\", {\r\n        /** Whether the autocomplete panel is open. */\r\n        get: /**\r\n         * Whether the autocomplete panel is open.\r\n         * @return {?}\r\n         */\r\n        function () { return this._isOpen && this.showPanel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatAutocomplete.prototype, \"autoActiveFirstOption\", {\r\n        /**\r\n         * Whether the first option should be highlighted when the autocomplete panel is opened.\r\n         * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\r\n         */\r\n        get: /**\r\n         * Whether the first option should be highlighted when the autocomplete panel is opened.\r\n         * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\r\n         * @return {?}\r\n         */\r\n        function () { return this._autoActiveFirstOption; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._autoActiveFirstOption = coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatAutocomplete.prototype, \"classList\", {\r\n        /**\r\n         * Takes classes set on the host mat-autocomplete element and applies them to the panel\r\n         * inside the overlay container to allow for easy styling.\r\n         */\r\n        set: /**\r\n         * Takes classes set on the host mat-autocomplete element and applies them to the panel\r\n         * inside the overlay container to allow for easy styling.\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            if (value && value.length) {\r\n                this._classList = value.split(' ').reduce((/**\r\n                 * @param {?} classList\r\n                 * @param {?} className\r\n                 * @return {?}\r\n                 */\r\n                function (classList, className) {\r\n                    classList[className.trim()] = true;\r\n                    return classList;\r\n                }), (/** @type {?} */ ({})));\r\n            }\r\n            else {\r\n                this._classList = {};\r\n            }\r\n            this._setVisibilityClasses(this._classList);\r\n            this._elementRef.nativeElement.className = '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\r\n        // Set the initial visibility state.\r\n        this._setVisibility();\r\n    };\r\n    /**\r\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\r\n     * above or below the fold, as they are not actually being focused when active.\r\n     */\r\n    /**\r\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\r\n     * above or below the fold, as they are not actually being focused when active.\r\n     * @param {?} scrollTop\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype._setScrollTop = /**\r\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\r\n     * above or below the fold, as they are not actually being focused when active.\r\n     * @param {?} scrollTop\r\n     * @return {?}\r\n     */\r\n    function (scrollTop) {\r\n        if (this.panel) {\r\n            this.panel.nativeElement.scrollTop = scrollTop;\r\n        }\r\n    };\r\n    /** Returns the panel's scrollTop. */\r\n    /**\r\n     * Returns the panel's scrollTop.\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype._getScrollTop = /**\r\n     * Returns the panel's scrollTop.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\r\n    };\r\n    /** Panel should hide itself when the option list is empty. */\r\n    /**\r\n     * Panel should hide itself when the option list is empty.\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype._setVisibility = /**\r\n     * Panel should hide itself when the option list is empty.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.showPanel = !!this.options.length;\r\n        this._setVisibilityClasses(this._classList);\r\n        this._changeDetectorRef.markForCheck();\r\n    };\r\n    /** Emits the `select` event. */\r\n    /**\r\n     * Emits the `select` event.\r\n     * @param {?} option\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype._emitSelectEvent = /**\r\n     * Emits the `select` event.\r\n     * @param {?} option\r\n     * @return {?}\r\n     */\r\n    function (option) {\r\n        /** @type {?} */\r\n        var event = new MatAutocompleteSelectedEvent(this, option);\r\n        this.optionSelected.emit(event);\r\n    };\r\n    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\r\n    /**\r\n     * Sets the autocomplete visibility classes on a classlist based on the panel is visible.\r\n     * @private\r\n     * @param {?} classList\r\n     * @return {?}\r\n     */\r\n    MatAutocomplete.prototype._setVisibilityClasses = /**\r\n     * Sets the autocomplete visibility classes on a classlist based on the panel is visible.\r\n     * @private\r\n     * @param {?} classList\r\n     * @return {?}\r\n     */\r\n    function (classList) {\r\n        classList['mat-autocomplete-visible'] = this.showPanel;\r\n        classList['mat-autocomplete-hidden'] = !this.showPanel;\r\n    };\r\n    MatAutocomplete.decorators = [\r\n        { type: Component, args: [{selector: 'mat-autocomplete',\r\n                    template: \"<ng-template><div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel><ng-content></ng-content></div></ng-template>\",\r\n                    styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}\"],\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    exportAs: 'matAutocomplete',\r\n                    inputs: ['disableRipple'],\r\n                    host: {\r\n                        'class': 'mat-autocomplete'\r\n                    },\r\n                    providers: [\r\n                        { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\r\n                    ]\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatAutocomplete.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: ElementRef },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\r\n    ]; };\r\n    MatAutocomplete.propDecorators = {\r\n        template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],\r\n        panel: [{ type: ViewChild, args: ['panel', { static: false },] }],\r\n        options: [{ type: ContentChildren, args: [MatOption, { descendants: true },] }],\r\n        optionGroups: [{ type: ContentChildren, args: [MatOptgroup,] }],\r\n        displayWith: [{ type: Input }],\r\n        autoActiveFirstOption: [{ type: Input }],\r\n        panelWidth: [{ type: Input }],\r\n        optionSelected: [{ type: Output }],\r\n        opened: [{ type: Output }],\r\n        closed: [{ type: Output }],\r\n        classList: [{ type: Input, args: ['class',] }]\r\n    };\r\n    return MatAutocomplete;\r\n}(_MatAutocompleteMixinBase));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Directive applied to an element to make it usable\r\n * as a connection point for an autocomplete panel.\r\n */\r\nvar MatAutocompleteOrigin = /** @class */ (function () {\r\n    function MatAutocompleteOrigin(elementRef) {\r\n        this.elementRef = elementRef;\r\n    }\r\n    MatAutocompleteOrigin.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[matAutocompleteOrigin]',\r\n                    exportAs: 'matAutocompleteOrigin',\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatAutocompleteOrigin.ctorParameters = function () { return [\r\n        { type: ElementRef }\r\n    ]; };\r\n    return MatAutocompleteOrigin;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * The height of each autocomplete option.\r\n * @type {?}\r\n */\r\nvar AUTOCOMPLETE_OPTION_HEIGHT = 48;\r\n/**\r\n * The total height of the autocomplete panel.\r\n * @type {?}\r\n */\r\nvar AUTOCOMPLETE_PANEL_HEIGHT = 256;\r\n/**\r\n * Injection token that determines the scroll handling while the autocomplete panel is open.\r\n * @type {?}\r\n */\r\nvar MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return (/**\r\n     * @return {?}\r\n     */\r\n    function () { return overlay.scrollStrategies.reposition(); });\r\n}\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/**\r\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef((/**\r\n     * @return {?}\r\n     */\r\n    function () { return MatAutocompleteTrigger; })),\r\n    multi: true\r\n};\r\n/**\r\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction getMatAutocompleteMissingPanelError() {\r\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\r\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\r\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\r\n}\r\nvar MatAutocompleteTrigger = /** @class */ (function () {\r\n    function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {\r\n        var _this = this;\r\n        this._element = _element;\r\n        this._overlay = _overlay;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._zone = _zone;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dir = _dir;\r\n        this._formField = _formField;\r\n        this._document = _document;\r\n        this._viewportRuler = _viewportRuler;\r\n        this._componentDestroyed = false;\r\n        this._autocompleteDisabled = false;\r\n        /**\r\n         * Whether or not the label state is being overridden.\r\n         */\r\n        this._manuallyFloatingLabel = false;\r\n        /**\r\n         * Subscription to viewport size changes.\r\n         */\r\n        this._viewportSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\r\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\r\n         * comes back.\r\n         */\r\n        this._canOpenOnNextFocus = true;\r\n        /**\r\n         * Stream of keyboard events that can close the panel.\r\n         */\r\n        this._closeKeyEventStream = new Subject();\r\n        /**\r\n         * Event handler for when the window is blurred. Needs to be an\r\n         * arrow function in order to preserve the context.\r\n         */\r\n        this._windowBlurHandler = (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\r\n            // refocused when they come back. In this case we want to skip the first focus event, if the\r\n            // pane was closed, in order to avoid reopening it unintentionally.\r\n            _this._canOpenOnNextFocus =\r\n                _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;\r\n        });\r\n        /**\r\n         * `View -> model callback called when value changes`\r\n         */\r\n        this._onChange = (/**\r\n         * @return {?}\r\n         */\r\n        function () { });\r\n        /**\r\n         * `View -> model callback called when autocomplete has been touched`\r\n         */\r\n        this._onTouched = (/**\r\n         * @return {?}\r\n         */\r\n        function () { });\r\n        /**\r\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\r\n         * will render the panel underneath the trigger if there is enough space for it to fit in\r\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\r\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\r\n         * whether it fits completely in the viewport.\r\n         */\r\n        this.position = 'auto';\r\n        /**\r\n         * `autocomplete` attribute to be set on the input element.\r\n         * \\@docs-private\r\n         */\r\n        this.autocompleteAttribute = 'off';\r\n        this._overlayAttached = false;\r\n        /**\r\n         * Stream of autocomplete option selections.\r\n         */\r\n        this.optionSelections = (/** @type {?} */ (defer((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (_this.autocomplete && _this.autocomplete.options) {\r\n                return merge.apply(void 0, _this.autocomplete.options.map((/**\r\n                 * @param {?} option\r\n                 * @return {?}\r\n                 */\r\n                function (option) { return option.onSelectionChange; })));\r\n            }\r\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\r\n            // Return a stream that we'll replace with the real one once everything is in place.\r\n            return _this._zone.onStable\r\n                .asObservable()\r\n                .pipe(take(1), switchMap((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this.optionSelections; })));\r\n        }))));\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    Object.defineProperty(MatAutocompleteTrigger.prototype, \"autocompleteDisabled\", {\r\n        /**\r\n         * Whether the autocomplete is disabled. When disabled, the element will\r\n         * act as a regular input and the user won't be able to open the panel.\r\n         */\r\n        get: /**\r\n         * Whether the autocomplete is disabled. When disabled, the element will\r\n         * act as a regular input and the user won't be able to open the panel.\r\n         * @return {?}\r\n         */\r\n        function () { return this._autocompleteDisabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._autocompleteDisabled = coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.ngAfterViewInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (typeof window !== 'undefined') {\r\n            this._zone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                window.addEventListener('blur', _this._windowBlurHandler);\r\n            }));\r\n            if (_supportsShadowDom()) {\r\n                /** @type {?} */\r\n                var element = this._element.nativeElement;\r\n                /** @type {?} */\r\n                var rootNode = element.getRootNode ? element.getRootNode() : null;\r\n                // We need to take the `ShadowRoot` off of `window`, because the built-in types are\r\n                // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\r\n                this._isInsideShadowRoot = rootNode instanceof ((/** @type {?} */ (window))).ShadowRoot;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        if (changes['position'] && this._positionStrategy) {\r\n            this._setStrategyPositions(this._positionStrategy);\r\n            if (this.panelOpen) {\r\n                (/** @type {?} */ (this._overlayRef)).updatePosition();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (typeof window !== 'undefined') {\r\n            window.removeEventListener('blur', this._windowBlurHandler);\r\n        }\r\n        this._viewportSubscription.unsubscribe();\r\n        this._componentDestroyed = true;\r\n        this._destroyPanel();\r\n        this._closeKeyEventStream.complete();\r\n    };\r\n    Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelOpen\", {\r\n        /** Whether or not the autocomplete panel is open. */\r\n        get: /**\r\n         * Whether or not the autocomplete panel is open.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._overlayAttached && this.autocomplete.showPanel;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Opens the autocomplete suggestion panel. */\r\n    /**\r\n     * Opens the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.openPanel = /**\r\n     * Opens the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._attachOverlay();\r\n        this._floatLabel();\r\n    };\r\n    /** Closes the autocomplete suggestion panel. */\r\n    /**\r\n     * Closes the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.closePanel = /**\r\n     * Closes the autocomplete suggestion panel.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._resetLabel();\r\n        if (!this._overlayAttached) {\r\n            return;\r\n        }\r\n        if (this.panelOpen) {\r\n            // Only emit if the panel was visible.\r\n            this.autocomplete.closed.emit();\r\n        }\r\n        this.autocomplete._isOpen = this._overlayAttached = false;\r\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\r\n            this._overlayRef.detach();\r\n            this._closingActionsSubscription.unsubscribe();\r\n        }\r\n        // Note that in some cases this can end up being called after the component is destroyed.\r\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\r\n        if (!this._componentDestroyed) {\r\n            // We need to trigger change detection manually, because\r\n            // `fromEvent` doesn't seem to do it at the proper time.\r\n            // This ensures that the label is reset when the\r\n            // user clicks outside.\r\n            this._changeDetectorRef.detectChanges();\r\n        }\r\n    };\r\n    /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     */\r\n    /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.updatePosition = /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._overlayAttached) {\r\n            (/** @type {?} */ (this._overlayRef)).updatePosition();\r\n        }\r\n    };\r\n    Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelClosingActions\", {\r\n        /**\r\n         * A stream of actions that should close the autocomplete panel, including\r\n         * when an option is selected, on blur, and when TAB is pressed.\r\n         */\r\n        get: /**\r\n         * A stream of actions that should close the autocomplete panel, including\r\n         * when an option is selected, on blur, and when TAB is pressed.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            var _this = this;\r\n            return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\r\n                this._overlayRef.detachments().pipe(filter((/**\r\n                 * @return {?}\r\n                 */\r\n                function () { return _this._overlayAttached; }))) :\r\n                of()).pipe(\r\n            // Normalize the output so we return a consistent type.\r\n            map((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            function (event) { return event instanceof MatOptionSelectionChange ? event : null; })));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatAutocompleteTrigger.prototype, \"activeOption\", {\r\n        /** The currently active option, coerced to MatOption type. */\r\n        get: /**\r\n         * The currently active option, coerced to MatOption type.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this.autocomplete && this.autocomplete._keyManager) {\r\n                return this.autocomplete._keyManager.activeItem;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Stream of clicks outside of the autocomplete panel. */\r\n    /**\r\n     * Stream of clicks outside of the autocomplete panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getOutsideClickStream = /**\r\n     * Stream of clicks outside of the autocomplete panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        return merge((/** @type {?} */ (fromEvent(this._document, 'click'))), (/** @type {?} */ (fromEvent(this._document, 'touchend'))))\r\n            .pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\r\n            // fall back to check the first element in the path of the click event.\r\n            /** @type {?} */\r\n            var clickTarget = (/** @type {?} */ ((_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\r\n                event.target)));\r\n            /** @type {?} */\r\n            var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;\r\n            return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&\r\n                (!formField || !formField.contains(clickTarget)) &&\r\n                (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\r\n        })));\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.writeValue = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        var _this = this;\r\n        Promise.resolve(null).then((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this._setTriggerValue(value); }));\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.registerOnChange = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        this._onChange = fn;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.registerOnTouched = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    function (fn) {\r\n        this._onTouched = fn;\r\n    };\r\n    // Implemented as part of ControlValueAccessor.\r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype.setDisabledState = \r\n    // Implemented as part of ControlValueAccessor.\r\n    /**\r\n     * @param {?} isDisabled\r\n     * @return {?}\r\n     */\r\n    function (isDisabled) {\r\n        this._element.nativeElement.disabled = isDisabled;\r\n    };\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._handleKeydown = /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        /** @type {?} */\r\n        var keyCode = event.keyCode;\r\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\r\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\r\n        // the input value to the one that it had on focus, however it won't dispatch any events\r\n        // which means that the model value will be out of sync with the view.\r\n        if (keyCode === ESCAPE) {\r\n            event.preventDefault();\r\n        }\r\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\r\n            this.activeOption._selectViaInteraction();\r\n            this._resetActiveItem();\r\n            event.preventDefault();\r\n        }\r\n        else if (this.autocomplete) {\r\n            /** @type {?} */\r\n            var prevActiveItem = this.autocomplete._keyManager.activeItem;\r\n            /** @type {?} */\r\n            var isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\r\n            if (this.panelOpen || keyCode === TAB) {\r\n                this.autocomplete._keyManager.onKeydown(event);\r\n            }\r\n            else if (isArrowKey && this._canOpen()) {\r\n                this.openPanel();\r\n            }\r\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\r\n                this._scrollToOption();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._handleInput = /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        /** @type {?} */\r\n        var target = (/** @type {?} */ (event.target));\r\n        /** @type {?} */\r\n        var value = target.value;\r\n        // Based on `NumberValueAccessor` from forms.\r\n        if (target.type === 'number') {\r\n            value = value == '' ? null : parseFloat(value);\r\n        }\r\n        // If the input has a placeholder, IE will fire the `input` event on page load,\r\n        // focus and blur, in addition to when the user actually changed the value. To\r\n        // filter out all of the extra events, we save the value on focus and between\r\n        // `input` events, and we check whether it changed.\r\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\r\n        if (this._previousValue !== value) {\r\n            this._previousValue = value;\r\n            this._onChange(value);\r\n            if (this._canOpen() && this._document.activeElement === event.target) {\r\n                this.openPanel();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._handleFocus = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this._canOpenOnNextFocus) {\r\n            this._canOpenOnNextFocus = true;\r\n        }\r\n        else if (this._canOpen()) {\r\n            this._previousValue = this._element.nativeElement.value;\r\n            this._attachOverlay();\r\n            this._floatLabel(true);\r\n        }\r\n    };\r\n    /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @param shouldAnimate Whether the label should be animated when it is floated.\r\n     */\r\n    /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @private\r\n     * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._floatLabel = /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @private\r\n     * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\r\n     * @return {?}\r\n     */\r\n    function (shouldAnimate) {\r\n        if (shouldAnimate === void 0) { shouldAnimate = false; }\r\n        if (this._formField && this._formField.floatLabel === 'auto') {\r\n            if (shouldAnimate) {\r\n                this._formField._animateAndLockLabel();\r\n            }\r\n            else {\r\n                this._formField.floatLabel = 'always';\r\n            }\r\n            this._manuallyFloatingLabel = true;\r\n        }\r\n    };\r\n    /** If the label has been manually elevated, return it to its normal state. */\r\n    /**\r\n     * If the label has been manually elevated, return it to its normal state.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._resetLabel = /**\r\n     * If the label has been manually elevated, return it to its normal state.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._manuallyFloatingLabel) {\r\n            this._formField.floatLabel = 'auto';\r\n            this._manuallyFloatingLabel = false;\r\n        }\r\n    };\r\n    /**\r\n     * Given that we are not actually focusing active options, we must manually adjust scroll\r\n     * to reveal options below the fold. First, we find the offset of the option from the top\r\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n     * the panel height + the option height, so the active option will be just visible at the\r\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n     * not adjusted.\r\n     */\r\n    /**\r\n     * Given that we are not actually focusing active options, we must manually adjust scroll\r\n     * to reveal options below the fold. First, we find the offset of the option from the top\r\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n     * the panel height + the option height, so the active option will be just visible at the\r\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n     * not adjusted.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._scrollToOption = /**\r\n     * Given that we are not actually focusing active options, we must manually adjust scroll\r\n     * to reveal options below the fold. First, we find the offset of the option from the top\r\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n     * the panel height + the option height, so the active option will be just visible at the\r\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n     * not adjusted.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var index = this.autocomplete._keyManager.activeItemIndex || 0;\r\n        /** @type {?} */\r\n        var labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\r\n        if (index === 0 && labelCount === 1) {\r\n            // If we've got one group label before the option and we're at the top option,\r\n            // scroll the list to the top. This is better UX than scrolling the list to the\r\n            // top of the option, because it allows the user to read the top group's label.\r\n            this.autocomplete._setScrollTop(0);\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            var newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\r\n            this.autocomplete._setScrollTop(newScrollPosition);\r\n        }\r\n    };\r\n    /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     */\r\n    /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._subscribeToClosingActions = /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        /** @type {?} */\r\n        var firstStable = this._zone.onStable.asObservable().pipe(take(1));\r\n        /** @type {?} */\r\n        var optionChanges = this.autocomplete.options.changes.pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this._positionStrategy.reapplyLastPosition(); })), \r\n        // Defer emitting to the stream until the next tick, because changing\r\n        // bindings in here will cause \"changed after checked\" errors.\r\n        delay(0));\r\n        // When the zone is stable initially, and when the option list changes...\r\n        return merge(firstStable, optionChanges)\r\n            .pipe(\r\n        // create a new stream of panelClosingActions, replacing any previous streams\r\n        // that were created, and flatten it so our stream only emits closing events...\r\n        switchMap((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            /** @type {?} */\r\n            var wasOpen = _this.panelOpen;\r\n            _this._resetActiveItem();\r\n            _this.autocomplete._setVisibility();\r\n            if (_this.panelOpen) {\r\n                (/** @type {?} */ (_this._overlayRef)).updatePosition();\r\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened`\r\n                // event, because we may not have emitted it when the panel was attached. This\r\n                // can happen if the users opens the panel and there are no options, but the\r\n                // options come in slightly later or as a result of the value changing.\r\n                if (wasOpen !== _this.panelOpen) {\r\n                    _this.autocomplete.opened.emit();\r\n                }\r\n            }\r\n            return _this.panelClosingActions;\r\n        })), \r\n        // when the first closing event occurs...\r\n        take(1))\r\n            // set the value, close the panel, and complete.\r\n            .subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) { return _this._setValueAndClose(event); }));\r\n    };\r\n    /** Destroys the autocomplete suggestion panel. */\r\n    /**\r\n     * Destroys the autocomplete suggestion panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._destroyPanel = /**\r\n     * Destroys the autocomplete suggestion panel.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._overlayRef) {\r\n            this.closePanel();\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._setTriggerValue = /**\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    function (value) {\r\n        /** @type {?} */\r\n        var toDisplay = this.autocomplete && this.autocomplete.displayWith ?\r\n            this.autocomplete.displayWith(value) :\r\n            value;\r\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\r\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\r\n        /** @type {?} */\r\n        var inputValue = toDisplay != null ? toDisplay : '';\r\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\r\n        // through change detection.\r\n        if (this._formField) {\r\n            this._formField._control.value = inputValue;\r\n        }\r\n        else {\r\n            this._element.nativeElement.value = inputValue;\r\n        }\r\n        this._previousValue = inputValue;\r\n    };\r\n    /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     */\r\n    /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._setValueAndClose = /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        if (event && event.source) {\r\n            this._clearPreviousSelectedOption(event.source);\r\n            this._setTriggerValue(event.source.value);\r\n            this._onChange(event.source.value);\r\n            this._element.nativeElement.focus();\r\n            this.autocomplete._emitSelectEvent(event.source);\r\n        }\r\n        this.closePanel();\r\n    };\r\n    /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     */\r\n    /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     * @private\r\n     * @param {?} skip\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     * @private\r\n     * @param {?} skip\r\n     * @return {?}\r\n     */\r\n    function (skip) {\r\n        this.autocomplete.options.forEach((/**\r\n         * @param {?} option\r\n         * @return {?}\r\n         */\r\n        function (option) {\r\n            if (option != skip && option.selected) {\r\n                option.deselect();\r\n            }\r\n        }));\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._attachOverlay = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (!this.autocomplete) {\r\n            throw getMatAutocompleteMissingPanelError();\r\n        }\r\n        /** @type {?} */\r\n        var overlayRef = this._overlayRef;\r\n        if (!overlayRef) {\r\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\r\n            overlayRef = this._overlay.create(this._getOverlayConfig());\r\n            this._overlayRef = overlayRef;\r\n            // Use the `keydownEvents` in order to take advantage of\r\n            // the overlay event targeting provided by the CDK overlay.\r\n            overlayRef.keydownEvents().subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            function (event) {\r\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\r\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\r\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\r\n                    _this._resetActiveItem();\r\n                    _this._closeKeyEventStream.next();\r\n                    // We need to stop propagation, otherwise the event will eventually\r\n                    // reach the input itself and cause the overlay to be reopened.\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                }\r\n            }));\r\n            if (this._viewportRuler) {\r\n                this._viewportSubscription = this._viewportRuler.change().subscribe((/**\r\n                 * @return {?}\r\n                 */\r\n                function () {\r\n                    if (_this.panelOpen && overlayRef) {\r\n                        overlayRef.updateSize({ width: _this._getPanelWidth() });\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        else {\r\n            // Update the trigger, panel width and direction, in case anything has changed.\r\n            this._positionStrategy.setOrigin(this._getConnectedElement());\r\n            overlayRef.updateSize({ width: this._getPanelWidth() });\r\n        }\r\n        if (overlayRef && !overlayRef.hasAttached()) {\r\n            overlayRef.attach(this._portal);\r\n            this._closingActionsSubscription = this._subscribeToClosingActions();\r\n        }\r\n        /** @type {?} */\r\n        var wasOpen = this.panelOpen;\r\n        this.autocomplete._setVisibility();\r\n        this.autocomplete._isOpen = this._overlayAttached = true;\r\n        // We need to do an extra `panelOpen` check in here, because the\r\n        // autocomplete won't be shown if there are no options.\r\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\r\n            this.autocomplete.opened.emit();\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getOverlayConfig = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._getOverlayPosition(),\r\n            scrollStrategy: this._scrollStrategy(),\r\n            width: this._getPanelWidth(),\r\n            direction: this._dir\r\n        });\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getOverlayPosition = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var strategy = this._overlay.position()\r\n            .flexibleConnectedTo(this._getConnectedElement())\r\n            .withFlexibleDimensions(false)\r\n            .withPush(false);\r\n        this._setStrategyPositions(strategy);\r\n        this._positionStrategy = strategy;\r\n        return strategy;\r\n    };\r\n    /** Sets the positions on a position strategy based on the directive's input state. */\r\n    /**\r\n     * Sets the positions on a position strategy based on the directive's input state.\r\n     * @private\r\n     * @param {?} positionStrategy\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._setStrategyPositions = /**\r\n     * Sets the positions on a position strategy based on the directive's input state.\r\n     * @private\r\n     * @param {?} positionStrategy\r\n     * @return {?}\r\n     */\r\n    function (positionStrategy) {\r\n        /** @type {?} */\r\n        var belowPosition = {\r\n            originX: 'start',\r\n            originY: 'bottom',\r\n            overlayX: 'start',\r\n            overlayY: 'top'\r\n        };\r\n        /** @type {?} */\r\n        var abovePosition = {\r\n            originX: 'start',\r\n            originY: 'top',\r\n            overlayX: 'start',\r\n            overlayY: 'bottom',\r\n            // The overlay edge connected to the trigger should have squared corners, while\r\n            // the opposite end has rounded corners. We apply a CSS class to swap the\r\n            // border-radius based on the overlay position.\r\n            panelClass: 'mat-autocomplete-panel-above'\r\n        };\r\n        /** @type {?} */\r\n        var positions;\r\n        if (this.position === 'above') {\r\n            positions = [abovePosition];\r\n        }\r\n        else if (this.position === 'below') {\r\n            positions = [belowPosition];\r\n        }\r\n        else {\r\n            positions = [belowPosition, abovePosition];\r\n        }\r\n        positionStrategy.withPositions(positions);\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getConnectedElement = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this.connectedTo) {\r\n            return this.connectedTo.elementRef;\r\n        }\r\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getPanelWidth = /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.autocomplete.panelWidth || this._getHostWidth();\r\n    };\r\n    /** Returns the width of the input element, so the panel width can match it. */\r\n    /**\r\n     * Returns the width of the input element, so the panel width can match it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._getHostWidth = /**\r\n     * Returns the width of the input element, so the panel width can match it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\r\n    };\r\n    /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     */\r\n    /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._resetActiveItem = /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\r\n    };\r\n    /** Determines whether the panel can be opened. */\r\n    /**\r\n     * Determines whether the panel can be opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatAutocompleteTrigger.prototype._canOpen = /**\r\n     * Determines whether the panel can be opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var element = this._element.nativeElement;\r\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\r\n    };\r\n    MatAutocompleteTrigger.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: \"input[matAutocomplete], textarea[matAutocomplete]\",\r\n                    host: {\r\n                        'class': 'mat-autocomplete-trigger',\r\n                        '[attr.autocomplete]': 'autocompleteAttribute',\r\n                        '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\r\n                        '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\r\n                        '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\r\n                        '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\r\n                        '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\r\n                        '[attr.aria-haspopup]': '!autocompleteDisabled',\r\n                        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\r\n                        // a little earlier. This avoids issues where IE delays the focusing of the input.\r\n                        '(focusin)': '_handleFocus()',\r\n                        '(blur)': '_onTouched()',\r\n                        '(input)': '_handleInput($event)',\r\n                        '(keydown)': '_handleKeydown($event)',\r\n                    },\r\n                    exportAs: 'matAutocompleteTrigger',\r\n                    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatAutocompleteTrigger.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: Overlay },\r\n        { type: ViewContainerRef },\r\n        { type: NgZone },\r\n        { type: ChangeDetectorRef },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] },\r\n        { type: MatFormField, decorators: [{ type: Optional }, { type: Host }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n        { type: ViewportRuler }\r\n    ]; };\r\n    MatAutocompleteTrigger.propDecorators = {\r\n        autocomplete: [{ type: Input, args: ['matAutocomplete',] }],\r\n        position: [{ type: Input, args: ['matAutocompletePosition',] }],\r\n        connectedTo: [{ type: Input, args: ['matAutocompleteConnectedTo',] }],\r\n        autocompleteAttribute: [{ type: Input, args: ['autocomplete',] }],\r\n        autocompleteDisabled: [{ type: Input, args: ['matAutocompleteDisabled',] }]\r\n    };\r\n    return MatAutocompleteTrigger;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatAutocompleteModule = /** @class */ (function () {\r\n    function MatAutocompleteModule() {\r\n    }\r\n    MatAutocompleteModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [MatOptionModule, OverlayModule, MatCommonModule, CommonModule],\r\n                    exports: [\r\n                        MatAutocomplete,\r\n                        MatOptionModule,\r\n                        MatAutocompleteTrigger,\r\n                        MatAutocompleteOrigin,\r\n                        MatCommonModule\r\n                    ],\r\n                    declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\r\n                    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\r\n                },] },\r\n    ];\r\n    return MatAutocompleteModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin };\r\n\r\n"]}