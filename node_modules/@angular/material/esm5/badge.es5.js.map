{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/badge.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsWM,AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAiBA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;cAUC","file":"badge.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { AriaDescriber, A11yModule } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { Directive, ElementRef, Inject, Input, NgZone, Optional, Renderer2, isDevMode, NgModule } from '@angular/core';\r\nimport { mixinDisabled, MatCommonModule } from '@angular/material/core';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nvar nextId = 0;\r\n// Boilerplate for applying mixins to MatBadge.\r\n/**\r\n * \\@docs-private\r\n */\r\nvar \r\n// Boilerplate for applying mixins to MatBadge.\r\n/**\r\n * \\@docs-private\r\n */\r\nMatBadgeBase = /** @class */ (function () {\r\n    function MatBadgeBase() {\r\n    }\r\n    return MatBadgeBase;\r\n}());\r\n/** @type {?} */\r\nvar _MatBadgeMixinBase = mixinDisabled(MatBadgeBase);\r\n/**\r\n * Directive to display a text badge.\r\n */\r\nvar MatBadge = /** @class */ (function (_super) {\r\n    __extends(MatBadge, _super);\r\n    function MatBadge(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {\r\n        var _this = _super.call(this) || this;\r\n        _this._ngZone = _ngZone;\r\n        _this._elementRef = _elementRef;\r\n        _this._ariaDescriber = _ariaDescriber;\r\n        _this._renderer = _renderer;\r\n        _this._animationMode = _animationMode;\r\n        /**\r\n         * Whether the badge has any content.\r\n         */\r\n        _this._hasContent = false;\r\n        _this._color = 'primary';\r\n        _this._overlap = true;\r\n        /**\r\n         * Position the badge should reside.\r\n         * Accepts any combination of 'above'|'below' and 'before'|'after'\r\n         */\r\n        _this.position = 'above after';\r\n        /**\r\n         * Size of the badge. Can be 'small', 'medium', or 'large'.\r\n         */\r\n        _this.size = 'medium';\r\n        /**\r\n         * Unique id for the badge\r\n         */\r\n        _this._id = nextId++;\r\n        if (isDevMode()) {\r\n            /** @type {?} */\r\n            var nativeElement = _elementRef.nativeElement;\r\n            if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {\r\n                throw Error('matBadge must be attached to an element node.');\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatBadge.prototype, \"color\", {\r\n        /** The color of the badge. Can be `primary`, `accent`, or `warn`. */\r\n        get: /**\r\n         * The color of the badge. Can be `primary`, `accent`, or `warn`.\r\n         * @return {?}\r\n         */\r\n        function () { return this._color; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._setColor(value);\r\n            this._color = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatBadge.prototype, \"overlap\", {\r\n        /** Whether the badge should overlap its contents or not */\r\n        get: /**\r\n         * Whether the badge should overlap its contents or not\r\n         * @return {?}\r\n         */\r\n        function () { return this._overlap; },\r\n        set: /**\r\n         * @param {?} val\r\n         * @return {?}\r\n         */\r\n        function (val) {\r\n            this._overlap = coerceBooleanProperty(val);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatBadge.prototype, \"description\", {\r\n        /** Message used to describe the decorated element via aria-describedby */\r\n        get: /**\r\n         * Message used to describe the decorated element via aria-describedby\r\n         * @return {?}\r\n         */\r\n        function () { return this._description; },\r\n        set: /**\r\n         * @param {?} newDescription\r\n         * @return {?}\r\n         */\r\n        function (newDescription) {\r\n            if (newDescription !== this._description) {\r\n                /** @type {?} */\r\n                var badgeElement = this._badgeElement;\r\n                this._updateHostAriaDescription(newDescription, this._description);\r\n                this._description = newDescription;\r\n                if (badgeElement) {\r\n                    newDescription ? badgeElement.setAttribute('aria-label', newDescription) :\r\n                        badgeElement.removeAttribute('aria-label');\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatBadge.prototype, \"hidden\", {\r\n        /** Whether the badge is hidden. */\r\n        get: /**\r\n         * Whether the badge is hidden.\r\n         * @return {?}\r\n         */\r\n        function () { return this._hidden; },\r\n        set: /**\r\n         * @param {?} val\r\n         * @return {?}\r\n         */\r\n        function (val) {\r\n            this._hidden = coerceBooleanProperty(val);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Whether the badge is above the host or not */\r\n    /**\r\n     * Whether the badge is above the host or not\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype.isAbove = /**\r\n     * Whether the badge is above the host or not\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.position.indexOf('below') === -1;\r\n    };\r\n    /** Whether the badge is after the host or not */\r\n    /**\r\n     * Whether the badge is after the host or not\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype.isAfter = /**\r\n     * Whether the badge is after the host or not\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.position.indexOf('before') === -1;\r\n    };\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype.ngOnChanges = /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    function (changes) {\r\n        /** @type {?} */\r\n        var contentChange = changes['content'];\r\n        if (contentChange) {\r\n            /** @type {?} */\r\n            var value = contentChange.currentValue;\r\n            this._hasContent = value != null && (\"\" + value).trim().length > 0;\r\n            this._updateTextContent();\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var badgeElement = this._badgeElement;\r\n        if (badgeElement) {\r\n            if (this.description) {\r\n                this._ariaDescriber.removeDescription(badgeElement, this.description);\r\n            }\r\n            // When creating a badge through the Renderer, Angular will keep it in an index.\r\n            // We have to destroy it ourselves, otherwise it'll be retained in memory.\r\n            if (this._renderer.destroyNode) {\r\n                this._renderer.destroyNode(badgeElement);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets the element into which the badge's content is being rendered.\r\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\r\n     */\r\n    /**\r\n     * Gets the element into which the badge's content is being rendered.\r\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype.getBadgeElement = /**\r\n     * Gets the element into which the badge's content is being rendered.\r\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._badgeElement;\r\n    };\r\n    /** Injects a span element into the DOM with the content. */\r\n    /**\r\n     * Injects a span element into the DOM with the content.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype._updateTextContent = /**\r\n     * Injects a span element into the DOM with the content.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this._badgeElement) {\r\n            this._badgeElement = this._createBadgeElement();\r\n        }\r\n        else {\r\n            this._badgeElement.textContent = this.content;\r\n        }\r\n        return this._badgeElement;\r\n    };\r\n    /** Creates the badge element */\r\n    /**\r\n     * Creates the badge element\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype._createBadgeElement = /**\r\n     * Creates the badge element\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var badgeElement = this._renderer.createElement('span');\r\n        /** @type {?} */\r\n        var activeClass = 'mat-badge-active';\r\n        /** @type {?} */\r\n        var contentClass = 'mat-badge-content';\r\n        // Clear any existing badges which may have persisted from a server-side render.\r\n        this._clearExistingBadges(contentClass);\r\n        badgeElement.setAttribute('id', \"mat-badge-content-\" + this._id);\r\n        badgeElement.classList.add(contentClass);\r\n        badgeElement.textContent = this.content;\r\n        if (this._animationMode === 'NoopAnimations') {\r\n            badgeElement.classList.add('_mat-animation-noopable');\r\n        }\r\n        if (this.description) {\r\n            badgeElement.setAttribute('aria-label', this.description);\r\n        }\r\n        this._elementRef.nativeElement.appendChild(badgeElement);\r\n        // animate in after insertion\r\n        if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {\r\n            this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                requestAnimationFrame((/**\r\n                 * @return {?}\r\n                 */\r\n                function () {\r\n                    badgeElement.classList.add(activeClass);\r\n                }));\r\n            }));\r\n        }\r\n        else {\r\n            badgeElement.classList.add(activeClass);\r\n        }\r\n        return badgeElement;\r\n    };\r\n    /** Sets the aria-label property on the element */\r\n    /**\r\n     * Sets the aria-label property on the element\r\n     * @private\r\n     * @param {?} newDescription\r\n     * @param {?} oldDescription\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype._updateHostAriaDescription = /**\r\n     * Sets the aria-label property on the element\r\n     * @private\r\n     * @param {?} newDescription\r\n     * @param {?} oldDescription\r\n     * @return {?}\r\n     */\r\n    function (newDescription, oldDescription) {\r\n        // ensure content available before setting label\r\n        /** @type {?} */\r\n        var content = this._updateTextContent();\r\n        if (oldDescription) {\r\n            this._ariaDescriber.removeDescription(content, oldDescription);\r\n        }\r\n        if (newDescription) {\r\n            this._ariaDescriber.describe(content, newDescription);\r\n        }\r\n    };\r\n    /** Adds css theme class given the color to the component host */\r\n    /**\r\n     * Adds css theme class given the color to the component host\r\n     * @private\r\n     * @param {?} colorPalette\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype._setColor = /**\r\n     * Adds css theme class given the color to the component host\r\n     * @private\r\n     * @param {?} colorPalette\r\n     * @return {?}\r\n     */\r\n    function (colorPalette) {\r\n        if (colorPalette !== this._color) {\r\n            if (this._color) {\r\n                this._elementRef.nativeElement.classList.remove(\"mat-badge-\" + this._color);\r\n            }\r\n            if (colorPalette) {\r\n                this._elementRef.nativeElement.classList.add(\"mat-badge-\" + colorPalette);\r\n            }\r\n        }\r\n    };\r\n    /** Clears any existing badges that might be left over from server-side rendering. */\r\n    /**\r\n     * Clears any existing badges that might be left over from server-side rendering.\r\n     * @private\r\n     * @param {?} cssClass\r\n     * @return {?}\r\n     */\r\n    MatBadge.prototype._clearExistingBadges = /**\r\n     * Clears any existing badges that might be left over from server-side rendering.\r\n     * @private\r\n     * @param {?} cssClass\r\n     * @return {?}\r\n     */\r\n    function (cssClass) {\r\n        /** @type {?} */\r\n        var element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        var childCount = element.children.length;\r\n        // Use a reverse while, because we'll be removing elements from the list as we're iterating.\r\n        while (childCount--) {\r\n            /** @type {?} */\r\n            var currentChild = element.children[childCount];\r\n            if (currentChild.classList.contains(cssClass)) {\r\n                element.removeChild(currentChild);\r\n            }\r\n        }\r\n    };\r\n    MatBadge.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[matBadge]',\r\n                    inputs: ['disabled: matBadgeDisabled'],\r\n                    host: {\r\n                        'class': 'mat-badge',\r\n                        '[class.mat-badge-overlap]': 'overlap',\r\n                        '[class.mat-badge-above]': 'isAbove()',\r\n                        '[class.mat-badge-below]': '!isAbove()',\r\n                        '[class.mat-badge-before]': '!isAfter()',\r\n                        '[class.mat-badge-after]': 'isAfter()',\r\n                        '[class.mat-badge-small]': 'size === \"small\"',\r\n                        '[class.mat-badge-medium]': 'size === \"medium\"',\r\n                        '[class.mat-badge-large]': 'size === \"large\"',\r\n                        '[class.mat-badge-hidden]': 'hidden || !_hasContent',\r\n                        '[class.mat-badge-disabled]': 'disabled',\r\n                    },\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatBadge.ctorParameters = function () { return [\r\n        { type: NgZone },\r\n        { type: ElementRef },\r\n        { type: AriaDescriber },\r\n        { type: Renderer2 },\r\n        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\r\n    ]; };\r\n    MatBadge.propDecorators = {\r\n        color: [{ type: Input, args: ['matBadgeColor',] }],\r\n        overlap: [{ type: Input, args: ['matBadgeOverlap',] }],\r\n        position: [{ type: Input, args: ['matBadgePosition',] }],\r\n        content: [{ type: Input, args: ['matBadge',] }],\r\n        description: [{ type: Input, args: ['matBadgeDescription',] }],\r\n        size: [{ type: Input, args: ['matBadgeSize',] }],\r\n        hidden: [{ type: Input, args: ['matBadgeHidden',] }]\r\n    };\r\n    return MatBadge;\r\n}(_MatBadgeMixinBase));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatBadgeModule = /** @class */ (function () {\r\n    function MatBadgeModule() {\r\n    }\r\n    MatBadgeModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [\r\n                        A11yModule,\r\n                        MatCommonModule\r\n                    ],\r\n                    exports: [MatBadge],\r\n                    declarations: [MatBadge],\r\n                },] },\r\n    ];\r\n    return MatBadgeModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatBadgeModule, MatBadge };\r\n\r\n"]}