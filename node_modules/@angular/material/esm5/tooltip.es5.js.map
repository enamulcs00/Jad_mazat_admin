{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/tooltip.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAosBM,AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wXAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmMA,AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8ZAKG;;;;;;;;;;KAUJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAiBC","file":"tooltip.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { animate, keyframes, state, style, transition, trigger } from '@angular/animations';\r\nimport { __assign } from 'tslib';\r\nimport { AriaDescriber, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';\r\nimport { Overlay, OverlayModule } from '@angular/cdk/overlay';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ComponentPortal } from '@angular/cdk/portal';\r\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\r\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Inject, InjectionToken, Input, NgZone, Optional, ViewContainerRef, ViewEncapsulation, NgModule } from '@angular/core';\r\nimport { HAMMER_LOADER, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\r\nimport { Subject } from 'rxjs';\r\nimport { take, takeUntil } from 'rxjs/operators';\r\nimport { CommonModule } from '@angular/common';\r\nimport { GestureConfig, MatCommonModule } from '@angular/material/core';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Animations used by MatTooltip.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar matTooltipAnimations = {\r\n    /**\r\n     * Animation that transitions a tooltip in and out.\r\n     */\r\n    tooltipState: trigger('state', [\r\n        state('initial, void, hidden', style({ opacity: 0, transform: 'scale(0)' })),\r\n        state('visible', style({ transform: 'scale(1)' })),\r\n        transition('* => visible', animate('200ms cubic-bezier(0, 0, 0.2, 1)', keyframes([\r\n            style({ opacity: 0, transform: 'scale(0)', offset: 0 }),\r\n            style({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),\r\n            style({ opacity: 1, transform: 'scale(1)', offset: 1 })\r\n        ]))),\r\n        transition('* => hidden', animate('100ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0 }))),\r\n    ])\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Time in ms to throttle repositioning after scroll events.\r\n * @type {?}\r\n */\r\nvar SCROLL_THROTTLE_MS = 20;\r\n/**\r\n * CSS class that will be attached to the overlay panel.\r\n * @type {?}\r\n */\r\nvar TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\r\n/**\r\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\r\n * \\@docs-private\r\n * @param {?} position\r\n * @return {?}\r\n */\r\nfunction getMatTooltipInvalidPositionError(position) {\r\n    return Error(\"Tooltip position \\\"\" + position + \"\\\" is invalid.\");\r\n}\r\n/**\r\n * Injection token that determines the scroll handling while a tooltip is visible.\r\n * @type {?}\r\n */\r\nvar MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken('mat-tooltip-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return (/**\r\n     * @return {?}\r\n     */\r\n    function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); });\r\n}\r\n/**\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_TOOLTIP_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/**\r\n * Injection token to be used to override the default options for `matTooltip`.\r\n * @type {?}\r\n */\r\nvar MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('mat-tooltip-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {\r\n    return {\r\n        showDelay: 0,\r\n        hideDelay: 0,\r\n        touchendHideDelay: 1500,\r\n    };\r\n}\r\n/**\r\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\r\n * hiding of a tooltip provided position (defaults to below the element).\r\n *\r\n * https://material.io/design/components/tooltips.html\r\n */\r\nvar MatTooltip = /** @class */ (function () {\r\n    function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {\r\n        var _this = this;\r\n        this._overlay = _overlay;\r\n        this._elementRef = _elementRef;\r\n        this._scrollDispatcher = _scrollDispatcher;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._ngZone = _ngZone;\r\n        this._ariaDescriber = _ariaDescriber;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._dir = _dir;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._position = 'below';\r\n        this._disabled = false;\r\n        /**\r\n         * The default delay in ms before showing the tooltip after show is called\r\n         */\r\n        this.showDelay = this._defaultOptions.showDelay;\r\n        /**\r\n         * The default delay in ms before hiding the tooltip after hide is called\r\n         */\r\n        this.hideDelay = this._defaultOptions.hideDelay;\r\n        this._message = '';\r\n        this._manualListeners = new Map();\r\n        /**\r\n         * Emits when the component is destroyed.\r\n         */\r\n        this._destroyed = new Subject();\r\n        this._scrollStrategy = scrollStrategy;\r\n        /** @type {?} */\r\n        var element = _elementRef.nativeElement;\r\n        /** @type {?} */\r\n        var hasGestures = typeof window === 'undefined' || ((/** @type {?} */ (window))).Hammer || hammerLoader;\r\n        // The mouse events shouldn't be bound on mobile devices, because they can prevent the\r\n        // first tap from firing its click event or can cause the tooltip to open for clicks.\r\n        if (!platform.IOS && !platform.ANDROID) {\r\n            this._manualListeners\r\n                .set('mouseenter', (/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this.show(); }))\r\n                .set('mouseleave', (/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this.hide(); }));\r\n        }\r\n        else if (!hasGestures) {\r\n            // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise\r\n            // there's no way for the user to trigger the tooltip on a touch device.\r\n            this._manualListeners.set('touchstart', (/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this.show(); }));\r\n        }\r\n        this._manualListeners.forEach((/**\r\n         * @param {?} listener\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (listener, event) { return element.addEventListener(event, listener); }));\r\n        _focusMonitor.monitor(_elementRef).pipe(takeUntil(this._destroyed)).subscribe((/**\r\n         * @param {?} origin\r\n         * @return {?}\r\n         */\r\n        function (origin) {\r\n            // Note that the focus monitor runs outside the Angular zone.\r\n            if (!origin) {\r\n                _ngZone.run((/**\r\n                 * @return {?}\r\n                 */\r\n                function () { return _this.hide(0); }));\r\n            }\r\n            else if (origin === 'keyboard') {\r\n                _ngZone.run((/**\r\n                 * @return {?}\r\n                 */\r\n                function () { return _this.show(); }));\r\n            }\r\n        }));\r\n        if (_defaultOptions && _defaultOptions.position) {\r\n            this.position = _defaultOptions.position;\r\n        }\r\n    }\r\n    Object.defineProperty(MatTooltip.prototype, \"position\", {\r\n        /** Allows the user to define the position of the tooltip relative to the parent element */\r\n        get: /**\r\n         * Allows the user to define the position of the tooltip relative to the parent element\r\n         * @return {?}\r\n         */\r\n        function () { return this._position; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            if (value !== this._position) {\r\n                this._position = value;\r\n                if (this._overlayRef) {\r\n                    this._updatePosition();\r\n                    if (this._tooltipInstance) {\r\n                        (/** @type {?} */ (this._tooltipInstance)).show(0);\r\n                    }\r\n                    this._overlayRef.updatePosition();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTooltip.prototype, \"disabled\", {\r\n        /** Disables the display of the tooltip. */\r\n        get: /**\r\n         * Disables the display of the tooltip.\r\n         * @return {?}\r\n         */\r\n        function () { return this._disabled; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._disabled = coerceBooleanProperty(value);\r\n            // If tooltip is disabled, hide immediately.\r\n            if (this._disabled) {\r\n                this.hide(0);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTooltip.prototype, \"message\", {\r\n        /** The message to be displayed in the tooltip */\r\n        get: /**\r\n         * The message to be displayed in the tooltip\r\n         * @return {?}\r\n         */\r\n        function () { return this._message; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            var _this = this;\r\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\r\n            // If the message is not a string (e.g. number), convert it to a string and trim it.\r\n            this._message = value != null ? (\"\" + value).trim() : '';\r\n            if (!this._message && this._isTooltipVisible()) {\r\n                this.hide(0);\r\n            }\r\n            else {\r\n                this._updateTooltipMessage();\r\n                this._ngZone.runOutsideAngular((/**\r\n                 * @return {?}\r\n                 */\r\n                function () {\r\n                    // The `AriaDescriber` has some functionality that avoids adding a description if it's the\r\n                    // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\r\n                    // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\r\n                    // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\r\n                    Promise.resolve().then((/**\r\n                     * @return {?}\r\n                     */\r\n                    function () {\r\n                        _this._ariaDescriber.describe(_this._elementRef.nativeElement, _this.message);\r\n                    }));\r\n                }));\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatTooltip.prototype, \"tooltipClass\", {\r\n        /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\r\n        get: /**\r\n         * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\r\n         * @return {?}\r\n         */\r\n        function () { return this._tooltipClass; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._tooltipClass = value;\r\n            if (this._tooltipInstance) {\r\n                this._setTooltipClass(this._tooltipClass);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Setup styling-specific things\r\n     */\r\n    /**\r\n     * Setup styling-specific things\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype.ngOnInit = /**\r\n     * Setup styling-specific things\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        var elementStyle = (/** @type {?} */ (element.style));\r\n        if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\r\n            // When we bind a gesture event on an element (in this case `longpress`), HammerJS\r\n            // will add some inline styles by default, including `user-select: none`. This is\r\n            // problematic on iOS and in Safari, because it will prevent users from typing in inputs.\r\n            // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected\r\n            // behavior for text fields, we always clear the `user-select` to avoid such issues.\r\n            elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';\r\n        }\r\n        // Hammer applies `-webkit-user-drag: none` on all elements by default,\r\n        // which breaks the native drag&drop. If the consumer explicitly made\r\n        // the element draggable, clear the `-webkit-user-drag`.\r\n        if (element.draggable && elementStyle.webkitUserDrag === 'none') {\r\n            elementStyle.webkitUserDrag = '';\r\n        }\r\n    };\r\n    /**\r\n     * Dispose the tooltip when destroyed.\r\n     */\r\n    /**\r\n     * Dispose the tooltip when destroyed.\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype.ngOnDestroy = /**\r\n     * Dispose the tooltip when destroyed.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (this._overlayRef) {\r\n            this._overlayRef.dispose();\r\n            this._tooltipInstance = null;\r\n        }\r\n        // Clean up the event listeners set in the constructor\r\n        this._manualListeners.forEach((/**\r\n         * @param {?} listener\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (listener, event) {\r\n            _this._elementRef.nativeElement.removeEventListener(event, listener);\r\n        }));\r\n        this._manualListeners.clear();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n    };\r\n    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\r\n    /**\r\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\r\n     * @param {?=} delay\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype.show = /**\r\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\r\n     * @param {?=} delay\r\n     * @return {?}\r\n     */\r\n    function (delay) {\r\n        var _this = this;\r\n        if (delay === void 0) { delay = this.showDelay; }\r\n        if (this.disabled || !this.message || (this._isTooltipVisible() &&\r\n            !(/** @type {?} */ (this._tooltipInstance))._showTimeoutId && !(/** @type {?} */ (this._tooltipInstance))._hideTimeoutId)) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        var overlayRef = this._createOverlay();\r\n        this._detach();\r\n        this._portal = this._portal || new ComponentPortal(TooltipComponent, this._viewContainerRef);\r\n        this._tooltipInstance = overlayRef.attach(this._portal).instance;\r\n        this._tooltipInstance.afterHidden()\r\n            .pipe(takeUntil(this._destroyed))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this._detach(); }));\r\n        this._setTooltipClass(this._tooltipClass);\r\n        this._updateTooltipMessage();\r\n        (/** @type {?} */ (this._tooltipInstance)).show(delay);\r\n    };\r\n    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\r\n    /**\r\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\r\n     * @param {?=} delay\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype.hide = /**\r\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\r\n     * @param {?=} delay\r\n     * @return {?}\r\n     */\r\n    function (delay) {\r\n        if (delay === void 0) { delay = this.hideDelay; }\r\n        if (this._tooltipInstance) {\r\n            this._tooltipInstance.hide(delay);\r\n        }\r\n    };\r\n    /** Shows/hides the tooltip */\r\n    /**\r\n     * Shows/hides the tooltip\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype.toggle = /**\r\n     * Shows/hides the tooltip\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._isTooltipVisible() ? this.hide() : this.show();\r\n    };\r\n    /** Returns true if the tooltip is currently visible to the user */\r\n    /**\r\n     * Returns true if the tooltip is currently visible to the user\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._isTooltipVisible = /**\r\n     * Returns true if the tooltip is currently visible to the user\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return !!this._tooltipInstance && this._tooltipInstance.isVisible();\r\n    };\r\n    /** Handles the keydown events on the host element. */\r\n    /**\r\n     * Handles the keydown events on the host element.\r\n     * @param {?} e\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._handleKeydown = /**\r\n     * Handles the keydown events on the host element.\r\n     * @param {?} e\r\n     * @return {?}\r\n     */\r\n    function (e) {\r\n        if (this._isTooltipVisible() && e.keyCode === ESCAPE && !hasModifierKey(e)) {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            this.hide(0);\r\n        }\r\n    };\r\n    /** Handles the touchend events on the host element. */\r\n    /**\r\n     * Handles the touchend events on the host element.\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._handleTouchend = /**\r\n     * Handles the touchend events on the host element.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.hide(this._defaultOptions.touchendHideDelay);\r\n    };\r\n    /** Create the overlay config and position strategy */\r\n    /**\r\n     * Create the overlay config and position strategy\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._createOverlay = /**\r\n     * Create the overlay config and position strategy\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (this._overlayRef) {\r\n            return this._overlayRef;\r\n        }\r\n        /** @type {?} */\r\n        var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\r\n        // Create connected position strategy that listens for scroll events to reposition.\r\n        /** @type {?} */\r\n        var strategy = this._overlay.position()\r\n            .flexibleConnectedTo(this._elementRef)\r\n            .withTransformOriginOn('.mat-tooltip')\r\n            .withFlexibleDimensions(false)\r\n            .withViewportMargin(8)\r\n            .withScrollableContainers(scrollableAncestors);\r\n        strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**\r\n         * @param {?} change\r\n         * @return {?}\r\n         */\r\n        function (change) {\r\n            if (_this._tooltipInstance) {\r\n                if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {\r\n                    // After position changes occur and the overlay is clipped by\r\n                    // a parent scrollable then close the tooltip.\r\n                    _this._ngZone.run((/**\r\n                     * @return {?}\r\n                     */\r\n                    function () { return _this.hide(0); }));\r\n                }\r\n            }\r\n        }));\r\n        this._overlayRef = this._overlay.create({\r\n            direction: this._dir,\r\n            positionStrategy: strategy,\r\n            panelClass: TOOLTIP_PANEL_CLASS,\r\n            scrollStrategy: this._scrollStrategy()\r\n        });\r\n        this._updatePosition();\r\n        this._overlayRef.detachments()\r\n            .pipe(takeUntil(this._destroyed))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this._detach(); }));\r\n        return this._overlayRef;\r\n    };\r\n    /** Detaches the currently-attached tooltip. */\r\n    /**\r\n     * Detaches the currently-attached tooltip.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._detach = /**\r\n     * Detaches the currently-attached tooltip.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\r\n            this._overlayRef.detach();\r\n        }\r\n        this._tooltipInstance = null;\r\n    };\r\n    /** Updates the position of the current tooltip. */\r\n    /**\r\n     * Updates the position of the current tooltip.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._updatePosition = /**\r\n     * Updates the position of the current tooltip.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var position = (/** @type {?} */ ((/** @type {?} */ (this._overlayRef)).getConfig().positionStrategy));\r\n        /** @type {?} */\r\n        var origin = this._getOrigin();\r\n        /** @type {?} */\r\n        var overlay = this._getOverlayPosition();\r\n        position.withPositions([\r\n            __assign({}, origin.main, overlay.main),\r\n            __assign({}, origin.fallback, overlay.fallback)\r\n        ]);\r\n    };\r\n    /**\r\n     * Returns the origin position and a fallback position based on the user's position preference.\r\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\r\n     */\r\n    /**\r\n     * Returns the origin position and a fallback position based on the user's position preference.\r\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._getOrigin = /**\r\n     * Returns the origin position and a fallback position based on the user's position preference.\r\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var isLtr = !this._dir || this._dir.value == 'ltr';\r\n        /** @type {?} */\r\n        var position = this.position;\r\n        /** @type {?} */\r\n        var originPosition;\r\n        if (position == 'above' || position == 'below') {\r\n            originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };\r\n        }\r\n        else if (position == 'before' ||\r\n            (position == 'left' && isLtr) ||\r\n            (position == 'right' && !isLtr)) {\r\n            originPosition = { originX: 'start', originY: 'center' };\r\n        }\r\n        else if (position == 'after' ||\r\n            (position == 'right' && isLtr) ||\r\n            (position == 'left' && !isLtr)) {\r\n            originPosition = { originX: 'end', originY: 'center' };\r\n        }\r\n        else {\r\n            throw getMatTooltipInvalidPositionError(position);\r\n        }\r\n        var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;\r\n        return {\r\n            main: originPosition,\r\n            fallback: { originX: x, originY: y }\r\n        };\r\n    };\r\n    /** Returns the overlay position and a fallback position based on the user's preference */\r\n    /**\r\n     * Returns the overlay position and a fallback position based on the user's preference\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._getOverlayPosition = /**\r\n     * Returns the overlay position and a fallback position based on the user's preference\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var isLtr = !this._dir || this._dir.value == 'ltr';\r\n        /** @type {?} */\r\n        var position = this.position;\r\n        /** @type {?} */\r\n        var overlayPosition;\r\n        if (position == 'above') {\r\n            overlayPosition = { overlayX: 'center', overlayY: 'bottom' };\r\n        }\r\n        else if (position == 'below') {\r\n            overlayPosition = { overlayX: 'center', overlayY: 'top' };\r\n        }\r\n        else if (position == 'before' ||\r\n            (position == 'left' && isLtr) ||\r\n            (position == 'right' && !isLtr)) {\r\n            overlayPosition = { overlayX: 'end', overlayY: 'center' };\r\n        }\r\n        else if (position == 'after' ||\r\n            (position == 'right' && isLtr) ||\r\n            (position == 'left' && !isLtr)) {\r\n            overlayPosition = { overlayX: 'start', overlayY: 'center' };\r\n        }\r\n        else {\r\n            throw getMatTooltipInvalidPositionError(position);\r\n        }\r\n        var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;\r\n        return {\r\n            main: overlayPosition,\r\n            fallback: { overlayX: x, overlayY: y }\r\n        };\r\n    };\r\n    /** Updates the tooltip message and repositions the overlay according to the new message length */\r\n    /**\r\n     * Updates the tooltip message and repositions the overlay according to the new message length\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._updateTooltipMessage = /**\r\n     * Updates the tooltip message and repositions the overlay according to the new message length\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // Must wait for the message to be painted to the tooltip so that the overlay can properly\r\n        // calculate the correct positioning based on the size of the text.\r\n        if (this._tooltipInstance) {\r\n            this._tooltipInstance.message = this.message;\r\n            this._tooltipInstance._markForCheck();\r\n            this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1), takeUntil(this._destroyed)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                if (_this._tooltipInstance) {\r\n                    (/** @type {?} */ (_this._overlayRef)).updatePosition();\r\n                }\r\n            }));\r\n        }\r\n    };\r\n    /** Updates the tooltip class */\r\n    /**\r\n     * Updates the tooltip class\r\n     * @private\r\n     * @param {?} tooltipClass\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._setTooltipClass = /**\r\n     * Updates the tooltip class\r\n     * @private\r\n     * @param {?} tooltipClass\r\n     * @return {?}\r\n     */\r\n    function (tooltipClass) {\r\n        if (this._tooltipInstance) {\r\n            this._tooltipInstance.tooltipClass = tooltipClass;\r\n            this._tooltipInstance._markForCheck();\r\n        }\r\n    };\r\n    /** Inverts an overlay position. */\r\n    /**\r\n     * Inverts an overlay position.\r\n     * @private\r\n     * @param {?} x\r\n     * @param {?} y\r\n     * @return {?}\r\n     */\r\n    MatTooltip.prototype._invertPosition = /**\r\n     * Inverts an overlay position.\r\n     * @private\r\n     * @param {?} x\r\n     * @param {?} y\r\n     * @return {?}\r\n     */\r\n    function (x, y) {\r\n        if (this.position === 'above' || this.position === 'below') {\r\n            if (y === 'top') {\r\n                y = 'bottom';\r\n            }\r\n            else if (y === 'bottom') {\r\n                y = 'top';\r\n            }\r\n        }\r\n        else {\r\n            if (x === 'end') {\r\n                x = 'start';\r\n            }\r\n            else if (x === 'start') {\r\n                x = 'end';\r\n            }\r\n        }\r\n        return { x: x, y: y };\r\n    };\r\n    MatTooltip.decorators = [\r\n        { type: Directive, args: [{\r\n                    selector: '[matTooltip]',\r\n                    exportAs: 'matTooltip',\r\n                    host: {\r\n                        '(longpress)': 'show()',\r\n                        '(keydown)': '_handleKeydown($event)',\r\n                        '(touchend)': '_handleTouchend()',\r\n                    },\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatTooltip.ctorParameters = function () { return [\r\n        { type: Overlay },\r\n        { type: ElementRef },\r\n        { type: ScrollDispatcher },\r\n        { type: ViewContainerRef },\r\n        { type: NgZone },\r\n        { type: Platform },\r\n        { type: AriaDescriber },\r\n        { type: FocusMonitor },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },\r\n        { type: Directionality, decorators: [{ type: Optional }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HAMMER_LOADER,] }] }\r\n    ]; };\r\n    MatTooltip.propDecorators = {\r\n        position: [{ type: Input, args: ['matTooltipPosition',] }],\r\n        disabled: [{ type: Input, args: ['matTooltipDisabled',] }],\r\n        showDelay: [{ type: Input, args: ['matTooltipShowDelay',] }],\r\n        hideDelay: [{ type: Input, args: ['matTooltipHideDelay',] }],\r\n        message: [{ type: Input, args: ['matTooltip',] }],\r\n        tooltipClass: [{ type: Input, args: ['matTooltipClass',] }]\r\n    };\r\n    return MatTooltip;\r\n}());\r\n/**\r\n * Internal component that wraps the tooltip's content.\r\n * \\@docs-private\r\n */\r\nvar TooltipComponent = /** @class */ (function () {\r\n    function TooltipComponent(_changeDetectorRef, _breakpointObserver) {\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._breakpointObserver = _breakpointObserver;\r\n        /**\r\n         * Property watched by the animation framework to show or hide the tooltip\r\n         */\r\n        this._visibility = 'initial';\r\n        /**\r\n         * Whether interactions on the page should close the tooltip\r\n         */\r\n        this._closeOnInteraction = false;\r\n        /**\r\n         * Subject for notifying that the tooltip has been hidden from the view\r\n         */\r\n        this._onHide = new Subject();\r\n        /**\r\n         * Stream that emits whether the user has a handset-sized display.\r\n         */\r\n        this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);\r\n    }\r\n    /**\r\n     * Shows the tooltip with an animation originating from the provided origin\r\n     * @param delay Amount of milliseconds to the delay showing the tooltip.\r\n     */\r\n    /**\r\n     * Shows the tooltip with an animation originating from the provided origin\r\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype.show = /**\r\n     * Shows the tooltip with an animation originating from the provided origin\r\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\r\n     * @return {?}\r\n     */\r\n    function (delay) {\r\n        var _this = this;\r\n        // Cancel the delayed hide if it is scheduled\r\n        if (this._hideTimeoutId) {\r\n            clearTimeout(this._hideTimeoutId);\r\n            this._hideTimeoutId = null;\r\n        }\r\n        // Body interactions should cancel the tooltip if there is a delay in showing.\r\n        this._closeOnInteraction = true;\r\n        this._showTimeoutId = setTimeout((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._visibility = 'visible';\r\n            _this._showTimeoutId = null;\r\n            // Mark for check so if any parent component has set the\r\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\r\n            _this._markForCheck();\r\n        }), delay);\r\n    };\r\n    /**\r\n     * Begins the animation to hide the tooltip after the provided delay in ms.\r\n     * @param delay Amount of milliseconds to delay showing the tooltip.\r\n     */\r\n    /**\r\n     * Begins the animation to hide the tooltip after the provided delay in ms.\r\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype.hide = /**\r\n     * Begins the animation to hide the tooltip after the provided delay in ms.\r\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\r\n     * @return {?}\r\n     */\r\n    function (delay) {\r\n        var _this = this;\r\n        // Cancel the delayed show if it is scheduled\r\n        if (this._showTimeoutId) {\r\n            clearTimeout(this._showTimeoutId);\r\n            this._showTimeoutId = null;\r\n        }\r\n        this._hideTimeoutId = setTimeout((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._visibility = 'hidden';\r\n            _this._hideTimeoutId = null;\r\n            // Mark for check so if any parent component has set the\r\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\r\n            _this._markForCheck();\r\n        }), delay);\r\n    };\r\n    /** Returns an observable that notifies when the tooltip has been hidden from view. */\r\n    /**\r\n     * Returns an observable that notifies when the tooltip has been hidden from view.\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype.afterHidden = /**\r\n     * Returns an observable that notifies when the tooltip has been hidden from view.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._onHide.asObservable();\r\n    };\r\n    /** Whether the tooltip is being displayed. */\r\n    /**\r\n     * Whether the tooltip is being displayed.\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype.isVisible = /**\r\n     * Whether the tooltip is being displayed.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this._visibility === 'visible';\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._onHide.complete();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype._animationStart = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._closeOnInteraction = false;\r\n    };\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype._animationDone = /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        /** @type {?} */\r\n        var toState = (/** @type {?} */ (event.toState));\r\n        if (toState === 'hidden' && !this.isVisible()) {\r\n            this._onHide.next();\r\n        }\r\n        if (toState === 'visible' || toState === 'hidden') {\r\n            this._closeOnInteraction = true;\r\n        }\r\n    };\r\n    /**\r\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\r\n     * material design spec.\r\n     * https://material.io/design/components/tooltips.html#behavior\r\n     */\r\n    /**\r\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\r\n     * material design spec.\r\n     * https://material.io/design/components/tooltips.html#behavior\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype._handleBodyInteraction = /**\r\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\r\n     * material design spec.\r\n     * https://material.io/design/components/tooltips.html#behavior\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._closeOnInteraction) {\r\n            this.hide(0);\r\n        }\r\n    };\r\n    /**\r\n     * Marks that the tooltip needs to be checked in the next change detection run.\r\n     * Mainly used for rendering the initial text before positioning a tooltip, which\r\n     * can be problematic in components with OnPush change detection.\r\n     */\r\n    /**\r\n     * Marks that the tooltip needs to be checked in the next change detection run.\r\n     * Mainly used for rendering the initial text before positioning a tooltip, which\r\n     * can be problematic in components with OnPush change detection.\r\n     * @return {?}\r\n     */\r\n    TooltipComponent.prototype._markForCheck = /**\r\n     * Marks that the tooltip needs to be checked in the next change detection run.\r\n     * Mainly used for rendering the initial text before positioning a tooltip, which\r\n     * can be problematic in components with OnPush change detection.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._changeDetectorRef.markForCheck();\r\n    };\r\n    TooltipComponent.decorators = [\r\n        { type: Component, args: [{selector: 'mat-tooltip-component',\r\n                    template: \"<div class=\\\"mat-tooltip\\\" [ngClass]=\\\"tooltipClass\\\" [class.mat-tooltip-handset]=\\\"(_isHandset | async)?.matches\\\" [@state]=\\\"_visibility\\\" (@state.start)=\\\"_animationStart()\\\" (@state.done)=\\\"_animationDone($event)\\\">{{message}}</div>\",\r\n                    styles: [\".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\"],\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    animations: [matTooltipAnimations.tooltipState],\r\n                    host: {\r\n                        // Forces the element to have a layout in IE and Edge. This fixes issues where the element\r\n                        // won't be rendered if the animations are disabled or there is no web animations polyfill.\r\n                        '[style.zoom]': '_visibility === \"visible\" ? 1 : null',\r\n                        '(body:click)': 'this._handleBodyInteraction()',\r\n                        'aria-hidden': 'true',\r\n                    }\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    TooltipComponent.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: BreakpointObserver }\r\n    ]; };\r\n    return TooltipComponent;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatTooltipModule = /** @class */ (function () {\r\n    function MatTooltipModule() {\r\n    }\r\n    MatTooltipModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [\r\n                        A11yModule,\r\n                        CommonModule,\r\n                        OverlayModule,\r\n                        MatCommonModule,\r\n                    ],\r\n                    exports: [MatTooltip, TooltipComponent, MatCommonModule],\r\n                    declarations: [MatTooltip, TooltipComponent],\r\n                    entryComponents: [TooltipComponent],\r\n                    providers: [\r\n                        MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,\r\n                        { provide: HAMMER_GESTURE_CONFIG, useClass: GestureConfig },\r\n                    ]\r\n                },] },\r\n    ];\r\n    return MatTooltipModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatTooltipModule, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations };\r\n\r\n"]}