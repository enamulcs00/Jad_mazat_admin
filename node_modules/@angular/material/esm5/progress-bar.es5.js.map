{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/progress-bar.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoOM,AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAcA;;;;;;;;;;;;;;;;;;;;;;KAsBD;;;;;;;;;;;;;4BAOC","file":"progress-bar.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { __extends } from 'tslib';\r\nimport { Component, ChangeDetectionStrategy, ElementRef, Inject, Input, Output, EventEmitter, Optional, NgZone, ViewEncapsulation, ViewChild, InjectionToken, inject, NgModule } from '@angular/core';\r\nimport { fromEvent, Subscription } from 'rxjs';\r\nimport { filter } from 'rxjs/operators';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// Boilerplate for applying mixins to MatProgressBar.\r\n/**\r\n * \\@docs-private\r\n */\r\nvar \r\n// Boilerplate for applying mixins to MatProgressBar.\r\n/**\r\n * \\@docs-private\r\n */\r\nMatProgressBarBase = /** @class */ (function () {\r\n    function MatProgressBarBase(_elementRef) {\r\n        this._elementRef = _elementRef;\r\n    }\r\n    return MatProgressBarBase;\r\n}());\r\n/** @type {?} */\r\nvar _MatProgressBarMixinBase = mixinColor(MatProgressBarBase, 'primary');\r\n/**\r\n * Injection token used to provide the current location to `MatProgressBar`.\r\n * Used to handle server-side rendering and to stub out during unit tests.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar MAT_PROGRESS_BAR_LOCATION = new InjectionToken('mat-progress-bar-location', { providedIn: 'root', factory: MAT_PROGRESS_BAR_LOCATION_FACTORY });\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_PROGRESS_BAR_LOCATION_FACTORY() {\r\n    /** @type {?} */\r\n    var _document = inject(DOCUMENT);\r\n    /** @type {?} */\r\n    var _location = _document ? _document.location : null;\r\n    return {\r\n        // Note that this needs to be a function, rather than a property, because Angular\r\n        // will only resolve it once, but we want the current path on each call.\r\n        getPathname: (/**\r\n         * @return {?}\r\n         */\r\n        function () { return _location ? (_location.pathname + _location.search) : ''; })\r\n    };\r\n}\r\n/**\r\n * Counter used to generate unique IDs for progress bars.\r\n * @type {?}\r\n */\r\nvar progressbarId = 0;\r\n/**\r\n * `<mat-progress-bar>` component.\r\n */\r\nvar MatProgressBar = /** @class */ (function (_super) {\r\n    __extends(MatProgressBar, _super);\r\n    function MatProgressBar(_elementRef, _ngZone, _animationMode, \r\n    /**\r\n     * @deprecated `location` parameter to be made required.\r\n     * @breaking-change 8.0.0\r\n     */\r\n    location) {\r\n        var _this = _super.call(this, _elementRef) || this;\r\n        _this._elementRef = _elementRef;\r\n        _this._ngZone = _ngZone;\r\n        _this._animationMode = _animationMode;\r\n        /**\r\n         * Flag that indicates whether NoopAnimations mode is set to true.\r\n         */\r\n        _this._isNoopAnimation = false;\r\n        _this._value = 0;\r\n        _this._bufferValue = 0;\r\n        /**\r\n         * Event emitted when animation of the primary progress bar completes. This event will not\r\n         * be emitted when animations are disabled, nor will it be emitted for modes with continuous\r\n         * animations (indeterminate and query).\r\n         */\r\n        _this.animationEnd = new EventEmitter();\r\n        /**\r\n         * Reference to animation end subscription to be unsubscribed on destroy.\r\n         */\r\n        _this._animationEndSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Mode of the progress bar.\r\n         *\r\n         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\r\n         * 'determinate'.\r\n         * Mirrored to mode attribute.\r\n         */\r\n        _this.mode = 'determinate';\r\n        /**\r\n         * ID of the progress bar.\r\n         */\r\n        _this.progressbarId = \"mat-progress-bar-\" + progressbarId++;\r\n        // We need to prefix the SVG reference with the current path, otherwise they won't work\r\n        // in Safari if the page has a `<base>` tag. Note that we need quotes inside the `url()`,\r\n        // because named route URLs can contain parentheses (see #12338). Also we don't use since\r\n        // we can't tell the difference between whether\r\n        // the consumer is using the hash location strategy or not, because `Location` normalizes\r\n        // both `/#/foo/bar` and `/foo/bar` to the same thing.\r\n        /** @type {?} */\r\n        var path = location ? location.getPathname().split('#')[0] : '';\r\n        _this._rectangleFillValue = \"url('\" + path + \"#\" + _this.progressbarId + \"')\";\r\n        _this._isNoopAnimation = _animationMode === 'NoopAnimations';\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatProgressBar.prototype, \"value\", {\r\n        /** Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow. */\r\n        get: /**\r\n         * Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.\r\n         * @return {?}\r\n         */\r\n        function () { return this._value; },\r\n        set: /**\r\n         * @param {?} v\r\n         * @return {?}\r\n         */\r\n        function (v) {\r\n            this._value = clamp(v || 0);\r\n            // When noop animation is set to true, trigger animationEnd directly.\r\n            if (this._isNoopAnimation) {\r\n                this._emitAnimationEnd();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatProgressBar.prototype, \"bufferValue\", {\r\n        /** Buffer value of the progress bar. Defaults to zero. */\r\n        get: /**\r\n         * Buffer value of the progress bar. Defaults to zero.\r\n         * @return {?}\r\n         */\r\n        function () { return this._bufferValue; },\r\n        set: /**\r\n         * @param {?} v\r\n         * @return {?}\r\n         */\r\n        function (v) { this._bufferValue = clamp(v || 0); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Gets the current transform value for the progress bar's primary indicator. */\r\n    /**\r\n     * Gets the current transform value for the progress bar's primary indicator.\r\n     * @return {?}\r\n     */\r\n    MatProgressBar.prototype._primaryTransform = /**\r\n     * Gets the current transform value for the progress bar's primary indicator.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        /** @type {?} */\r\n        var scale = this.value / 100;\r\n        return { transform: \"scaleX(\" + scale + \")\" };\r\n    };\r\n    /**\r\n     * Gets the current transform value for the progress bar's buffer indicator. Only used if the\r\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\r\n     */\r\n    /**\r\n     * Gets the current transform value for the progress bar's buffer indicator. Only used if the\r\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\r\n     * @return {?}\r\n     */\r\n    MatProgressBar.prototype._bufferTransform = /**\r\n     * Gets the current transform value for the progress bar's buffer indicator. Only used if the\r\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this.mode === 'buffer') {\r\n            /** @type {?} */\r\n            var scale = this.bufferValue / 100;\r\n            return { transform: \"scaleX(\" + scale + \")\" };\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatProgressBar.prototype.ngAfterViewInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (!this._isNoopAnimation) {\r\n            // Run outside angular so change detection didn't get triggered on every transition end\r\n            // instead only on the animation that we care about (primary value bar's transitionend)\r\n            this._ngZone.runOutsideAngular(((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                /** @type {?} */\r\n                var element = _this._primaryValueBar.nativeElement;\r\n                _this._animationEndSubscription =\r\n                    ((/** @type {?} */ (fromEvent(element, 'transitionend'))))\r\n                        .pipe(filter(((/**\r\n                     * @param {?} e\r\n                     * @return {?}\r\n                     */\r\n                    function (e) { return e.target === element; }))))\r\n                        .subscribe((/**\r\n                     * @return {?}\r\n                     */\r\n                    function () { return _this._ngZone.run((/**\r\n                     * @return {?}\r\n                     */\r\n                    function () { return _this._emitAnimationEnd(); })); }));\r\n            })));\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatProgressBar.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._animationEndSubscription.unsubscribe();\r\n    };\r\n    /** Emit an animationEnd event if in determinate or buffer mode. */\r\n    /**\r\n     * Emit an animationEnd event if in determinate or buffer mode.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatProgressBar.prototype._emitAnimationEnd = /**\r\n     * Emit an animationEnd event if in determinate or buffer mode.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this.mode === 'determinate' || this.mode === 'buffer') {\r\n            this.animationEnd.next({ value: this.value });\r\n        }\r\n    };\r\n    MatProgressBar.decorators = [\r\n        { type: Component, args: [{selector: 'mat-progress-bar',\r\n                    exportAs: 'matProgressBar',\r\n                    host: {\r\n                        'role': 'progressbar',\r\n                        'aria-valuemin': '0',\r\n                        'aria-valuemax': '100',\r\n                        '[attr.aria-valuenow]': '(mode === \"indeterminate\" || mode === \"query\") ? null : value',\r\n                        '[attr.mode]': 'mode',\r\n                        'class': 'mat-progress-bar',\r\n                        '[class._mat-animation-noopable]': '_isNoopAnimation',\r\n                    },\r\n                    inputs: ['color'],\r\n                    template: \"<svg width=\\\"100%\\\" height=\\\"4\\\" focusable=\\\"false\\\" class=\\\"mat-progress-bar-background mat-progress-bar-element\\\"><defs><pattern [id]=\\\"progressbarId\\\" x=\\\"4\\\" y=\\\"0\\\" width=\\\"8\\\" height=\\\"4\\\" patternUnits=\\\"userSpaceOnUse\\\"><circle cx=\\\"2\\\" cy=\\\"2\\\" r=\\\"2\\\"/></pattern></defs><rect [attr.fill]=\\\"_rectangleFillValue\\\" width=\\\"100%\\\" height=\\\"100%\\\"/></svg><div class=\\\"mat-progress-bar-buffer mat-progress-bar-element\\\" [ngStyle]=\\\"_bufferTransform()\\\"></div><div class=\\\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\\\" [ngStyle]=\\\"_primaryTransform()\\\" #primaryValueBar></div><div class=\\\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\\\"></div>\",\r\n                    styles: [\".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\"],\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatProgressBar.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: NgZone },\r\n        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_PROGRESS_BAR_LOCATION,] }] }\r\n    ]; };\r\n    MatProgressBar.propDecorators = {\r\n        value: [{ type: Input }],\r\n        bufferValue: [{ type: Input }],\r\n        _primaryValueBar: [{ type: ViewChild, args: ['primaryValueBar', { static: false },] }],\r\n        animationEnd: [{ type: Output }],\r\n        mode: [{ type: Input }]\r\n    };\r\n    return MatProgressBar;\r\n}(_MatProgressBarMixinBase));\r\n/**\r\n * Clamps a value to be between two numbers, by default 0 and 100.\r\n * @param {?} v\r\n * @param {?=} min\r\n * @param {?=} max\r\n * @return {?}\r\n */\r\nfunction clamp(v, min, max) {\r\n    if (min === void 0) { min = 0; }\r\n    if (max === void 0) { max = 100; }\r\n    return Math.max(min, Math.min(max, v));\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatProgressBarModule = /** @class */ (function () {\r\n    function MatProgressBarModule() {\r\n    }\r\n    MatProgressBarModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [CommonModule, MatCommonModule],\r\n                    exports: [MatProgressBar, MatCommonModule],\r\n                    declarations: [MatProgressBar],\r\n                },] },\r\n    ];\r\n    return MatProgressBarModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatProgressBarModule, MAT_PROGRESS_BAR_LOCATION_FACTORY, MAT_PROGRESS_BAR_LOCATION, MatProgressBar };\r\n\r\n"]}