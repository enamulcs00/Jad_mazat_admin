{"version":3,"sources":["v:/jad-admin-go/mazat_admin_panel/node_modules/@angular/material/esm5/sidenav.es5.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyEM,AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAWG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmjBH,AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwjBA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAkBA;;;;;;;;;;;;KAYD,AAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gGAWG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAgEF,AAuBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAKA;;;;;;;KAOD,AAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAIA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2BC","file":"sidenav.es5.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { animate, state, style, transition, trigger } from '@angular/animations';\r\nimport { __extends } from 'tslib';\r\nimport { FocusMonitor, FocusTrapFactory } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\r\nimport { CdkScrollable, ScrollDispatcher, ViewportRuler, ScrollingModule } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, forwardRef, Inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewEncapsulation, HostListener, HostBinding, NgModule } from '@angular/core';\r\nimport { fromEvent, merge, Subject } from 'rxjs';\r\nimport { debounceTime, filter, map, startWith, take, takeUntil, distinctUntilChanged } from 'rxjs/operators';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\nimport { MatCommonModule } from '@angular/material/core';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Animations used by the Material drawers.\r\n * \\@docs-private\r\n * @type {?}\r\n */\r\nvar matDrawerAnimations = {\r\n    /**\r\n     * Animation that slides a drawer in and out.\r\n     */\r\n    transformDrawer: trigger('transform', [\r\n        // We remove the `transform` here completely, rather than setting it to zero, because:\r\n        // 1. Having a transform can cause elements with ripples or an animated\r\n        //    transform to shift around in Chrome with an RTL layout (see #10023).\r\n        // 2. 3d transforms causes text to appear blurry on IE and Edge.\r\n        state('open, open-instant', style({\r\n            'transform': 'none',\r\n            'visibility': 'visible',\r\n        })),\r\n        state('void', style({\r\n            // Avoids the shadow showing up when closed in SSR.\r\n            'box-shadow': 'none',\r\n            'visibility': 'hidden',\r\n        })),\r\n        transition('void => open-instant', animate('0ms')),\r\n        transition('void <=> open, open-instant => void', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\r\n    ])\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Throws an exception when two MatDrawer are matching the same position.\r\n * \\@docs-private\r\n * @param {?} position\r\n * @return {?}\r\n */\r\nfunction throwMatDuplicatedDrawerError(position) {\r\n    throw Error(\"A drawer was already declared for 'position=\\\"\" + position + \"\\\"'\");\r\n}\r\n/**\r\n * Configures whether drawers should use auto sizing by default.\r\n * @type {?}\r\n */\r\nvar MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {\r\n    providedIn: 'root',\r\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\r\n    return false;\r\n}\r\nvar MatDrawerContent = /** @class */ (function (_super) {\r\n    __extends(MatDrawerContent, _super);\r\n    function MatDrawerContent(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {\r\n        var _this = _super.call(this, elementRef, scrollDispatcher, ngZone) || this;\r\n        _this._changeDetectorRef = _changeDetectorRef;\r\n        _this._container = _container;\r\n        return _this;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContent.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._container._contentMarginChanges.subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._changeDetectorRef.markForCheck();\r\n        }));\r\n    };\r\n    MatDrawerContent.decorators = [\r\n        { type: Component, args: [{selector: 'mat-drawer-content',\r\n                    template: '<ng-content></ng-content>',\r\n                    host: {\r\n                        'class': 'mat-drawer-content',\r\n                        '[style.margin-left.px]': '_container._contentMargins.left',\r\n                        '[style.margin-right.px]': '_container._contentMargins.right',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDrawerContent.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef((/**\r\n                         * @return {?}\r\n                         */\r\n                        function () { return MatDrawerContainer; })),] }] },\r\n        { type: ElementRef },\r\n        { type: ScrollDispatcher },\r\n        { type: NgZone }\r\n    ]; };\r\n    return MatDrawerContent;\r\n}(CdkScrollable));\r\n/**\r\n * This component corresponds to a drawer that can be opened on the drawer container.\r\n */\r\nvar MatDrawer = /** @class */ (function () {\r\n    function MatDrawer(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {\r\n        var _this = this;\r\n        this._elementRef = _elementRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._platform = _platform;\r\n        this._ngZone = _ngZone;\r\n        this._doc = _doc;\r\n        this._elementFocusedBeforeDrawerWasOpened = null;\r\n        /**\r\n         * Whether the drawer is initialized. Used for disabling the initial animation.\r\n         */\r\n        this._enableAnimations = false;\r\n        this._position = 'start';\r\n        this._mode = 'over';\r\n        this._disableClose = false;\r\n        this._autoFocus = true;\r\n        /**\r\n         * Emits whenever the drawer has started animating.\r\n         */\r\n        this._animationStarted = new Subject();\r\n        /**\r\n         * Emits whenever the drawer is done animating.\r\n         */\r\n        this._animationEnd = new Subject();\r\n        /**\r\n         * Current state of the sidenav animation.\r\n         */\r\n        // @HostBinding is used in the class as it is expected to be extended.  Since @Component decorator\r\n        // metadata is not inherited by child classes, instead the host binding data is defined in a way\r\n        // that can be inherited.\r\n        // tslint:disable:no-host-decorator-in-concrete\r\n        this._animationState = 'void';\r\n        /**\r\n         * Event emitted when the drawer open state is changed.\r\n         */\r\n        this.openedChange = \r\n        // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\r\n        new EventEmitter(/* isAsync */ true);\r\n        /**\r\n         * Emits when the component is destroyed.\r\n         */\r\n        this._destroyed = new Subject();\r\n        /**\r\n         * Event emitted when the drawer's position changes.\r\n         */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onPositionChanged = new EventEmitter();\r\n        /**\r\n         * An observable that emits when the drawer mode changes. This is used by the drawer container to\r\n         * to know when to when the mode changes so it can adapt the margins on the content.\r\n         */\r\n        this._modeChanged = new Subject();\r\n        this._opened = false;\r\n        this.openedChange.subscribe((/**\r\n         * @param {?} opened\r\n         * @return {?}\r\n         */\r\n        function (opened) {\r\n            if (opened) {\r\n                if (_this._doc) {\r\n                    _this._elementFocusedBeforeDrawerWasOpened = (/** @type {?} */ (_this._doc.activeElement));\r\n                }\r\n                if (_this._isFocusTrapEnabled && _this._focusTrap) {\r\n                    _this._trapFocus();\r\n                }\r\n            }\r\n            else {\r\n                _this._restoreFocus();\r\n            }\r\n        }));\r\n        /**\r\n         * Listen to `keydown` events outside the zone so that change detection is not run every\r\n         * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\r\n         * and we don't have close disabled.\r\n         */\r\n        this._ngZone.runOutsideAngular((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            ((/** @type {?} */ (fromEvent(_this._elementRef.nativeElement, 'keydown')))).pipe(filter((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            function (event) {\r\n                return event.keyCode === ESCAPE && !_this.disableClose && !hasModifierKey(event);\r\n            })), takeUntil(_this._destroyed)).subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            function (event) { return _this._ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this.close();\r\n                event.stopPropagation();\r\n                event.preventDefault();\r\n            })); }));\r\n        }));\r\n        // We need a Subject with distinctUntilChanged, because the `done` event\r\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\r\n        this._animationEnd.pipe(distinctUntilChanged((/**\r\n         * @param {?} x\r\n         * @param {?} y\r\n         * @return {?}\r\n         */\r\n        function (x, y) {\r\n            return x.fromState === y.fromState && x.toState === y.toState;\r\n        }))).subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            var fromState = event.fromState, toState = event.toState;\r\n            if ((toState.indexOf('open') === 0 && fromState === 'void') ||\r\n                (toState === 'void' && fromState.indexOf('open') === 0)) {\r\n                _this.openedChange.emit(_this._opened);\r\n            }\r\n        }));\r\n    }\r\n    Object.defineProperty(MatDrawer.prototype, \"position\", {\r\n        /** The side that the drawer is attached to. */\r\n        get: /**\r\n         * The side that the drawer is attached to.\r\n         * @return {?}\r\n         */\r\n        function () { return this._position; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            // Make sure we have a valid value.\r\n            value = value === 'end' ? 'end' : 'start';\r\n            if (value != this._position) {\r\n                this._position = value;\r\n                this.onPositionChanged.emit();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"mode\", {\r\n        /** Mode of the drawer; one of 'over', 'push' or 'side'. */\r\n        get: /**\r\n         * Mode of the drawer; one of 'over', 'push' or 'side'.\r\n         * @return {?}\r\n         */\r\n        function () { return this._mode; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._mode = value;\r\n            this._updateFocusTrapState();\r\n            this._modeChanged.next();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"disableClose\", {\r\n        /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\r\n        get: /**\r\n         * Whether the drawer can be closed with the escape key or by clicking on the backdrop.\r\n         * @return {?}\r\n         */\r\n        function () { return this._disableClose; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._disableClose = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"autoFocus\", {\r\n        /** Whether the drawer should focus the first focusable element automatically when opened. */\r\n        get: /**\r\n         * Whether the drawer should focus the first focusable element automatically when opened.\r\n         * @return {?}\r\n         */\r\n        function () { return this._autoFocus; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._autoFocus = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"_openedStream\", {\r\n        /** Event emitted when the drawer has been opened. */\r\n        get: /**\r\n         * Event emitted when the drawer has been opened.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this.openedChange.pipe(filter((/**\r\n             * @param {?} o\r\n             * @return {?}\r\n             */\r\n            function (o) { return o; })), map((/**\r\n             * @return {?}\r\n             */\r\n            function () { })));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"openedStart\", {\r\n        /** Event emitted when the drawer has started opening. */\r\n        get: /**\r\n         * Event emitted when the drawer has started opening.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._animationStarted.pipe(filter((/**\r\n             * @param {?} e\r\n             * @return {?}\r\n             */\r\n            function (e) { return e.fromState !== e.toState && e.toState.indexOf('open') === 0; })), map((/**\r\n             * @return {?}\r\n             */\r\n            function () { })));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"_closedStream\", {\r\n        /** Event emitted when the drawer has been closed. */\r\n        get: /**\r\n         * Event emitted when the drawer has been closed.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this.openedChange.pipe(filter((/**\r\n             * @param {?} o\r\n             * @return {?}\r\n             */\r\n            function (o) { return !o; })), map((/**\r\n             * @return {?}\r\n             */\r\n            function () { })));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"closedStart\", {\r\n        /** Event emitted when the drawer has started closing. */\r\n        get: /**\r\n         * Event emitted when the drawer has started closing.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._animationStarted.pipe(filter((/**\r\n             * @param {?} e\r\n             * @return {?}\r\n             */\r\n            function (e) { return e.fromState !== e.toState && e.toState === 'void'; })), map((/**\r\n             * @return {?}\r\n             */\r\n            function () { })));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawer.prototype, \"_isFocusTrapEnabled\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // The focus trap is only enabled when the drawer is open in any mode other than side.\r\n            return this.opened && this.mode !== 'side';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Traps focus inside the drawer. */\r\n    /**\r\n     * Traps focus inside the drawer.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype._trapFocus = /**\r\n     * Traps focus inside the drawer.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        if (!this.autoFocus) {\r\n            return;\r\n        }\r\n        this._focusTrap.focusInitialElementWhenReady().then((/**\r\n         * @param {?} hasMovedFocus\r\n         * @return {?}\r\n         */\r\n        function (hasMovedFocus) {\r\n            // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\r\n            // still works. We need to check that `focus` is a function due to Universal.\r\n            if (!hasMovedFocus && typeof _this._elementRef.nativeElement.focus === 'function') {\r\n                _this._elementRef.nativeElement.focus();\r\n            }\r\n        }));\r\n    };\r\n    /**\r\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\r\n     * opened.\r\n     */\r\n    /**\r\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\r\n     * opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype._restoreFocus = /**\r\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\r\n     * opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (!this.autoFocus) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        var activeEl = this._doc && this._doc.activeElement;\r\n        if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\r\n            if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\r\n                this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\r\n            }\r\n            else {\r\n                this._elementRef.nativeElement.blur();\r\n            }\r\n        }\r\n        this._elementFocusedBeforeDrawerWasOpened = null;\r\n        this._openedVia = null;\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\r\n        this._updateFocusTrapState();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.ngAfterContentChecked = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // Enable the animations after the lifecycle hooks have run, in order to avoid animating\r\n        // drawers that are open by default. When we're on the server, we shouldn't enable the\r\n        // animations, because we don't want the drawer to animate the first time the user sees\r\n        // the page.\r\n        if (this._platform.isBrowser) {\r\n            this._enableAnimations = true;\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._focusTrap) {\r\n            this._focusTrap.destroy();\r\n        }\r\n        this._animationStarted.complete();\r\n        this._animationEnd.complete();\r\n        this._modeChanged.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    };\r\n    Object.defineProperty(MatDrawer.prototype, \"opened\", {\r\n        /**\r\n         * Whether the drawer is opened. We overload this because we trigger an event when it\r\n         * starts or end.\r\n         */\r\n        get: /**\r\n         * Whether the drawer is opened. We overload this because we trigger an event when it\r\n         * starts or end.\r\n         * @return {?}\r\n         */\r\n        function () { return this._opened; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this.toggle(coerceBooleanProperty(value)); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Open the drawer.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    /**\r\n     * Open the drawer.\r\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.open = /**\r\n     * Open the drawer.\r\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     * @return {?}\r\n     */\r\n    function (openedVia) {\r\n        return this.toggle(true, openedVia);\r\n    };\r\n    /** Close the drawer. */\r\n    /**\r\n     * Close the drawer.\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.close = /**\r\n     * Close the drawer.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return this.toggle(false);\r\n    };\r\n    /**\r\n     * Toggle this drawer.\r\n     * @param isOpen Whether the drawer should be open.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    /**\r\n     * Toggle this drawer.\r\n     * @param {?=} isOpen Whether the drawer should be open.\r\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype.toggle = /**\r\n     * Toggle this drawer.\r\n     * @param {?=} isOpen Whether the drawer should be open.\r\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     * @return {?}\r\n     */\r\n    function (isOpen, openedVia) {\r\n        var _this = this;\r\n        if (isOpen === void 0) { isOpen = !this.opened; }\r\n        if (openedVia === void 0) { openedVia = 'program'; }\r\n        this._opened = isOpen;\r\n        if (isOpen) {\r\n            this._animationState = this._enableAnimations ? 'open' : 'open-instant';\r\n            this._openedVia = openedVia;\r\n        }\r\n        else {\r\n            this._animationState = 'void';\r\n            this._restoreFocus();\r\n        }\r\n        this._updateFocusTrapState();\r\n        return new Promise((/**\r\n         * @param {?} resolve\r\n         * @return {?}\r\n         */\r\n        function (resolve) {\r\n            _this.openedChange.pipe(take(1)).subscribe((/**\r\n             * @param {?} open\r\n             * @return {?}\r\n             */\r\n            function (open) { return resolve(open ? 'open' : 'close'); }));\r\n        }));\r\n    };\r\n    Object.defineProperty(MatDrawer.prototype, \"_width\", {\r\n        get: /**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Updates the enabled state of the focus trap. */\r\n    /**\r\n     * Updates the enabled state of the focus trap.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype._updateFocusTrapState = /**\r\n     * Updates the enabled state of the focus trap.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        if (this._focusTrap) {\r\n            this._focusTrap.enabled = this._isFocusTrapEnabled;\r\n        }\r\n    };\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype._animationStartListener = \r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        this._animationStarted.next(event);\r\n    };\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    MatDrawer.prototype._animationDoneListener = \r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    function (event) {\r\n        this._animationEnd.next(event);\r\n    };\r\n    MatDrawer.decorators = [\r\n        { type: Component, args: [{selector: 'mat-drawer',\r\n                    exportAs: 'matDrawer',\r\n                    template: \"<div class=\\\"mat-drawer-inner-container\\\"><ng-content></ng-content></div>\",\r\n                    animations: [matDrawerAnimations.transformDrawer],\r\n                    host: {\r\n                        'class': 'mat-drawer',\r\n                        // must prevent the browser from aligning text based on value\r\n                        '[attr.align]': 'null',\r\n                        '[class.mat-drawer-end]': 'position === \"end\"',\r\n                        '[class.mat-drawer-over]': 'mode === \"over\"',\r\n                        '[class.mat-drawer-push]': 'mode === \"push\"',\r\n                        '[class.mat-drawer-side]': 'mode === \"side\"',\r\n                        '[class.mat-drawer-opened]': 'opened',\r\n                        'tabIndex': '-1',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDrawer.ctorParameters = function () { return [\r\n        { type: ElementRef },\r\n        { type: FocusTrapFactory },\r\n        { type: FocusMonitor },\r\n        { type: Platform },\r\n        { type: NgZone },\r\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n    ]; };\r\n    MatDrawer.propDecorators = {\r\n        position: [{ type: Input }],\r\n        mode: [{ type: Input }],\r\n        disableClose: [{ type: Input }],\r\n        autoFocus: [{ type: Input }],\r\n        _animationState: [{ type: HostBinding, args: ['@transform',] }],\r\n        openedChange: [{ type: Output }],\r\n        _openedStream: [{ type: Output, args: ['opened',] }],\r\n        openedStart: [{ type: Output }],\r\n        _closedStream: [{ type: Output, args: ['closed',] }],\r\n        closedStart: [{ type: Output }],\r\n        onPositionChanged: [{ type: Output, args: ['positionChanged',] }],\r\n        opened: [{ type: Input }],\r\n        _animationStartListener: [{ type: HostListener, args: ['@transform.start', ['$event'],] }],\r\n        _animationDoneListener: [{ type: HostListener, args: ['@transform.done', ['$event'],] }]\r\n    };\r\n    return MatDrawer;\r\n}());\r\n/**\r\n * `<mat-drawer-container>` component.\r\n *\r\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\r\n * and coordinates the backdrop and content styling.\r\n */\r\nvar MatDrawerContainer = /** @class */ (function () {\r\n    function MatDrawerContainer(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize, _animationMode) {\r\n        var _this = this;\r\n        if (defaultAutosize === void 0) { defaultAutosize = false; }\r\n        this._dir = _dir;\r\n        this._element = _element;\r\n        this._ngZone = _ngZone;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._animationMode = _animationMode;\r\n        /**\r\n         * Event emitted when the drawer backdrop is clicked.\r\n         */\r\n        this.backdropClick = new EventEmitter();\r\n        /**\r\n         * Emits when the component is destroyed.\r\n         */\r\n        this._destroyed = new Subject();\r\n        /**\r\n         * Emits on every ngDoCheck. Used for debouncing reflows.\r\n         */\r\n        this._doCheckSubject = new Subject();\r\n        /**\r\n         * Margins to be applied to the content. These are used to push / shrink the drawer content when a\r\n         * drawer is open. We use margin rather than transform even for push mode because transform breaks\r\n         * fixed position elements inside of the transformed element.\r\n         */\r\n        this._contentMargins = { left: null, right: null };\r\n        this._contentMarginChanges = new Subject();\r\n        // If a `Dir` directive exists up the tree, listen direction changes\r\n        // and update the left/right properties to point to the proper start/end.\r\n        if (_dir) {\r\n            _dir.change.pipe(takeUntil(this._destroyed)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this._validateDrawers();\r\n                _this.updateContentMargins();\r\n            }));\r\n        }\r\n        // Since the minimum width of the sidenav depends on the viewport width,\r\n        // we need to recompute the margins if the viewport changes.\r\n        viewportRuler.change()\r\n            .pipe(takeUntil(this._destroyed))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this.updateContentMargins(); }));\r\n        this._autosize = defaultAutosize;\r\n    }\r\n    Object.defineProperty(MatDrawerContainer.prototype, \"start\", {\r\n        /** The drawer child with the `start` position. */\r\n        get: /**\r\n         * The drawer child with the `start` position.\r\n         * @return {?}\r\n         */\r\n        function () { return this._start; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawerContainer.prototype, \"end\", {\r\n        /** The drawer child with the `end` position. */\r\n        get: /**\r\n         * The drawer child with the `end` position.\r\n         * @return {?}\r\n         */\r\n        function () { return this._end; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawerContainer.prototype, \"autosize\", {\r\n        /**\r\n         * Whether to automatically resize the container whenever\r\n         * the size of any of its drawers changes.\r\n         *\r\n         * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\r\n         * the drawers on every change detection cycle. Can be configured globally via the\r\n         * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\r\n         */\r\n        get: /**\r\n         * Whether to automatically resize the container whenever\r\n         * the size of any of its drawers changes.\r\n         *\r\n         * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\r\n         * the drawers on every change detection cycle. Can be configured globally via the\r\n         * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\r\n         * @return {?}\r\n         */\r\n        function () { return this._autosize; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._autosize = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawerContainer.prototype, \"hasBackdrop\", {\r\n        /**\r\n         * Whether the drawer container should have a backdrop while one of the sidenavs is open.\r\n         * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\r\n         * mode as well.\r\n         */\r\n        get: /**\r\n         * Whether the drawer container should have a backdrop while one of the sidenavs is open.\r\n         * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\r\n         * mode as well.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            if (this._backdropOverride == null) {\r\n                return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\r\n            }\r\n            return this._backdropOverride;\r\n        },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) {\r\n            this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatDrawerContainer.prototype, \"scrollable\", {\r\n        /** Reference to the CdkScrollable instance that wraps the scrollable content. */\r\n        get: /**\r\n         * Reference to the CdkScrollable instance that wraps the scrollable content.\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return this._userContent || this._content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.ngAfterContentInit = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._drawers.changes.pipe(startWith(null)).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._validateDrawers();\r\n            _this._drawers.forEach((/**\r\n             * @param {?} drawer\r\n             * @return {?}\r\n             */\r\n            function (drawer) {\r\n                _this._watchDrawerToggle(drawer);\r\n                _this._watchDrawerPosition(drawer);\r\n                _this._watchDrawerMode(drawer);\r\n            }));\r\n            if (!_this._drawers.length ||\r\n                _this._isDrawerOpen(_this._start) ||\r\n                _this._isDrawerOpen(_this._end)) {\r\n                _this.updateContentMargins();\r\n            }\r\n            _this._changeDetectorRef.markForCheck();\r\n        }));\r\n        this._doCheckSubject.pipe(debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\r\n        takeUntil(this._destroyed)).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () { return _this.updateContentMargins(); }));\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.ngOnDestroy = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._contentMarginChanges.complete();\r\n        this._doCheckSubject.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    };\r\n    /** Calls `open` of both start and end drawers */\r\n    /**\r\n     * Calls `open` of both start and end drawers\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.open = /**\r\n     * Calls `open` of both start and end drawers\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._drawers.forEach((/**\r\n         * @param {?} drawer\r\n         * @return {?}\r\n         */\r\n        function (drawer) { return drawer.open(); }));\r\n    };\r\n    /** Calls `close` of both start and end drawers */\r\n    /**\r\n     * Calls `close` of both start and end drawers\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.close = /**\r\n     * Calls `close` of both start and end drawers\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this._drawers.forEach((/**\r\n         * @param {?} drawer\r\n         * @return {?}\r\n         */\r\n        function (drawer) { return drawer.close(); }));\r\n    };\r\n    /**\r\n     * Recalculates and updates the inline styles for the content. Note that this should be used\r\n     * sparingly, because it causes a reflow.\r\n     */\r\n    /**\r\n     * Recalculates and updates the inline styles for the content. Note that this should be used\r\n     * sparingly, because it causes a reflow.\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.updateContentMargins = /**\r\n     * Recalculates and updates the inline styles for the content. Note that this should be used\r\n     * sparingly, because it causes a reflow.\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // 1. For drawers in `over` mode, they don't affect the content.\r\n        // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\r\n        //    left margin (for left drawer) or right margin (for right the drawer).\r\n        // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\r\n        //    adding to the left or right margin and simultaneously subtracting the same amount of\r\n        //    margin from the other side.\r\n        /** @type {?} */\r\n        var left = 0;\r\n        /** @type {?} */\r\n        var right = 0;\r\n        if (this._left && this._left.opened) {\r\n            if (this._left.mode == 'side') {\r\n                left += this._left._width;\r\n            }\r\n            else if (this._left.mode == 'push') {\r\n                /** @type {?} */\r\n                var width = this._left._width;\r\n                left += width;\r\n                right -= width;\r\n            }\r\n        }\r\n        if (this._right && this._right.opened) {\r\n            if (this._right.mode == 'side') {\r\n                right += this._right._width;\r\n            }\r\n            else if (this._right.mode == 'push') {\r\n                /** @type {?} */\r\n                var width = this._right._width;\r\n                right += width;\r\n                left -= width;\r\n            }\r\n        }\r\n        // If either `right` or `left` is zero, don't set a style to the element. This\r\n        // allows users to specify a custom size via CSS class in SSR scenarios where the\r\n        // measured widths will always be zero. Note that we reset to `null` here, rather\r\n        // than below, in order to ensure that the types in the `if` below are consistent.\r\n        left = left || (/** @type {?} */ (null));\r\n        right = right || (/** @type {?} */ (null));\r\n        if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\r\n            this._contentMargins = { left: left, right: right };\r\n            // Pull back into the NgZone since in some cases we could be outside. We need to be careful\r\n            // to do it only when something changed, otherwise we can end up hitting the zone too often.\r\n            this._ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._contentMarginChanges.next(_this._contentMargins); }));\r\n        }\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype.ngDoCheck = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // If users opted into autosizing, do a check every change detection cycle.\r\n        if (this._autosize && this._isPushed()) {\r\n            // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\r\n            this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            function () { return _this._doCheckSubject.next(); }));\r\n        }\r\n    };\r\n    /**\r\n     * Subscribes to drawer events in order to set a class on the main container element when the\r\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n     * is properly hidden.\r\n     */\r\n    /**\r\n     * Subscribes to drawer events in order to set a class on the main container element when the\r\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n     * is properly hidden.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._watchDrawerToggle = /**\r\n     * Subscribes to drawer events in order to set a class on the main container element when the\r\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n     * is properly hidden.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    function (drawer) {\r\n        var _this = this;\r\n        drawer._animationStarted.pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) { return event.fromState !== event.toState; })), takeUntil(this._drawers.changes))\r\n            .subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        function (event) {\r\n            // Set the transition class on the container so that the animations occur. This should not\r\n            // be set initially because animations should only be triggered via a change in state.\r\n            if (event.toState !== 'open-instant' && _this._animationMode !== 'NoopAnimations') {\r\n                _this._element.nativeElement.classList.add('mat-drawer-transition');\r\n            }\r\n            _this.updateContentMargins();\r\n            _this._changeDetectorRef.markForCheck();\r\n        }));\r\n        if (drawer.mode !== 'side') {\r\n            drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                return _this._setContainerClass(drawer.opened);\r\n            }));\r\n        }\r\n    };\r\n    /**\r\n     * Subscribes to drawer onPositionChanged event in order to\r\n     * re-validate drawers when the position changes.\r\n     */\r\n    /**\r\n     * Subscribes to drawer onPositionChanged event in order to\r\n     * re-validate drawers when the position changes.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._watchDrawerPosition = /**\r\n     * Subscribes to drawer onPositionChanged event in order to\r\n     * re-validate drawers when the position changes.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    function (drawer) {\r\n        var _this = this;\r\n        if (!drawer) {\r\n            return;\r\n        }\r\n        // NOTE: We need to wait for the microtask queue to be empty before validating,\r\n        // since both drawers may be swapping positions at the same time.\r\n        drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            _this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this._validateDrawers();\r\n            }));\r\n        }));\r\n    };\r\n    /** Subscribes to changes in drawer mode so we can run change detection. */\r\n    /**\r\n     * Subscribes to changes in drawer mode so we can run change detection.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._watchDrawerMode = /**\r\n     * Subscribes to changes in drawer mode so we can run change detection.\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    function (drawer) {\r\n        var _this = this;\r\n        if (drawer) {\r\n            drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\r\n                .subscribe((/**\r\n             * @return {?}\r\n             */\r\n            function () {\r\n                _this.updateContentMargins();\r\n                _this._changeDetectorRef.markForCheck();\r\n            }));\r\n        }\r\n    };\r\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\r\n    /**\r\n     * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\r\n     * @private\r\n     * @param {?} isAdd\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._setContainerClass = /**\r\n     * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\r\n     * @private\r\n     * @param {?} isAdd\r\n     * @return {?}\r\n     */\r\n    function (isAdd) {\r\n        /** @type {?} */\r\n        var classList = this._element.nativeElement.classList;\r\n        /** @type {?} */\r\n        var className = 'mat-drawer-container-has-open';\r\n        if (isAdd) {\r\n            classList.add(className);\r\n        }\r\n        else {\r\n            classList.remove(className);\r\n        }\r\n    };\r\n    /** Validate the state of the drawer children components. */\r\n    /**\r\n     * Validate the state of the drawer children components.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._validateDrawers = /**\r\n     * Validate the state of the drawer children components.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        this._start = this._end = null;\r\n        // Ensure that we have at most one start and one end drawer.\r\n        this._drawers.forEach((/**\r\n         * @param {?} drawer\r\n         * @return {?}\r\n         */\r\n        function (drawer) {\r\n            if (drawer.position == 'end') {\r\n                if (_this._end != null) {\r\n                    throwMatDuplicatedDrawerError('end');\r\n                }\r\n                _this._end = drawer;\r\n            }\r\n            else {\r\n                if (_this._start != null) {\r\n                    throwMatDuplicatedDrawerError('start');\r\n                }\r\n                _this._start = drawer;\r\n            }\r\n        }));\r\n        this._right = this._left = null;\r\n        // Detect if we're LTR or RTL.\r\n        if (this._dir && this._dir.value === 'rtl') {\r\n            this._left = this._end;\r\n            this._right = this._start;\r\n        }\r\n        else {\r\n            this._left = this._start;\r\n            this._right = this._end;\r\n        }\r\n    };\r\n    /** Whether the container is being pushed to the side by one of the drawers. */\r\n    /**\r\n     * Whether the container is being pushed to the side by one of the drawers.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._isPushed = /**\r\n     * Whether the container is being pushed to the side by one of the drawers.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\r\n            (this._isDrawerOpen(this._end) && this._end.mode != 'over');\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._onBackdropClicked = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        this.backdropClick.emit();\r\n        this._closeModalDrawer();\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._closeModalDrawer = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        var _this = this;\r\n        // Close all open drawers where closing is not disabled and the mode is not `side`.\r\n        [this._start, this._end]\r\n            .filter((/**\r\n         * @param {?} drawer\r\n         * @return {?}\r\n         */\r\n        function (drawer) { return drawer && !drawer.disableClose && _this._canHaveBackdrop(drawer); }))\r\n            .forEach((/**\r\n         * @param {?} drawer\r\n         * @return {?}\r\n         */\r\n        function (drawer) { return (/** @type {?} */ (drawer)).close(); }));\r\n    };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._isShowingBackdrop = /**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\r\n            (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._canHaveBackdrop = /**\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    function (drawer) {\r\n        return drawer.mode !== 'side' || !!this._backdropOverride;\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    MatDrawerContainer.prototype._isDrawerOpen = /**\r\n     * @private\r\n     * @param {?} drawer\r\n     * @return {?}\r\n     */\r\n    function (drawer) {\r\n        return drawer != null && drawer.opened;\r\n    };\r\n    MatDrawerContainer.decorators = [\r\n        { type: Component, args: [{selector: 'mat-drawer-container',\r\n                    exportAs: 'matDrawerContainer',\r\n                    template: \"<div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\" *ngIf=\\\"hasBackdrop\\\" [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div><ng-content select=\\\"mat-drawer\\\"></ng-content><ng-content select=\\\"mat-drawer-content\\\"></ng-content><mat-drawer-content *ngIf=\\\"!_content\\\"><ng-content></ng-content></mat-drawer-content>\",\r\n                    styles: [\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"],\r\n                    host: {\r\n                        'class': 'mat-drawer-container',\r\n                        '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatDrawerContainer.ctorParameters = function () { return [\r\n        { type: Directionality, decorators: [{ type: Optional }] },\r\n        { type: ElementRef },\r\n        { type: NgZone },\r\n        { type: ChangeDetectorRef },\r\n        { type: ViewportRuler },\r\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_DRAWER_DEFAULT_AUTOSIZE,] }] },\r\n        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\r\n    ]; };\r\n    MatDrawerContainer.propDecorators = {\r\n        _drawers: [{ type: ContentChildren, args: [MatDrawer,] }],\r\n        _content: [{ type: ContentChild, args: [MatDrawerContent, { static: false },] }],\r\n        _userContent: [{ type: ViewChild, args: [MatDrawerContent, { static: false },] }],\r\n        autosize: [{ type: Input }],\r\n        hasBackdrop: [{ type: Input }],\r\n        backdropClick: [{ type: Output }]\r\n    };\r\n    return MatDrawerContainer;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatSidenavContent = /** @class */ (function (_super) {\r\n    __extends(MatSidenavContent, _super);\r\n    function MatSidenavContent(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {\r\n        return _super.call(this, changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) || this;\r\n    }\r\n    MatSidenavContent.decorators = [\r\n        { type: Component, args: [{selector: 'mat-sidenav-content',\r\n                    template: '<ng-content></ng-content>',\r\n                    host: {\r\n                        'class': 'mat-drawer-content mat-sidenav-content',\r\n                        '[style.margin-left.px]': '_container._contentMargins.left',\r\n                        '[style.margin-right.px]': '_container._contentMargins.right',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    /** @nocollapse */\r\n    MatSidenavContent.ctorParameters = function () { return [\r\n        { type: ChangeDetectorRef },\r\n        { type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef((/**\r\n                         * @return {?}\r\n                         */\r\n                        function () { return MatSidenavContainer; })),] }] },\r\n        { type: ElementRef },\r\n        { type: ScrollDispatcher },\r\n        { type: NgZone }\r\n    ]; };\r\n    return MatSidenavContent;\r\n}(MatDrawerContent));\r\nvar MatSidenav = /** @class */ (function (_super) {\r\n    __extends(MatSidenav, _super);\r\n    function MatSidenav() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._fixedInViewport = false;\r\n        _this._fixedTopGap = 0;\r\n        _this._fixedBottomGap = 0;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MatSidenav.prototype, \"fixedInViewport\", {\r\n        /** Whether the sidenav is fixed in the viewport. */\r\n        get: /**\r\n         * Whether the sidenav is fixed in the viewport.\r\n         * @return {?}\r\n         */\r\n        function () { return this._fixedInViewport; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._fixedInViewport = coerceBooleanProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatSidenav.prototype, \"fixedTopGap\", {\r\n        /**\r\n         * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\r\n         * mode.\r\n         */\r\n        get: /**\r\n         * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\r\n         * mode.\r\n         * @return {?}\r\n         */\r\n        function () { return this._fixedTopGap; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._fixedTopGap = coerceNumberProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MatSidenav.prototype, \"fixedBottomGap\", {\r\n        /**\r\n         * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\r\n         * fixed mode.\r\n         */\r\n        get: /**\r\n         * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\r\n         * fixed mode.\r\n         * @return {?}\r\n         */\r\n        function () { return this._fixedBottomGap; },\r\n        set: /**\r\n         * @param {?} value\r\n         * @return {?}\r\n         */\r\n        function (value) { this._fixedBottomGap = coerceNumberProperty(value); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MatSidenav.decorators = [\r\n        { type: Component, args: [{selector: 'mat-sidenav',\r\n                    exportAs: 'matSidenav',\r\n                    template: \"<div class=\\\"mat-drawer-inner-container\\\"><ng-content></ng-content></div>\",\r\n                    animations: [matDrawerAnimations.transformDrawer],\r\n                    host: {\r\n                        'class': 'mat-drawer mat-sidenav',\r\n                        'tabIndex': '-1',\r\n                        // must prevent the browser from aligning text based on value\r\n                        '[attr.align]': 'null',\r\n                        '[class.mat-drawer-end]': 'position === \"end\"',\r\n                        '[class.mat-drawer-over]': 'mode === \"over\"',\r\n                        '[class.mat-drawer-push]': 'mode === \"push\"',\r\n                        '[class.mat-drawer-side]': 'mode === \"side\"',\r\n                        '[class.mat-drawer-opened]': 'opened',\r\n                        '[class.mat-sidenav-fixed]': 'fixedInViewport',\r\n                        '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',\r\n                        '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    MatSidenav.propDecorators = {\r\n        fixedInViewport: [{ type: Input }],\r\n        fixedTopGap: [{ type: Input }],\r\n        fixedBottomGap: [{ type: Input }]\r\n    };\r\n    return MatSidenav;\r\n}(MatDrawer));\r\nvar MatSidenavContainer = /** @class */ (function (_super) {\r\n    __extends(MatSidenavContainer, _super);\r\n    function MatSidenavContainer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    MatSidenavContainer.decorators = [\r\n        { type: Component, args: [{selector: 'mat-sidenav-container',\r\n                    exportAs: 'matSidenavContainer',\r\n                    template: \"<div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\" *ngIf=\\\"hasBackdrop\\\" [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div><ng-content select=\\\"mat-sidenav\\\"></ng-content><ng-content select=\\\"mat-sidenav-content\\\"></ng-content><mat-sidenav-content *ngIf=\\\"!_content\\\" cdkScrollable><ng-content></ng-content></mat-sidenav-content>\",\r\n                    styles: [\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"],\r\n                    host: {\r\n                        'class': 'mat-drawer-container mat-sidenav-container',\r\n                        '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\r\n                    },\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    encapsulation: ViewEncapsulation.None,\r\n                },] },\r\n    ];\r\n    MatSidenavContainer.propDecorators = {\r\n        _drawers: [{ type: ContentChildren, args: [MatSidenav,] }],\r\n        _content: [{ type: ContentChild, args: [MatSidenavContent, { static: false },] }]\r\n    };\r\n    return MatSidenavContainer;\r\n}(MatDrawerContainer));\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nvar MatSidenavModule = /** @class */ (function () {\r\n    function MatSidenavModule() {\r\n    }\r\n    MatSidenavModule.decorators = [\r\n        { type: NgModule, args: [{\r\n                    imports: [\r\n                        CommonModule,\r\n                        MatCommonModule,\r\n                        ScrollingModule,\r\n                        PlatformModule,\r\n                    ],\r\n                    exports: [\r\n                        MatCommonModule,\r\n                        MatDrawer,\r\n                        MatDrawerContainer,\r\n                        MatDrawerContent,\r\n                        MatSidenav,\r\n                        MatSidenavContainer,\r\n                        MatSidenavContent,\r\n                    ],\r\n                    declarations: [\r\n                        MatDrawer,\r\n                        MatDrawerContainer,\r\n                        MatDrawerContent,\r\n                        MatSidenav,\r\n                        MatSidenavContainer,\r\n                        MatSidenavContent,\r\n                    ],\r\n                },] },\r\n    ];\r\n    return MatSidenavModule;\r\n}());\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MatSidenavModule, throwMatDuplicatedDrawerError, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MAT_DRAWER_DEFAULT_AUTOSIZE, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, matDrawerAnimations };\r\n\r\n"]}